// Generated from KotlinParser.g4 by ANTLR 4.8
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(nonstandard_style)]
#![allow(unused_imports)]
#![allow(unused_mut)]
use antlr_rust::PredictionContextCache;
use antlr_rust::parser::{Parser, BaseParser, ParserRecog, ParserNodeType};
use antlr_rust::token_stream::TokenStream;
use antlr_rust::TokenSource;
use antlr_rust::parser_atn_simulator::ParserATNSimulator;
use antlr_rust::errors::*;
use antlr_rust::rule_context::{BaseRuleContext, CustomRuleContext, RuleContext};
use antlr_rust::recognizer::{Recognizer,Actions};
use antlr_rust::atn_deserializer::ATNDeserializer;
use antlr_rust::dfa::DFA;
use antlr_rust::atn::{ATN, INVALID_ALT};
use antlr_rust::error_strategy::{ErrorStrategy, DefaultErrorStrategy};
use antlr_rust::parser_rule_context::{BaseParserRuleContext, ParserRuleContext,cast,cast_mut};
use antlr_rust::tree::*;
use antlr_rust::token::{TOKEN_EOF,OwningToken,Token};
use antlr_rust::int_stream::EOF;
use antlr_rust::vocabulary::{Vocabulary,VocabularyImpl};
use antlr_rust::token_factory::{CommonTokenFactory,TokenFactory, TokenAware};
use super::kotlinparserlistener::*;
use super::kotlinparservisitor::*;

use antlr_rust::lazy_static;
use antlr_rust::{TidAble,TidExt};

use std::marker::PhantomData;
use std::sync::Arc;
use std::rc::Rc;
use std::convert::TryFrom;
use std::cell::RefCell;
use std::ops::{DerefMut, Deref};
use std::borrow::{Borrow,BorrowMut};
use std::any::{Any,TypeId};

		pub const ShebangLine:isize=1; 
		pub const DelimitedComment:isize=2; 
		pub const LineComment:isize=3; 
		pub const WS:isize=4; 
		pub const NL:isize=5; 
		pub const RESERVED:isize=6; 
		pub const DOT:isize=7; 
		pub const COMMA:isize=8; 
		pub const LPAREN:isize=9; 
		pub const RPAREN:isize=10; 
		pub const LSQUARE:isize=11; 
		pub const RSQUARE:isize=12; 
		pub const LCURL:isize=13; 
		pub const RCURL:isize=14; 
		pub const MULT:isize=15; 
		pub const MOD:isize=16; 
		pub const DIV:isize=17; 
		pub const ADD:isize=18; 
		pub const SUB:isize=19; 
		pub const INCR:isize=20; 
		pub const DECR:isize=21; 
		pub const CONJ:isize=22; 
		pub const DISJ:isize=23; 
		pub const EXCL_WS:isize=24; 
		pub const EXCL_NO_WS:isize=25; 
		pub const COLON:isize=26; 
		pub const SEMICOLON:isize=27; 
		pub const ASSIGNMENT:isize=28; 
		pub const ADD_ASSIGNMENT:isize=29; 
		pub const SUB_ASSIGNMENT:isize=30; 
		pub const MULT_ASSIGNMENT:isize=31; 
		pub const DIV_ASSIGNMENT:isize=32; 
		pub const MOD_ASSIGNMENT:isize=33; 
		pub const ARROW:isize=34; 
		pub const DOUBLE_ARROW:isize=35; 
		pub const RANGE:isize=36; 
		pub const COLONCOLON:isize=37; 
		pub const DOUBLE_SEMICOLON:isize=38; 
		pub const HASH:isize=39; 
		pub const AT_NO_WS:isize=40; 
		pub const AT_POST_WS:isize=41; 
		pub const AT_PRE_WS:isize=42; 
		pub const AT_BOTH_WS:isize=43; 
		pub const QUEST_WS:isize=44; 
		pub const QUEST_NO_WS:isize=45; 
		pub const LANGLE:isize=46; 
		pub const RANGLE:isize=47; 
		pub const LE:isize=48; 
		pub const GE:isize=49; 
		pub const EXCL_EQ:isize=50; 
		pub const EXCL_EQEQ:isize=51; 
		pub const AS_SAFE:isize=52; 
		pub const EQEQ:isize=53; 
		pub const EQEQEQ:isize=54; 
		pub const SINGLE_QUOTE:isize=55; 
		pub const RETURN_AT:isize=56; 
		pub const CONTINUE_AT:isize=57; 
		pub const BREAK_AT:isize=58; 
		pub const THIS_AT:isize=59; 
		pub const SUPER_AT:isize=60; 
		pub const FILE:isize=61; 
		pub const FIELD:isize=62; 
		pub const PROPERTY:isize=63; 
		pub const GET:isize=64; 
		pub const SET:isize=65; 
		pub const RECEIVER:isize=66; 
		pub const PARAM:isize=67; 
		pub const SETPARAM:isize=68; 
		pub const DELEGATE:isize=69; 
		pub const PACKAGE:isize=70; 
		pub const IMPORT:isize=71; 
		pub const CLASS:isize=72; 
		pub const INTERFACE:isize=73; 
		pub const FUN:isize=74; 
		pub const OBJECT:isize=75; 
		pub const VAL:isize=76; 
		pub const VAR:isize=77; 
		pub const TYPE_ALIAS:isize=78; 
		pub const CONSTRUCTOR:isize=79; 
		pub const BY:isize=80; 
		pub const COMPANION:isize=81; 
		pub const INIT:isize=82; 
		pub const THIS:isize=83; 
		pub const SUPER:isize=84; 
		pub const TYPEOF:isize=85; 
		pub const WHERE:isize=86; 
		pub const IF:isize=87; 
		pub const ELSE:isize=88; 
		pub const WHEN:isize=89; 
		pub const TRY:isize=90; 
		pub const CATCH:isize=91; 
		pub const FINALLY:isize=92; 
		pub const FOR:isize=93; 
		pub const DO:isize=94; 
		pub const WHILE:isize=95; 
		pub const THROW:isize=96; 
		pub const RETURN:isize=97; 
		pub const CONTINUE:isize=98; 
		pub const BREAK:isize=99; 
		pub const AS:isize=100; 
		pub const IS:isize=101; 
		pub const IN:isize=102; 
		pub const NOT_IS:isize=103; 
		pub const NOT_IN:isize=104; 
		pub const OUT:isize=105; 
		pub const DYNAMIC:isize=106; 
		pub const PUBLIC:isize=107; 
		pub const PRIVATE:isize=108; 
		pub const PROTECTED:isize=109; 
		pub const INTERNAL:isize=110; 
		pub const ENUM:isize=111; 
		pub const SEALED:isize=112; 
		pub const ANNOTATION:isize=113; 
		pub const DATA:isize=114; 
		pub const INNER:isize=115; 
		pub const VALUE:isize=116; 
		pub const TAILREC:isize=117; 
		pub const OPERATOR:isize=118; 
		pub const INLINE:isize=119; 
		pub const INFIX:isize=120; 
		pub const EXTERNAL:isize=121; 
		pub const SUSPEND:isize=122; 
		pub const OVERRIDE:isize=123; 
		pub const ABSTRACT:isize=124; 
		pub const FINAL:isize=125; 
		pub const OPEN:isize=126; 
		pub const CONST:isize=127; 
		pub const LATEINIT:isize=128; 
		pub const VARARG:isize=129; 
		pub const NOINLINE:isize=130; 
		pub const CROSSINLINE:isize=131; 
		pub const REIFIED:isize=132; 
		pub const EXPECT:isize=133; 
		pub const ACTUAL:isize=134; 
		pub const RealLiteral:isize=135; 
		pub const FloatLiteral:isize=136; 
		pub const DoubleLiteral:isize=137; 
		pub const IntegerLiteral:isize=138; 
		pub const HexLiteral:isize=139; 
		pub const BinLiteral:isize=140; 
		pub const UnsignedLiteral:isize=141; 
		pub const LongLiteral:isize=142; 
		pub const BooleanLiteral:isize=143; 
		pub const NullLiteral:isize=144; 
		pub const CharacterLiteral:isize=145; 
		pub const Identifier:isize=146; 
		pub const IdentifierOrSoftKey:isize=147; 
		pub const FieldIdentifier:isize=148; 
		pub const QUOTE_OPEN:isize=149; 
		pub const TRIPLE_QUOTE_OPEN:isize=150; 
		pub const UNICODE_CLASS_LL:isize=151; 
		pub const UNICODE_CLASS_LM:isize=152; 
		pub const UNICODE_CLASS_LO:isize=153; 
		pub const UNICODE_CLASS_LT:isize=154; 
		pub const UNICODE_CLASS_LU:isize=155; 
		pub const UNICODE_CLASS_ND:isize=156; 
		pub const UNICODE_CLASS_NL:isize=157; 
		pub const QUOTE_CLOSE:isize=158; 
		pub const LineStrRef:isize=159; 
		pub const LineStrText:isize=160; 
		pub const LineStrEscapedChar:isize=161; 
		pub const LineStrExprStart:isize=162; 
		pub const TRIPLE_QUOTE_CLOSE:isize=163; 
		pub const MultiLineStringQuote:isize=164; 
		pub const MultiLineStrRef:isize=165; 
		pub const MultiLineStrText:isize=166; 
		pub const MultiLineStrExprStart:isize=167; 
		pub const Inside_Comment:isize=168; 
		pub const Inside_WS:isize=169; 
		pub const Inside_NL:isize=170; 
		pub const ErrorCharacter:isize=171;
	pub const RULE_kotlinFile:usize = 0; 
	pub const RULE_script:usize = 1; 
	pub const RULE_shebangLine:usize = 2; 
	pub const RULE_fileAnnotation:usize = 3; 
	pub const RULE_packageHeader:usize = 4; 
	pub const RULE_importList:usize = 5; 
	pub const RULE_importHeader:usize = 6; 
	pub const RULE_importAlias:usize = 7; 
	pub const RULE_topLevelObject:usize = 8; 
	pub const RULE_typeAlias:usize = 9; 
	pub const RULE_declaration:usize = 10; 
	pub const RULE_classDeclaration:usize = 11; 
	pub const RULE_primaryConstructor:usize = 12; 
	pub const RULE_classBody:usize = 13; 
	pub const RULE_classParameters:usize = 14; 
	pub const RULE_classParameter:usize = 15; 
	pub const RULE_delegationSpecifiers:usize = 16; 
	pub const RULE_delegationSpecifier:usize = 17; 
	pub const RULE_constructorInvocation:usize = 18; 
	pub const RULE_annotatedDelegationSpecifier:usize = 19; 
	pub const RULE_explicitDelegation:usize = 20; 
	pub const RULE_typeParameters:usize = 21; 
	pub const RULE_typeParameter:usize = 22; 
	pub const RULE_typeConstraints:usize = 23; 
	pub const RULE_typeConstraint:usize = 24; 
	pub const RULE_classMemberDeclarations:usize = 25; 
	pub const RULE_classMemberDeclaration:usize = 26; 
	pub const RULE_anonymousInitializer:usize = 27; 
	pub const RULE_companionObject:usize = 28; 
	pub const RULE_functionValueParameters:usize = 29; 
	pub const RULE_functionValueParameter:usize = 30; 
	pub const RULE_functionDeclaration:usize = 31; 
	pub const RULE_functionBody:usize = 32; 
	pub const RULE_variableDeclaration:usize = 33; 
	pub const RULE_multiVariableDeclaration:usize = 34; 
	pub const RULE_propertyDeclaration:usize = 35; 
	pub const RULE_propertyDelegate:usize = 36; 
	pub const RULE_getter:usize = 37; 
	pub const RULE_setter:usize = 38; 
	pub const RULE_parametersWithOptionalType:usize = 39; 
	pub const RULE_functionValueParameterWithOptionalType:usize = 40; 
	pub const RULE_parameterWithOptionalType:usize = 41; 
	pub const RULE_parameter:usize = 42; 
	pub const RULE_objectDeclaration:usize = 43; 
	pub const RULE_secondaryConstructor:usize = 44; 
	pub const RULE_constructorDelegationCall:usize = 45; 
	pub const RULE_enumClassBody:usize = 46; 
	pub const RULE_enumEntries:usize = 47; 
	pub const RULE_enumEntry:usize = 48; 
	pub const RULE_rustType:usize = 49; 
	pub const RULE_typeReference:usize = 50; 
	pub const RULE_nullableType:usize = 51; 
	pub const RULE_quest:usize = 52; 
	pub const RULE_userType:usize = 53; 
	pub const RULE_simpleUserType:usize = 54; 
	pub const RULE_typeProjection:usize = 55; 
	pub const RULE_typeProjectionModifiers:usize = 56; 
	pub const RULE_typeProjectionModifier:usize = 57; 
	pub const RULE_functionType:usize = 58; 
	pub const RULE_functionTypeParameters:usize = 59; 
	pub const RULE_parenthesizedType:usize = 60; 
	pub const RULE_receiverType:usize = 61; 
	pub const RULE_parenthesizedUserType:usize = 62; 
	pub const RULE_statements:usize = 63; 
	pub const RULE_statement:usize = 64; 
	pub const RULE_label:usize = 65; 
	pub const RULE_controlStructureBody:usize = 66; 
	pub const RULE_block:usize = 67; 
	pub const RULE_loopStatement:usize = 68; 
	pub const RULE_forStatement:usize = 69; 
	pub const RULE_whileStatement:usize = 70; 
	pub const RULE_doWhileStatement:usize = 71; 
	pub const RULE_assignment:usize = 72; 
	pub const RULE_semi:usize = 73; 
	pub const RULE_semis:usize = 74; 
	pub const RULE_expression:usize = 75; 
	pub const RULE_disjunction:usize = 76; 
	pub const RULE_conjunction:usize = 77; 
	pub const RULE_equality:usize = 78; 
	pub const RULE_comparison:usize = 79; 
	pub const RULE_genericCallLikeComparison:usize = 80; 
	pub const RULE_infixOperation:usize = 81; 
	pub const RULE_elvisExpression:usize = 82; 
	pub const RULE_elvis:usize = 83; 
	pub const RULE_infixFunctionCall:usize = 84; 
	pub const RULE_rangeExpression:usize = 85; 
	pub const RULE_additiveExpression:usize = 86; 
	pub const RULE_multiplicativeExpression:usize = 87; 
	pub const RULE_asExpression:usize = 88; 
	pub const RULE_prefixUnaryExpression:usize = 89; 
	pub const RULE_unaryPrefix:usize = 90; 
	pub const RULE_postfixUnaryExpression:usize = 91; 
	pub const RULE_postfixUnarySuffix:usize = 92; 
	pub const RULE_directlyAssignableExpression:usize = 93; 
	pub const RULE_parenthesizedDirectlyAssignableExpression:usize = 94; 
	pub const RULE_assignableExpression:usize = 95; 
	pub const RULE_parenthesizedAssignableExpression:usize = 96; 
	pub const RULE_assignableSuffix:usize = 97; 
	pub const RULE_indexingSuffix:usize = 98; 
	pub const RULE_navigationSuffix:usize = 99; 
	pub const RULE_callSuffix:usize = 100; 
	pub const RULE_annotatedLambda:usize = 101; 
	pub const RULE_typeArguments:usize = 102; 
	pub const RULE_valueArguments:usize = 103; 
	pub const RULE_valueArgument:usize = 104; 
	pub const RULE_primaryExpression:usize = 105; 
	pub const RULE_parenthesizedExpression:usize = 106; 
	pub const RULE_collectionLiteral:usize = 107; 
	pub const RULE_literalConstant:usize = 108; 
	pub const RULE_stringLiteral:usize = 109; 
	pub const RULE_lineStringLiteral:usize = 110; 
	pub const RULE_multiLineStringLiteral:usize = 111; 
	pub const RULE_lineStringContent:usize = 112; 
	pub const RULE_lineStringExpression:usize = 113; 
	pub const RULE_multiLineStringContent:usize = 114; 
	pub const RULE_multiLineStringExpression:usize = 115; 
	pub const RULE_lambdaLiteral:usize = 116; 
	pub const RULE_lambdaParameters:usize = 117; 
	pub const RULE_lambdaParameter:usize = 118; 
	pub const RULE_anonymousFunction:usize = 119; 
	pub const RULE_functionLiteral:usize = 120; 
	pub const RULE_objectLiteral:usize = 121; 
	pub const RULE_thisExpression:usize = 122; 
	pub const RULE_superExpression:usize = 123; 
	pub const RULE_ifExpression:usize = 124; 
	pub const RULE_whenSubject:usize = 125; 
	pub const RULE_whenExpression:usize = 126; 
	pub const RULE_whenEntry:usize = 127; 
	pub const RULE_whenCondition:usize = 128; 
	pub const RULE_rangeTest:usize = 129; 
	pub const RULE_typeTest:usize = 130; 
	pub const RULE_tryExpression:usize = 131; 
	pub const RULE_catchBlock:usize = 132; 
	pub const RULE_finallyBlock:usize = 133; 
	pub const RULE_jumpExpression:usize = 134; 
	pub const RULE_callableReference:usize = 135; 
	pub const RULE_assignmentAndOperator:usize = 136; 
	pub const RULE_equalityOperator:usize = 137; 
	pub const RULE_comparisonOperator:usize = 138; 
	pub const RULE_inOperator:usize = 139; 
	pub const RULE_isOperator:usize = 140; 
	pub const RULE_additiveOperator:usize = 141; 
	pub const RULE_multiplicativeOperator:usize = 142; 
	pub const RULE_asOperator:usize = 143; 
	pub const RULE_prefixUnaryOperator:usize = 144; 
	pub const RULE_postfixUnaryOperator:usize = 145; 
	pub const RULE_excl:usize = 146; 
	pub const RULE_memberAccessOperator:usize = 147; 
	pub const RULE_safeNav:usize = 148; 
	pub const RULE_modifiers:usize = 149; 
	pub const RULE_parameterModifiers:usize = 150; 
	pub const RULE_modifier:usize = 151; 
	pub const RULE_typeModifiers:usize = 152; 
	pub const RULE_typeModifier:usize = 153; 
	pub const RULE_classModifier:usize = 154; 
	pub const RULE_memberModifier:usize = 155; 
	pub const RULE_visibilityModifier:usize = 156; 
	pub const RULE_varianceModifier:usize = 157; 
	pub const RULE_typeParameterModifiers:usize = 158; 
	pub const RULE_typeParameterModifier:usize = 159; 
	pub const RULE_functionModifier:usize = 160; 
	pub const RULE_propertyModifier:usize = 161; 
	pub const RULE_inheritanceModifier:usize = 162; 
	pub const RULE_parameterModifier:usize = 163; 
	pub const RULE_reificationModifier:usize = 164; 
	pub const RULE_platformModifier:usize = 165; 
	pub const RULE_annotation:usize = 166; 
	pub const RULE_singleAnnotation:usize = 167; 
	pub const RULE_multiAnnotation:usize = 168; 
	pub const RULE_annotationUseSiteTarget:usize = 169; 
	pub const RULE_unescapedAnnotation:usize = 170; 
	pub const RULE_simpleIdentifier:usize = 171; 
	pub const RULE_identifier:usize = 172;
	pub const ruleNames: [&'static str; 173] =  [
		"kotlinFile", "script", "shebangLine", "fileAnnotation", "packageHeader", 
		"importList", "importHeader", "importAlias", "topLevelObject", "typeAlias", 
		"declaration", "classDeclaration", "primaryConstructor", "classBody", 
		"classParameters", "classParameter", "delegationSpecifiers", "delegationSpecifier", 
		"constructorInvocation", "annotatedDelegationSpecifier", "explicitDelegation", 
		"typeParameters", "typeParameter", "typeConstraints", "typeConstraint", 
		"classMemberDeclarations", "classMemberDeclaration", "anonymousInitializer", 
		"companionObject", "functionValueParameters", "functionValueParameter", 
		"functionDeclaration", "functionBody", "variableDeclaration", "multiVariableDeclaration", 
		"propertyDeclaration", "propertyDelegate", "getter", "setter", "parametersWithOptionalType", 
		"functionValueParameterWithOptionalType", "parameterWithOptionalType", 
		"parameter", "objectDeclaration", "secondaryConstructor", "constructorDelegationCall", 
		"enumClassBody", "enumEntries", "enumEntry", "rustType", "typeReference", 
		"nullableType", "quest", "userType", "simpleUserType", "typeProjection", 
		"typeProjectionModifiers", "typeProjectionModifier", "functionType", "functionTypeParameters", 
		"parenthesizedType", "receiverType", "parenthesizedUserType", "statements", 
		"statement", "label", "controlStructureBody", "block", "loopStatement", 
		"forStatement", "whileStatement", "doWhileStatement", "assignment", "semi", 
		"semis", "expression", "disjunction", "conjunction", "equality", "comparison", 
		"genericCallLikeComparison", "infixOperation", "elvisExpression", "elvis", 
		"infixFunctionCall", "rangeExpression", "additiveExpression", "multiplicativeExpression", 
		"asExpression", "prefixUnaryExpression", "unaryPrefix", "postfixUnaryExpression", 
		"postfixUnarySuffix", "directlyAssignableExpression", "parenthesizedDirectlyAssignableExpression", 
		"assignableExpression", "parenthesizedAssignableExpression", "assignableSuffix", 
		"indexingSuffix", "navigationSuffix", "callSuffix", "annotatedLambda", 
		"typeArguments", "valueArguments", "valueArgument", "primaryExpression", 
		"parenthesizedExpression", "collectionLiteral", "literalConstant", "stringLiteral", 
		"lineStringLiteral", "multiLineStringLiteral", "lineStringContent", "lineStringExpression", 
		"multiLineStringContent", "multiLineStringExpression", "lambdaLiteral", 
		"lambdaParameters", "lambdaParameter", "anonymousFunction", "functionLiteral", 
		"objectLiteral", "thisExpression", "superExpression", "ifExpression", 
		"whenSubject", "whenExpression", "whenEntry", "whenCondition", "rangeTest", 
		"typeTest", "tryExpression", "catchBlock", "finallyBlock", "jumpExpression", 
		"callableReference", "assignmentAndOperator", "equalityOperator", "comparisonOperator", 
		"inOperator", "isOperator", "additiveOperator", "multiplicativeOperator", 
		"asOperator", "prefixUnaryOperator", "postfixUnaryOperator", "excl", "memberAccessOperator", 
		"safeNav", "modifiers", "parameterModifiers", "modifier", "typeModifiers", 
		"typeModifier", "classModifier", "memberModifier", "visibilityModifier", 
		"varianceModifier", "typeParameterModifiers", "typeParameterModifier", 
		"functionModifier", "propertyModifier", "inheritanceModifier", "parameterModifier", 
		"reificationModifier", "platformModifier", "annotation", "singleAnnotation", 
		"multiAnnotation", "annotationUseSiteTarget", "unescapedAnnotation", "simpleIdentifier", 
		"identifier"
	];


	pub const _LITERAL_NAMES: [Option<&'static str>;151] = [
		None, None, None, None, None, None, Some("'...'"), Some("'.'"), Some("','"), 
		Some("'('"), Some("')'"), Some("'['"), Some("']'"), Some("'{'"), Some("'}'"), 
		Some("'*'"), Some("'%'"), Some("'/'"), Some("'+'"), Some("'-'"), Some("'++'"), 
		Some("'--'"), Some("'&&'"), Some("'||'"), None, Some("'!'"), Some("':'"), 
		Some("';'"), Some("'='"), Some("'+='"), Some("'-='"), Some("'*='"), Some("'/='"), 
		Some("'%='"), Some("'->'"), Some("'=>'"), Some("'..'"), Some("'::'"), 
		Some("';;'"), Some("'#'"), Some("'@'"), None, None, None, None, Some("'?'"), 
		Some("'<'"), Some("'>'"), Some("'<='"), Some("'>='"), Some("'!='"), Some("'!=='"), 
		Some("'as?'"), Some("'=='"), Some("'==='"), Some("'''"), None, None, None, 
		None, None, Some("'file'"), Some("'field'"), Some("'property'"), Some("'get'"), 
		Some("'set'"), Some("'receiver'"), Some("'param'"), Some("'setparam'"), 
		Some("'delegate'"), Some("'package'"), Some("'import'"), Some("'class'"), 
		Some("'interface'"), Some("'fun'"), Some("'object'"), Some("'val'"), Some("'var'"), 
		Some("'typealias'"), Some("'constructor'"), Some("'by'"), Some("'companion'"), 
		Some("'init'"), Some("'this'"), Some("'super'"), Some("'typeof'"), Some("'where'"), 
		Some("'if'"), Some("'else'"), Some("'when'"), Some("'try'"), Some("'catch'"), 
		Some("'finally'"), Some("'for'"), Some("'do'"), Some("'while'"), Some("'throw'"), 
		Some("'return'"), Some("'continue'"), Some("'break'"), Some("'as'"), Some("'is'"), 
		Some("'in'"), None, None, Some("'out'"), Some("'dynamic'"), Some("'public'"), 
		Some("'private'"), Some("'protected'"), Some("'internal'"), Some("'enum'"), 
		Some("'sealed'"), Some("'annotation'"), Some("'data'"), Some("'inner'"), 
		Some("'value'"), Some("'tailrec'"), Some("'operator'"), Some("'inline'"), 
		Some("'infix'"), Some("'external'"), Some("'suspend'"), Some("'override'"), 
		Some("'abstract'"), Some("'final'"), Some("'open'"), Some("'const'"), 
		Some("'lateinit'"), Some("'vararg'"), Some("'noinline'"), Some("'crossinline'"), 
		Some("'reified'"), Some("'expect'"), Some("'actual'"), None, None, None, 
		None, None, None, None, None, None, Some("'null'"), None, None, None, 
		None, None, Some("'\"\"\"'")
	];
	pub const _SYMBOLIC_NAMES: [Option<&'static str>;172]  = [
		None, Some("ShebangLine"), Some("DelimitedComment"), Some("LineComment"), 
		Some("WS"), Some("NL"), Some("RESERVED"), Some("DOT"), Some("COMMA"), 
		Some("LPAREN"), Some("RPAREN"), Some("LSQUARE"), Some("RSQUARE"), Some("LCURL"), 
		Some("RCURL"), Some("MULT"), Some("MOD"), Some("DIV"), Some("ADD"), Some("SUB"), 
		Some("INCR"), Some("DECR"), Some("CONJ"), Some("DISJ"), Some("EXCL_WS"), 
		Some("EXCL_NO_WS"), Some("COLON"), Some("SEMICOLON"), Some("ASSIGNMENT"), 
		Some("ADD_ASSIGNMENT"), Some("SUB_ASSIGNMENT"), Some("MULT_ASSIGNMENT"), 
		Some("DIV_ASSIGNMENT"), Some("MOD_ASSIGNMENT"), Some("ARROW"), Some("DOUBLE_ARROW"), 
		Some("RANGE"), Some("COLONCOLON"), Some("DOUBLE_SEMICOLON"), Some("HASH"), 
		Some("AT_NO_WS"), Some("AT_POST_WS"), Some("AT_PRE_WS"), Some("AT_BOTH_WS"), 
		Some("QUEST_WS"), Some("QUEST_NO_WS"), Some("LANGLE"), Some("RANGLE"), 
		Some("LE"), Some("GE"), Some("EXCL_EQ"), Some("EXCL_EQEQ"), Some("AS_SAFE"), 
		Some("EQEQ"), Some("EQEQEQ"), Some("SINGLE_QUOTE"), Some("RETURN_AT"), 
		Some("CONTINUE_AT"), Some("BREAK_AT"), Some("THIS_AT"), Some("SUPER_AT"), 
		Some("FILE"), Some("FIELD"), Some("PROPERTY"), Some("GET"), Some("SET"), 
		Some("RECEIVER"), Some("PARAM"), Some("SETPARAM"), Some("DELEGATE"), Some("PACKAGE"), 
		Some("IMPORT"), Some("CLASS"), Some("INTERFACE"), Some("FUN"), Some("OBJECT"), 
		Some("VAL"), Some("VAR"), Some("TYPE_ALIAS"), Some("CONSTRUCTOR"), Some("BY"), 
		Some("COMPANION"), Some("INIT"), Some("THIS"), Some("SUPER"), Some("TYPEOF"), 
		Some("WHERE"), Some("IF"), Some("ELSE"), Some("WHEN"), Some("TRY"), Some("CATCH"), 
		Some("FINALLY"), Some("FOR"), Some("DO"), Some("WHILE"), Some("THROW"), 
		Some("RETURN"), Some("CONTINUE"), Some("BREAK"), Some("AS"), Some("IS"), 
		Some("IN"), Some("NOT_IS"), Some("NOT_IN"), Some("OUT"), Some("DYNAMIC"), 
		Some("PUBLIC"), Some("PRIVATE"), Some("PROTECTED"), Some("INTERNAL"), 
		Some("ENUM"), Some("SEALED"), Some("ANNOTATION"), Some("DATA"), Some("INNER"), 
		Some("VALUE"), Some("TAILREC"), Some("OPERATOR"), Some("INLINE"), Some("INFIX"), 
		Some("EXTERNAL"), Some("SUSPEND"), Some("OVERRIDE"), Some("ABSTRACT"), 
		Some("FINAL"), Some("OPEN"), Some("CONST"), Some("LATEINIT"), Some("VARARG"), 
		Some("NOINLINE"), Some("CROSSINLINE"), Some("REIFIED"), Some("EXPECT"), 
		Some("ACTUAL"), Some("RealLiteral"), Some("FloatLiteral"), Some("DoubleLiteral"), 
		Some("IntegerLiteral"), Some("HexLiteral"), Some("BinLiteral"), Some("UnsignedLiteral"), 
		Some("LongLiteral"), Some("BooleanLiteral"), Some("NullLiteral"), Some("CharacterLiteral"), 
		Some("Identifier"), Some("IdentifierOrSoftKey"), Some("FieldIdentifier"), 
		Some("QUOTE_OPEN"), Some("TRIPLE_QUOTE_OPEN"), Some("UNICODE_CLASS_LL"), 
		Some("UNICODE_CLASS_LM"), Some("UNICODE_CLASS_LO"), Some("UNICODE_CLASS_LT"), 
		Some("UNICODE_CLASS_LU"), Some("UNICODE_CLASS_ND"), Some("UNICODE_CLASS_NL"), 
		Some("QUOTE_CLOSE"), Some("LineStrRef"), Some("LineStrText"), Some("LineStrEscapedChar"), 
		Some("LineStrExprStart"), Some("TRIPLE_QUOTE_CLOSE"), Some("MultiLineStringQuote"), 
		Some("MultiLineStrRef"), Some("MultiLineStrText"), Some("MultiLineStrExprStart"), 
		Some("Inside_Comment"), Some("Inside_WS"), Some("Inside_NL"), Some("ErrorCharacter")
	];
	lazy_static!{
	    static ref _shared_context_cache: Arc<PredictionContextCache> = Arc::new(PredictionContextCache::new());
		static ref VOCABULARY: Box<dyn Vocabulary> = Box::new(VocabularyImpl::new(_LITERAL_NAMES.iter(), _SYMBOLIC_NAMES.iter(), None));
	}


type BaseParserType<'input, I> =
	BaseParser<'input,KotlinParserExt, I, KotlinParserContextType , dyn KotlinParserListener<'input> + 'input >;

type TokenType<'input> = <LocalTokenFactory<'input> as TokenFactory<'input>>::Tok;
pub type LocalTokenFactory<'input> = CommonTokenFactory;

pub type KotlinParserTreeWalker<'input,'a> =
	ParseTreeWalker<'input, 'a, KotlinParserContextType , dyn KotlinParserListener<'input> + 'a>;

/// Parser for KotlinParser grammar
pub struct KotlinParser<'input,I,H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	base:BaseParserType<'input,I>,
	interpreter:Arc<ParserATNSimulator>,
	_shared_context_cache: Box<PredictionContextCache>,
    pub err_handler: H,
}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn get_serialized_atn() -> &'static str { _serializedATN }

    pub fn set_error_strategy(&mut self, strategy: H) {
        self.err_handler = strategy
    }

    pub fn with_strategy(input: I, strategy: H) -> Self {
		antlr_rust::recognizer::check_version("0","3");
		let interpreter = Arc::new(ParserATNSimulator::new(
			_ATN.clone(),
			_decision_to_DFA.clone(),
			_shared_context_cache.clone(),
		));
		Self {
			base: BaseParser::new_base_parser(
				input,
				Arc::clone(&interpreter),
				KotlinParserExt{
				}
			),
			interpreter,
            _shared_context_cache: Box::new(PredictionContextCache::new()),
            err_handler: strategy,
        }
    }

}

type DynStrategy<'input,I> = Box<dyn ErrorStrategy<'input,BaseParserType<'input,I>> + 'input>;

impl<'input, I> KotlinParser<'input, I, DynStrategy<'input,I>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
    pub fn with_dyn_strategy(input: I) -> Self{
    	Self::with_strategy(input,Box::new(DefaultErrorStrategy::new()))
    }
}

impl<'input, I> KotlinParser<'input, I, DefaultErrorStrategy<'input,KotlinParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
    pub fn new(input: I) -> Self{
    	Self::with_strategy(input,DefaultErrorStrategy::new())
    }
}

/// Trait for monomorphized trait object that corresponds to the nodes of parse tree generated for KotlinParser
pub trait KotlinParserContext<'input>:
	for<'x> Listenable<dyn KotlinParserListener<'input> + 'x > + 
	for<'x> Visitable<dyn KotlinParserVisitor<'input> + 'x > + 
	ParserRuleContext<'input, TF=LocalTokenFactory<'input>, Ctx=KotlinParserContextType>
{}

antlr_rust::coerce_from!{ 'input : KotlinParserContext<'input> }

impl<'input, 'x, T> VisitableDyn<T> for dyn KotlinParserContext<'input> + 'input
where
    T: KotlinParserVisitor<'input> + 'x,
{
    fn accept_dyn(&self, visitor: &mut T) {
        self.accept(visitor as &mut (dyn KotlinParserVisitor<'input> + 'x))
    }
}

impl<'input> KotlinParserContext<'input> for TerminalNode<'input,KotlinParserContextType> {}
impl<'input> KotlinParserContext<'input> for ErrorNode<'input,KotlinParserContextType> {}

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn KotlinParserContext<'input> + 'input }

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn KotlinParserListener<'input> + 'input }

pub struct KotlinParserContextType;
antlr_rust::tid!{KotlinParserContextType}

impl<'input> ParserNodeType<'input> for KotlinParserContextType{
	type TF = LocalTokenFactory<'input>;
	type Type = dyn KotlinParserContext<'input> + 'input;
}

impl<'input, I, H> Deref for KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
    type Target = BaseParserType<'input,I>;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl<'input, I, H> DerefMut for KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.base
    }
}

pub struct KotlinParserExt{
}

impl KotlinParserExt{
}


impl<'input> TokenAware<'input> for KotlinParserExt{
	type TF = LocalTokenFactory<'input>;
}

impl<'input,I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>> ParserRecog<'input, BaseParserType<'input,I>> for KotlinParserExt{}

impl<'input,I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>> Actions<'input, BaseParserType<'input,I>> for KotlinParserExt{
	fn get_grammar_file_name(&self) -> & str{ "KotlinParser.g4"}

   	fn get_rule_names(&self) -> &[& str] {&ruleNames}

   	fn get_vocabulary(&self) -> &dyn Vocabulary { &**VOCABULARY }
}
//------------------- kotlinFile ----------------
pub type KotlinFileContextAll<'input> = KotlinFileContext<'input>;


pub type KotlinFileContext<'input> = BaseParserRuleContext<'input,KotlinFileContextExt<'input>>;

#[derive(Clone)]
pub struct KotlinFileContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for KotlinFileContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for KotlinFileContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_kotlinFile(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_kotlinFile(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for KotlinFileContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_kotlinFile(self);
	}
}

impl<'input> CustomRuleContext<'input> for KotlinFileContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_kotlinFile }
	//fn type_rule_index() -> usize where Self: Sized { RULE_kotlinFile }
}
antlr_rust::tid!{KotlinFileContextExt<'a>}

impl<'input> KotlinFileContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<KotlinFileContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,KotlinFileContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait KotlinFileContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<KotlinFileContextExt<'input>>{

fn packageHeader(&self) -> Option<Rc<PackageHeaderContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn importList(&self) -> Option<Rc<ImportListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token EOF
/// Returns `None` if there is no child corresponding to token EOF
fn EOF(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EOF, 0)
}
fn shebangLine(&self) -> Option<Rc<ShebangLineContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn fileAnnotation_all(&self) ->  Vec<Rc<FileAnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn fileAnnotation(&self, i: usize) -> Option<Rc<FileAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn topLevelObject_all(&self) ->  Vec<Rc<TopLevelObjectContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn topLevelObject(&self, i: usize) -> Option<Rc<TopLevelObjectContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> KotlinFileContextAttrs<'input> for KotlinFileContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn kotlinFile(&mut self,)
	-> Result<Rc<KotlinFileContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = KotlinFileContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 0, RULE_kotlinFile);
        let mut _localctx: Rc<KotlinFileContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(347);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==ShebangLine {
				{
				/*InvokeRule shebangLine*/
				recog.base.set_state(346);
				recog.shebangLine()?;

				}
			}

			recog.base.set_state(352);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(349);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(354);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(358);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(2,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule fileAnnotation*/
					recog.base.set_state(355);
					recog.fileAnnotation()?;

					}
					} 
				}
				recog.base.set_state(360);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(2,&mut recog.base)?;
			}
			/*InvokeRule packageHeader*/
			recog.base.set_state(361);
			recog.packageHeader()?;

			/*InvokeRule importList*/
			recog.base.set_state(362);
			recog.importList()?;

			recog.base.set_state(366);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 72)) & !0x3f) == 0 && ((1usize << (_la - 72)) & ((1usize << (CLASS - 72)) | (1usize << (INTERFACE - 72)) | (1usize << (FUN - 72)) | (1usize << (OBJECT - 72)) | (1usize << (VAL - 72)) | (1usize << (VAR - 72)) | (1usize << (TYPE_ALIAS - 72)) | (1usize << (PUBLIC - 72)) | (1usize << (PRIVATE - 72)) | (1usize << (PROTECTED - 72)) | (1usize << (INTERNAL - 72)) | (1usize << (ENUM - 72)) | (1usize << (SEALED - 72)) | (1usize << (ANNOTATION - 72)) | (1usize << (DATA - 72)) | (1usize << (INNER - 72)) | (1usize << (VALUE - 72)) | (1usize << (TAILREC - 72)) | (1usize << (OPERATOR - 72)) | (1usize << (INLINE - 72)) | (1usize << (INFIX - 72)) | (1usize << (EXTERNAL - 72)) | (1usize << (SUSPEND - 72)) | (1usize << (OVERRIDE - 72)) | (1usize << (ABSTRACT - 72)) | (1usize << (FINAL - 72)) | (1usize << (OPEN - 72)) | (1usize << (CONST - 72)) | (1usize << (LATEINIT - 72)) | (1usize << (VARARG - 72)) | (1usize << (NOINLINE - 72)) | (1usize << (CROSSINLINE - 72)) | (1usize << (EXPECT - 72)) | (1usize << (ACTUAL - 72)))) != 0) {
				{
				{
				/*InvokeRule topLevelObject*/
				recog.base.set_state(363);
				recog.topLevelObject()?;

				}
				}
				recog.base.set_state(368);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(369);
			recog.base.match_token(EOF,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- script ----------------
pub type ScriptContextAll<'input> = ScriptContext<'input>;


pub type ScriptContext<'input> = BaseParserRuleContext<'input,ScriptContextExt<'input>>;

#[derive(Clone)]
pub struct ScriptContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ScriptContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ScriptContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_script(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_script(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ScriptContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_script(self);
	}
}

impl<'input> CustomRuleContext<'input> for ScriptContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_script }
	//fn type_rule_index() -> usize where Self: Sized { RULE_script }
}
antlr_rust::tid!{ScriptContextExt<'a>}

impl<'input> ScriptContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ScriptContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ScriptContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ScriptContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ScriptContextExt<'input>>{

fn packageHeader(&self) -> Option<Rc<PackageHeaderContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn importList(&self) -> Option<Rc<ImportListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token EOF
/// Returns `None` if there is no child corresponding to token EOF
fn EOF(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EOF, 0)
}
fn shebangLine(&self) -> Option<Rc<ShebangLineContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn fileAnnotation_all(&self) ->  Vec<Rc<FileAnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn fileAnnotation(&self, i: usize) -> Option<Rc<FileAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn statement_all(&self) ->  Vec<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn statement(&self, i: usize) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn semi_all(&self) ->  Vec<Rc<SemiContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn semi(&self, i: usize) -> Option<Rc<SemiContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ScriptContextAttrs<'input> for ScriptContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn script(&mut self,)
	-> Result<Rc<ScriptContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ScriptContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 2, RULE_script);
        let mut _localctx: Rc<ScriptContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(372);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==ShebangLine {
				{
				/*InvokeRule shebangLine*/
				recog.base.set_state(371);
				recog.shebangLine()?;

				}
			}

			recog.base.set_state(377);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(374);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(379);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(383);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(6,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule fileAnnotation*/
					recog.base.set_state(380);
					recog.fileAnnotation()?;

					}
					} 
				}
				recog.base.set_state(385);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(6,&mut recog.base)?;
			}
			/*InvokeRule packageHeader*/
			recog.base.set_state(386);
			recog.packageHeader()?;

			/*InvokeRule importList*/
			recog.base.set_state(387);
			recog.importList()?;

			recog.base.set_state(393);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << LPAREN) | (1usize << LSQUARE) | (1usize << LCURL) | (1usize << ADD) | (1usize << SUB) | (1usize << INCR) | (1usize << DECR) | (1usize << EXCL_WS) | (1usize << EXCL_NO_WS) | (1usize << COLONCOLON) | (1usize << AT_NO_WS) | (1usize << AT_PRE_WS) | (1usize << RETURN_AT) | (1usize << CONTINUE_AT) | (1usize << BREAK_AT) | (1usize << THIS_AT) | (1usize << SUPER_AT) | (1usize << FILE) | (1usize << FIELD) | (1usize << PROPERTY))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (GET - 64)) | (1usize << (SET - 64)) | (1usize << (RECEIVER - 64)) | (1usize << (PARAM - 64)) | (1usize << (SETPARAM - 64)) | (1usize << (DELEGATE - 64)) | (1usize << (IMPORT - 64)) | (1usize << (CLASS - 64)) | (1usize << (INTERFACE - 64)) | (1usize << (FUN - 64)) | (1usize << (OBJECT - 64)) | (1usize << (VAL - 64)) | (1usize << (VAR - 64)) | (1usize << (TYPE_ALIAS - 64)) | (1usize << (CONSTRUCTOR - 64)) | (1usize << (BY - 64)) | (1usize << (COMPANION - 64)) | (1usize << (INIT - 64)) | (1usize << (THIS - 64)) | (1usize << (SUPER - 64)) | (1usize << (WHERE - 64)) | (1usize << (IF - 64)) | (1usize << (WHEN - 64)) | (1usize << (TRY - 64)) | (1usize << (CATCH - 64)) | (1usize << (FINALLY - 64)) | (1usize << (FOR - 64)) | (1usize << (DO - 64)) | (1usize << (WHILE - 64)) | (1usize << (THROW - 64)) | (1usize << (RETURN - 64)) | (1usize << (CONTINUE - 64)) | (1usize << (BREAK - 64)) | (1usize << (OUT - 64)) | (1usize << (DYNAMIC - 64)) | (1usize << (PUBLIC - 64)) | (1usize << (PRIVATE - 64)) | (1usize << (PROTECTED - 64)) | (1usize << (INTERNAL - 64)) | (1usize << (ENUM - 64)) | (1usize << (SEALED - 64)) | (1usize << (ANNOTATION - 64)) | (1usize << (DATA - 64)) | (1usize << (INNER - 64)) | (1usize << (VALUE - 64)) | (1usize << (TAILREC - 64)) | (1usize << (OPERATOR - 64)) | (1usize << (INLINE - 64)) | (1usize << (INFIX - 64)) | (1usize << (EXTERNAL - 64)) | (1usize << (SUSPEND - 64)) | (1usize << (OVERRIDE - 64)) | (1usize << (ABSTRACT - 64)) | (1usize << (FINAL - 64)) | (1usize << (OPEN - 64)) | (1usize << (CONST - 64)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (LATEINIT - 128)) | (1usize << (VARARG - 128)) | (1usize << (NOINLINE - 128)) | (1usize << (CROSSINLINE - 128)) | (1usize << (REIFIED - 128)) | (1usize << (EXPECT - 128)) | (1usize << (ACTUAL - 128)) | (1usize << (RealLiteral - 128)) | (1usize << (IntegerLiteral - 128)) | (1usize << (HexLiteral - 128)) | (1usize << (BinLiteral - 128)) | (1usize << (UnsignedLiteral - 128)) | (1usize << (LongLiteral - 128)) | (1usize << (BooleanLiteral - 128)) | (1usize << (NullLiteral - 128)) | (1usize << (CharacterLiteral - 128)) | (1usize << (Identifier - 128)) | (1usize << (QUOTE_OPEN - 128)) | (1usize << (TRIPLE_QUOTE_OPEN - 128)))) != 0) {
				{
				{
				/*InvokeRule statement*/
				recog.base.set_state(388);
				recog.statement()?;

				/*InvokeRule semi*/
				recog.base.set_state(389);
				recog.semi()?;

				}
				}
				recog.base.set_state(395);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(396);
			recog.base.match_token(EOF,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- shebangLine ----------------
pub type ShebangLineContextAll<'input> = ShebangLineContext<'input>;


pub type ShebangLineContext<'input> = BaseParserRuleContext<'input,ShebangLineContextExt<'input>>;

#[derive(Clone)]
pub struct ShebangLineContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ShebangLineContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ShebangLineContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_shebangLine(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_shebangLine(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ShebangLineContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_shebangLine(self);
	}
}

impl<'input> CustomRuleContext<'input> for ShebangLineContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_shebangLine }
	//fn type_rule_index() -> usize where Self: Sized { RULE_shebangLine }
}
antlr_rust::tid!{ShebangLineContextExt<'a>}

impl<'input> ShebangLineContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ShebangLineContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ShebangLineContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ShebangLineContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ShebangLineContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ShebangLine
/// Returns `None` if there is no child corresponding to token ShebangLine
fn ShebangLine(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ShebangLine, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ShebangLineContextAttrs<'input> for ShebangLineContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn shebangLine(&mut self,)
	-> Result<Rc<ShebangLineContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ShebangLineContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 4, RULE_shebangLine);
        let mut _localctx: Rc<ShebangLineContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(398);
			recog.base.match_token(ShebangLine,&mut recog.err_handler)?;

			recog.base.set_state(400); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					{
					recog.base.set_state(399);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(402); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(8,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fileAnnotation ----------------
pub type FileAnnotationContextAll<'input> = FileAnnotationContext<'input>;


pub type FileAnnotationContext<'input> = BaseParserRuleContext<'input,FileAnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct FileAnnotationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FileAnnotationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FileAnnotationContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_fileAnnotation(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_fileAnnotation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FileAnnotationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_fileAnnotation(self);
	}
}

impl<'input> CustomRuleContext<'input> for FileAnnotationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fileAnnotation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fileAnnotation }
}
antlr_rust::tid!{FileAnnotationContextExt<'a>}

impl<'input> FileAnnotationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FileAnnotationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FileAnnotationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FileAnnotationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FileAnnotationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FILE
/// Returns `None` if there is no child corresponding to token FILE
fn FILE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FILE, 0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
/// Retrieves first TerminalNode corresponding to token AT_NO_WS
/// Returns `None` if there is no child corresponding to token AT_NO_WS
fn AT_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_NO_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token AT_PRE_WS
/// Returns `None` if there is no child corresponding to token AT_PRE_WS
fn AT_PRE_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_PRE_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token LSQUARE
/// Returns `None` if there is no child corresponding to token LSQUARE
fn LSQUARE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LSQUARE, 0)
}
/// Retrieves first TerminalNode corresponding to token RSQUARE
/// Returns `None` if there is no child corresponding to token RSQUARE
fn RSQUARE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RSQUARE, 0)
}
fn unescapedAnnotation_all(&self) ->  Vec<Rc<UnescapedAnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn unescapedAnnotation(&self, i: usize) -> Option<Rc<UnescapedAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> FileAnnotationContextAttrs<'input> for FileAnnotationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fileAnnotation(&mut self,)
	-> Result<Rc<FileAnnotationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FileAnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 6, RULE_fileAnnotation);
        let mut _localctx: Rc<FileAnnotationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(404);
			_la = recog.base.input.la(1);
			if { !(_la==AT_NO_WS || _la==AT_PRE_WS) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			recog.base.set_state(405);
			recog.base.match_token(FILE,&mut recog.err_handler)?;

			recog.base.set_state(409);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(406);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(411);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(412);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			recog.base.set_state(416);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(413);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(418);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(428);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LSQUARE 
				=> {
					{
					recog.base.set_state(419);
					recog.base.match_token(LSQUARE,&mut recog.err_handler)?;

					recog.base.set_state(421); 
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					loop {
						{
						{
						/*InvokeRule unescapedAnnotation*/
						recog.base.set_state(420);
						recog.unescapedAnnotation()?;

						}
						}
						recog.base.set_state(423); 
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if !(((((_la - 61)) & !0x3f) == 0 && ((1usize << (_la - 61)) & ((1usize << (FILE - 61)) | (1usize << (FIELD - 61)) | (1usize << (PROPERTY - 61)) | (1usize << (GET - 61)) | (1usize << (SET - 61)) | (1usize << (RECEIVER - 61)) | (1usize << (PARAM - 61)) | (1usize << (SETPARAM - 61)) | (1usize << (DELEGATE - 61)) | (1usize << (IMPORT - 61)) | (1usize << (CONSTRUCTOR - 61)) | (1usize << (BY - 61)) | (1usize << (COMPANION - 61)) | (1usize << (INIT - 61)) | (1usize << (WHERE - 61)) | (1usize << (CATCH - 61)) | (1usize << (FINALLY - 61)) | (1usize << (OUT - 61)) | (1usize << (DYNAMIC - 61)) | (1usize << (PUBLIC - 61)) | (1usize << (PRIVATE - 61)) | (1usize << (PROTECTED - 61)) | (1usize << (INTERNAL - 61)) | (1usize << (ENUM - 61)) | (1usize << (SEALED - 61)) | (1usize << (ANNOTATION - 61)) | (1usize << (DATA - 61)) | (1usize << (INNER - 61)) | (1usize << (VALUE - 61)) | (1usize << (TAILREC - 61)) | (1usize << (OPERATOR - 61)) | (1usize << (INLINE - 61)) | (1usize << (INFIX - 61)) | (1usize << (EXTERNAL - 61)) | (1usize << (SUSPEND - 61)) | (1usize << (OVERRIDE - 61)) | (1usize << (ABSTRACT - 61)))) != 0) || ((((_la - 125)) & !0x3f) == 0 && ((1usize << (_la - 125)) & ((1usize << (FINAL - 125)) | (1usize << (OPEN - 125)) | (1usize << (CONST - 125)) | (1usize << (LATEINIT - 125)) | (1usize << (VARARG - 125)) | (1usize << (NOINLINE - 125)) | (1usize << (CROSSINLINE - 125)) | (1usize << (REIFIED - 125)) | (1usize << (EXPECT - 125)) | (1usize << (ACTUAL - 125)) | (1usize << (Identifier - 125)))) != 0)) {break}
					}
					recog.base.set_state(425);
					recog.base.match_token(RSQUARE,&mut recog.err_handler)?;

					}
				}

			 FILE | FIELD | PROPERTY | GET | SET | RECEIVER | PARAM | SETPARAM | DELEGATE |
			 IMPORT | CONSTRUCTOR | BY | COMPANION | INIT | WHERE | CATCH | FINALLY |
			 OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED |
			 ANNOTATION | DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX |
			 EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT |
			 VARARG | NOINLINE | CROSSINLINE | REIFIED | EXPECT | ACTUAL | Identifier 
				=> {
					{
					/*InvokeRule unescapedAnnotation*/
					recog.base.set_state(427);
					recog.unescapedAnnotation()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(433);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(430);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(435);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- packageHeader ----------------
pub type PackageHeaderContextAll<'input> = PackageHeaderContext<'input>;


pub type PackageHeaderContext<'input> = BaseParserRuleContext<'input,PackageHeaderContextExt<'input>>;

#[derive(Clone)]
pub struct PackageHeaderContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PackageHeaderContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PackageHeaderContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_packageHeader(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_packageHeader(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PackageHeaderContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_packageHeader(self);
	}
}

impl<'input> CustomRuleContext<'input> for PackageHeaderContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_packageHeader }
	//fn type_rule_index() -> usize where Self: Sized { RULE_packageHeader }
}
antlr_rust::tid!{PackageHeaderContextExt<'a>}

impl<'input> PackageHeaderContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PackageHeaderContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PackageHeaderContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PackageHeaderContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PackageHeaderContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token PACKAGE
/// Returns `None` if there is no child corresponding to token PACKAGE
fn PACKAGE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PACKAGE, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn semi(&self) -> Option<Rc<SemiContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PackageHeaderContextAttrs<'input> for PackageHeaderContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn packageHeader(&mut self,)
	-> Result<Rc<PackageHeaderContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PackageHeaderContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 8, RULE_packageHeader);
        let mut _localctx: Rc<PackageHeaderContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(441);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==PACKAGE {
				{
				recog.base.set_state(436);
				recog.base.match_token(PACKAGE,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(437);
				recog.identifier()?;

				recog.base.set_state(439);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(14,&mut recog.base)? {
					x if x == 1=>{
						{
						/*InvokeRule semi*/
						recog.base.set_state(438);
						recog.semi()?;

						}
					}

					_ => {}
				}
				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- importList ----------------
pub type ImportListContextAll<'input> = ImportListContext<'input>;


pub type ImportListContext<'input> = BaseParserRuleContext<'input,ImportListContextExt<'input>>;

#[derive(Clone)]
pub struct ImportListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ImportListContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ImportListContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_importList(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_importList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ImportListContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_importList(self);
	}
}

impl<'input> CustomRuleContext<'input> for ImportListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_importList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_importList }
}
antlr_rust::tid!{ImportListContextExt<'a>}

impl<'input> ImportListContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ImportListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ImportListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ImportListContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ImportListContextExt<'input>>{

fn importHeader_all(&self) ->  Vec<Rc<ImportHeaderContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn importHeader(&self, i: usize) -> Option<Rc<ImportHeaderContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ImportListContextAttrs<'input> for ImportListContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn importList(&mut self,)
	-> Result<Rc<ImportListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ImportListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 10, RULE_importList);
        let mut _localctx: Rc<ImportListContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(446);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(16,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule importHeader*/
					recog.base.set_state(443);
					recog.importHeader()?;

					}
					} 
				}
				recog.base.set_state(448);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(16,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- importHeader ----------------
pub type ImportHeaderContextAll<'input> = ImportHeaderContext<'input>;


pub type ImportHeaderContext<'input> = BaseParserRuleContext<'input,ImportHeaderContextExt<'input>>;

#[derive(Clone)]
pub struct ImportHeaderContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ImportHeaderContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ImportHeaderContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_importHeader(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_importHeader(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ImportHeaderContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_importHeader(self);
	}
}

impl<'input> CustomRuleContext<'input> for ImportHeaderContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_importHeader }
	//fn type_rule_index() -> usize where Self: Sized { RULE_importHeader }
}
antlr_rust::tid!{ImportHeaderContextExt<'a>}

impl<'input> ImportHeaderContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ImportHeaderContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ImportHeaderContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ImportHeaderContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ImportHeaderContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IMPORT
/// Returns `None` if there is no child corresponding to token IMPORT
fn IMPORT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(IMPORT, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves first TerminalNode corresponding to token MULT
/// Returns `None` if there is no child corresponding to token MULT
fn MULT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MULT, 0)
}
fn importAlias(&self) -> Option<Rc<ImportAliasContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn semi(&self) -> Option<Rc<SemiContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ImportHeaderContextAttrs<'input> for ImportHeaderContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn importHeader(&mut self,)
	-> Result<Rc<ImportHeaderContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ImportHeaderContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 12, RULE_importHeader);
        let mut _localctx: Rc<ImportHeaderContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(449);
			recog.base.match_token(IMPORT,&mut recog.err_handler)?;

			/*InvokeRule identifier*/
			recog.base.set_state(450);
			recog.identifier()?;

			recog.base.set_state(454);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 DOT 
				=> {
			    	{
			    	recog.base.set_state(451);
			    	recog.base.match_token(DOT,&mut recog.err_handler)?;

			    	recog.base.set_state(452);
			    	recog.base.match_token(MULT,&mut recog.err_handler)?;

			    	}
			    }

			 AS 
				=> {
			    	{
			    	/*InvokeRule importAlias*/
			    	recog.base.set_state(453);
			    	recog.importAlias()?;

			    	}
			    }

			 EOF | NL | LPAREN | LSQUARE | LCURL | ADD | SUB | INCR | DECR | EXCL_WS |
			 EXCL_NO_WS | SEMICOLON | COLONCOLON | AT_NO_WS | AT_PRE_WS | RETURN_AT |
			 CONTINUE_AT | BREAK_AT | THIS_AT | SUPER_AT | FILE | FIELD | PROPERTY |
			 GET | SET | RECEIVER | PARAM | SETPARAM | DELEGATE | IMPORT | CLASS |
			 INTERFACE | FUN | OBJECT | VAL | VAR | TYPE_ALIAS | CONSTRUCTOR | BY |
			 COMPANION | INIT | THIS | SUPER | WHERE | IF | WHEN | TRY | CATCH | FINALLY |
			 FOR | DO | WHILE | THROW | RETURN | CONTINUE | BREAK | OUT | DYNAMIC |
			 PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED | ANNOTATION |
			 DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX | EXTERNAL |
			 SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT | VARARG |
			 NOINLINE | CROSSINLINE | REIFIED | EXPECT | ACTUAL | RealLiteral | IntegerLiteral |
			 HexLiteral | BinLiteral | UnsignedLiteral | LongLiteral | BooleanLiteral |
			 NullLiteral | CharacterLiteral | Identifier | QUOTE_OPEN | TRIPLE_QUOTE_OPEN 
				=> {
			    }

				_ => {}
			}
			recog.base.set_state(457);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(18,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule semi*/
					recog.base.set_state(456);
					recog.semi()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- importAlias ----------------
pub type ImportAliasContextAll<'input> = ImportAliasContext<'input>;


pub type ImportAliasContext<'input> = BaseParserRuleContext<'input,ImportAliasContextExt<'input>>;

#[derive(Clone)]
pub struct ImportAliasContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ImportAliasContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ImportAliasContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_importAlias(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_importAlias(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ImportAliasContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_importAlias(self);
	}
}

impl<'input> CustomRuleContext<'input> for ImportAliasContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_importAlias }
	//fn type_rule_index() -> usize where Self: Sized { RULE_importAlias }
}
antlr_rust::tid!{ImportAliasContextExt<'a>}

impl<'input> ImportAliasContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ImportAliasContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ImportAliasContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ImportAliasContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ImportAliasContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token AS
/// Returns `None` if there is no child corresponding to token AS
fn AS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AS, 0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ImportAliasContextAttrs<'input> for ImportAliasContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn importAlias(&mut self,)
	-> Result<Rc<ImportAliasContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ImportAliasContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 14, RULE_importAlias);
        let mut _localctx: Rc<ImportAliasContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(459);
			recog.base.match_token(AS,&mut recog.err_handler)?;

			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(460);
			recog.simpleIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- topLevelObject ----------------
pub type TopLevelObjectContextAll<'input> = TopLevelObjectContext<'input>;


pub type TopLevelObjectContext<'input> = BaseParserRuleContext<'input,TopLevelObjectContextExt<'input>>;

#[derive(Clone)]
pub struct TopLevelObjectContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TopLevelObjectContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TopLevelObjectContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_topLevelObject(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_topLevelObject(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TopLevelObjectContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_topLevelObject(self);
	}
}

impl<'input> CustomRuleContext<'input> for TopLevelObjectContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_topLevelObject }
	//fn type_rule_index() -> usize where Self: Sized { RULE_topLevelObject }
}
antlr_rust::tid!{TopLevelObjectContextExt<'a>}

impl<'input> TopLevelObjectContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TopLevelObjectContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TopLevelObjectContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TopLevelObjectContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TopLevelObjectContextExt<'input>>{

fn declaration(&self) -> Option<Rc<DeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn semis(&self) -> Option<Rc<SemisContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TopLevelObjectContextAttrs<'input> for TopLevelObjectContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn topLevelObject(&mut self,)
	-> Result<Rc<TopLevelObjectContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TopLevelObjectContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 16, RULE_topLevelObject);
        let mut _localctx: Rc<TopLevelObjectContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule declaration*/
			recog.base.set_state(462);
			recog.declaration()?;

			recog.base.set_state(464);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(19,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule semis*/
					recog.base.set_state(463);
					recog.semis()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeAlias ----------------
pub type TypeAliasContextAll<'input> = TypeAliasContext<'input>;


pub type TypeAliasContext<'input> = BaseParserRuleContext<'input,TypeAliasContextExt<'input>>;

#[derive(Clone)]
pub struct TypeAliasContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeAliasContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeAliasContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeAlias(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_typeAlias(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeAliasContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeAlias(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeAliasContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeAlias }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeAlias }
}
antlr_rust::tid!{TypeAliasContextExt<'a>}

impl<'input> TypeAliasContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeAliasContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeAliasContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeAliasContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeAliasContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token TYPE_ALIAS
/// Returns `None` if there is no child corresponding to token TYPE_ALIAS
fn TYPE_ALIAS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(TYPE_ALIAS, 0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ASSIGNMENT
fn ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ASSIGNMENT, 0)
}
fn rustType(&self) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn typeParameters(&self) -> Option<Rc<TypeParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeAliasContextAttrs<'input> for TypeAliasContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeAlias(&mut self,)
	-> Result<Rc<TypeAliasContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeAliasContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 18, RULE_typeAlias);
        let mut _localctx: Rc<TypeAliasContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(467);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 107)) & !0x3f) == 0 && ((1usize << (_la - 107)) & ((1usize << (PUBLIC - 107)) | (1usize << (PRIVATE - 107)) | (1usize << (PROTECTED - 107)) | (1usize << (INTERNAL - 107)) | (1usize << (ENUM - 107)) | (1usize << (SEALED - 107)) | (1usize << (ANNOTATION - 107)) | (1usize << (DATA - 107)) | (1usize << (INNER - 107)) | (1usize << (VALUE - 107)) | (1usize << (TAILREC - 107)) | (1usize << (OPERATOR - 107)) | (1usize << (INLINE - 107)) | (1usize << (INFIX - 107)) | (1usize << (EXTERNAL - 107)) | (1usize << (SUSPEND - 107)) | (1usize << (OVERRIDE - 107)) | (1usize << (ABSTRACT - 107)) | (1usize << (FINAL - 107)) | (1usize << (OPEN - 107)) | (1usize << (CONST - 107)) | (1usize << (LATEINIT - 107)) | (1usize << (VARARG - 107)) | (1usize << (NOINLINE - 107)) | (1usize << (CROSSINLINE - 107)) | (1usize << (EXPECT - 107)) | (1usize << (ACTUAL - 107)))) != 0) {
				{
				/*InvokeRule modifiers*/
				recog.base.set_state(466);
				recog.modifiers()?;

				}
			}

			recog.base.set_state(469);
			recog.base.match_token(TYPE_ALIAS,&mut recog.err_handler)?;

			recog.base.set_state(473);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(470);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(475);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(476);
			recog.simpleIdentifier()?;

			recog.base.set_state(484);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(23,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(480);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(477);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(482);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeParameters*/
					recog.base.set_state(483);
					recog.typeParameters()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(489);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(486);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(491);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(492);
			recog.base.match_token(ASSIGNMENT,&mut recog.err_handler)?;

			recog.base.set_state(496);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(493);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(498);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule rustType*/
			recog.base.set_state(499);
			recog.rustType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- declaration ----------------
pub type DeclarationContextAll<'input> = DeclarationContext<'input>;


pub type DeclarationContext<'input> = BaseParserRuleContext<'input,DeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct DeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for DeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for DeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_declaration(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_declaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for DeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_declaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for DeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_declaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_declaration }
}
antlr_rust::tid!{DeclarationContextExt<'a>}

impl<'input> DeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DeclarationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<DeclarationContextExt<'input>>{

fn classDeclaration(&self) -> Option<Rc<ClassDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn objectDeclaration(&self) -> Option<Rc<ObjectDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionDeclaration(&self) -> Option<Rc<FunctionDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn propertyDeclaration(&self) -> Option<Rc<PropertyDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeAlias(&self) -> Option<Rc<TypeAliasContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DeclarationContextAttrs<'input> for DeclarationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn declaration(&mut self,)
	-> Result<Rc<DeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 20, RULE_declaration);
        let mut _localctx: Rc<DeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(506);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(26,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule classDeclaration*/
					recog.base.set_state(501);
					recog.classDeclaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule objectDeclaration*/
					recog.base.set_state(502);
					recog.objectDeclaration()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule functionDeclaration*/
					recog.base.set_state(503);
					recog.functionDeclaration()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule propertyDeclaration*/
					recog.base.set_state(504);
					recog.propertyDeclaration()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule typeAlias*/
					recog.base.set_state(505);
					recog.typeAlias()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classDeclaration ----------------
pub type ClassDeclarationContextAll<'input> = ClassDeclarationContext<'input>;


pub type ClassDeclarationContext<'input> = BaseParserRuleContext<'input,ClassDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ClassDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ClassDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ClassDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_classDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ClassDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_classDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classDeclaration }
}
antlr_rust::tid!{ClassDeclarationContextExt<'a>}

impl<'input> ClassDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassDeclarationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ClassDeclarationContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token CLASS
/// Returns `None` if there is no child corresponding to token CLASS
fn CLASS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CLASS, 0)
}
/// Retrieves first TerminalNode corresponding to token INTERFACE
/// Returns `None` if there is no child corresponding to token INTERFACE
fn INTERFACE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INTERFACE, 0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn typeParameters(&self) -> Option<Rc<TypeParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn primaryConstructor(&self) -> Option<Rc<PrimaryConstructorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn delegationSpecifiers(&self) -> Option<Rc<DelegationSpecifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeConstraints(&self) -> Option<Rc<TypeConstraintsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classBody(&self) -> Option<Rc<ClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn enumClassBody(&self) -> Option<Rc<EnumClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token FUN
/// Returns `None` if there is no child corresponding to token FUN
fn FUN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FUN, 0)
}

}

impl<'input> ClassDeclarationContextAttrs<'input> for ClassDeclarationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classDeclaration(&mut self,)
	-> Result<Rc<ClassDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 22, RULE_classDeclaration);
        let mut _localctx: Rc<ClassDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(509);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 107)) & !0x3f) == 0 && ((1usize << (_la - 107)) & ((1usize << (PUBLIC - 107)) | (1usize << (PRIVATE - 107)) | (1usize << (PROTECTED - 107)) | (1usize << (INTERNAL - 107)) | (1usize << (ENUM - 107)) | (1usize << (SEALED - 107)) | (1usize << (ANNOTATION - 107)) | (1usize << (DATA - 107)) | (1usize << (INNER - 107)) | (1usize << (VALUE - 107)) | (1usize << (TAILREC - 107)) | (1usize << (OPERATOR - 107)) | (1usize << (INLINE - 107)) | (1usize << (INFIX - 107)) | (1usize << (EXTERNAL - 107)) | (1usize << (SUSPEND - 107)) | (1usize << (OVERRIDE - 107)) | (1usize << (ABSTRACT - 107)) | (1usize << (FINAL - 107)) | (1usize << (OPEN - 107)) | (1usize << (CONST - 107)) | (1usize << (LATEINIT - 107)) | (1usize << (VARARG - 107)) | (1usize << (NOINLINE - 107)) | (1usize << (CROSSINLINE - 107)) | (1usize << (EXPECT - 107)) | (1usize << (ACTUAL - 107)))) != 0) {
				{
				/*InvokeRule modifiers*/
				recog.base.set_state(508);
				recog.modifiers()?;

				}
			}

			recog.base.set_state(522);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 CLASS 
				=> {
					{
					recog.base.set_state(511);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}

			 INTERFACE | FUN 
				=> {
					{
					recog.base.set_state(519);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==FUN {
						{
						recog.base.set_state(512);
						recog.base.match_token(FUN,&mut recog.err_handler)?;

						recog.base.set_state(516);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(513);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(518);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						}
					}

					recog.base.set_state(521);
					recog.base.match_token(INTERFACE,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(527);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(524);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(529);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(530);
			recog.simpleIdentifier()?;

			recog.base.set_state(538);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(33,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(534);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(531);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(536);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeParameters*/
					recog.base.set_state(537);
					recog.typeParameters()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(547);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(35,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(543);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(540);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(545);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule primaryConstructor*/
					recog.base.set_state(546);
					recog.primaryConstructor()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(563);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(38,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(552);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(549);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(554);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(555);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(559);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(37,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(556);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(561);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(37,&mut recog.base)?;
					}
					/*InvokeRule delegationSpecifiers*/
					recog.base.set_state(562);
					recog.delegationSpecifiers()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(572);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(40,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(568);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(565);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(570);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeConstraints*/
					recog.base.set_state(571);
					recog.typeConstraints()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(588);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(43,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(577);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(574);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(579);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule classBody*/
					recog.base.set_state(580);
					recog.classBody()?;

					}
				}

				x if x == 2=>{
					{
					recog.base.set_state(584);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(581);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(586);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule enumClassBody*/
					recog.base.set_state(587);
					recog.enumClassBody()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primaryConstructor ----------------
pub type PrimaryConstructorContextAll<'input> = PrimaryConstructorContext<'input>;


pub type PrimaryConstructorContext<'input> = BaseParserRuleContext<'input,PrimaryConstructorContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryConstructorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PrimaryConstructorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PrimaryConstructorContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_primaryConstructor(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_primaryConstructor(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PrimaryConstructorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_primaryConstructor(self);
	}
}

impl<'input> CustomRuleContext<'input> for PrimaryConstructorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryConstructor }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryConstructor }
}
antlr_rust::tid!{PrimaryConstructorContextExt<'a>}

impl<'input> PrimaryConstructorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryConstructorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryConstructorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryConstructorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PrimaryConstructorContextExt<'input>>{

fn classParameters(&self) -> Option<Rc<ClassParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token CONSTRUCTOR
/// Returns `None` if there is no child corresponding to token CONSTRUCTOR
fn CONSTRUCTOR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CONSTRUCTOR, 0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> PrimaryConstructorContextAttrs<'input> for PrimaryConstructorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primaryConstructor(&mut self,)
	-> Result<Rc<PrimaryConstructorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryConstructorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 24, RULE_primaryConstructor);
        let mut _localctx: Rc<PrimaryConstructorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(600);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 79)) & !0x3f) == 0 && ((1usize << (_la - 79)) & ((1usize << (CONSTRUCTOR - 79)) | (1usize << (PUBLIC - 79)) | (1usize << (PRIVATE - 79)) | (1usize << (PROTECTED - 79)) | (1usize << (INTERNAL - 79)) | (1usize << (ENUM - 79)) | (1usize << (SEALED - 79)) | (1usize << (ANNOTATION - 79)) | (1usize << (DATA - 79)) | (1usize << (INNER - 79)) | (1usize << (VALUE - 79)) | (1usize << (TAILREC - 79)) | (1usize << (OPERATOR - 79)) | (1usize << (INLINE - 79)) | (1usize << (INFIX - 79)) | (1usize << (EXTERNAL - 79)) | (1usize << (SUSPEND - 79)) | (1usize << (OVERRIDE - 79)) | (1usize << (ABSTRACT - 79)) | (1usize << (FINAL - 79)) | (1usize << (OPEN - 79)) | (1usize << (CONST - 79)) | (1usize << (LATEINIT - 79)) | (1usize << (VARARG - 79)) | (1usize << (NOINLINE - 79)) | (1usize << (CROSSINLINE - 79)) | (1usize << (EXPECT - 79)) | (1usize << (ACTUAL - 79)))) != 0) {
				{
				recog.base.set_state(591);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 107)) & !0x3f) == 0 && ((1usize << (_la - 107)) & ((1usize << (PUBLIC - 107)) | (1usize << (PRIVATE - 107)) | (1usize << (PROTECTED - 107)) | (1usize << (INTERNAL - 107)) | (1usize << (ENUM - 107)) | (1usize << (SEALED - 107)) | (1usize << (ANNOTATION - 107)) | (1usize << (DATA - 107)) | (1usize << (INNER - 107)) | (1usize << (VALUE - 107)) | (1usize << (TAILREC - 107)) | (1usize << (OPERATOR - 107)) | (1usize << (INLINE - 107)) | (1usize << (INFIX - 107)) | (1usize << (EXTERNAL - 107)) | (1usize << (SUSPEND - 107)) | (1usize << (OVERRIDE - 107)) | (1usize << (ABSTRACT - 107)) | (1usize << (FINAL - 107)) | (1usize << (OPEN - 107)) | (1usize << (CONST - 107)) | (1usize << (LATEINIT - 107)) | (1usize << (VARARG - 107)) | (1usize << (NOINLINE - 107)) | (1usize << (CROSSINLINE - 107)) | (1usize << (EXPECT - 107)) | (1usize << (ACTUAL - 107)))) != 0) {
					{
					/*InvokeRule modifiers*/
					recog.base.set_state(590);
					recog.modifiers()?;

					}
				}

				recog.base.set_state(593);
				recog.base.match_token(CONSTRUCTOR,&mut recog.err_handler)?;

				recog.base.set_state(597);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				while _la==NL {
					{
					{
					recog.base.set_state(594);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					}
					recog.base.set_state(599);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
				}
				}
			}

			/*InvokeRule classParameters*/
			recog.base.set_state(602);
			recog.classParameters()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classBody ----------------
pub type ClassBodyContextAll<'input> = ClassBodyContext<'input>;


pub type ClassBodyContext<'input> = BaseParserRuleContext<'input,ClassBodyContextExt<'input>>;

#[derive(Clone)]
pub struct ClassBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ClassBodyContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ClassBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classBody(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_classBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ClassBodyContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_classBody(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classBody }
}
antlr_rust::tid!{ClassBodyContextExt<'a>}

impl<'input> ClassBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassBodyContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ClassBodyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LCURL
/// Returns `None` if there is no child corresponding to token LCURL
fn LCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LCURL, 0)
}
fn classMemberDeclarations(&self) -> Option<Rc<ClassMemberDeclarationsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RCURL
/// Returns `None` if there is no child corresponding to token RCURL
fn RCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RCURL, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ClassBodyContextAttrs<'input> for ClassBodyContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classBody(&mut self,)
	-> Result<Rc<ClassBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 26, RULE_classBody);
        let mut _localctx: Rc<ClassBodyContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(604);
			recog.base.match_token(LCURL,&mut recog.err_handler)?;

			recog.base.set_state(608);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(47,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(605);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(610);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(47,&mut recog.base)?;
			}
			/*InvokeRule classMemberDeclarations*/
			recog.base.set_state(611);
			recog.classMemberDeclarations()?;

			recog.base.set_state(615);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(612);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(617);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(618);
			recog.base.match_token(RCURL,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classParameters ----------------
pub type ClassParametersContextAll<'input> = ClassParametersContext<'input>;


pub type ClassParametersContext<'input> = BaseParserRuleContext<'input,ClassParametersContextExt<'input>>;

#[derive(Clone)]
pub struct ClassParametersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ClassParametersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ClassParametersContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classParameters(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_classParameters(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ClassParametersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_classParameters(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassParametersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classParameters }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classParameters }
}
antlr_rust::tid!{ClassParametersContextExt<'a>}

impl<'input> ClassParametersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassParametersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassParametersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassParametersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ClassParametersContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn classParameter_all(&self) ->  Vec<Rc<ClassParameterContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn classParameter(&self, i: usize) -> Option<Rc<ClassParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> ClassParametersContextAttrs<'input> for ClassParametersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classParameters(&mut self,)
	-> Result<Rc<ClassParametersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassParametersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 28, RULE_classParameters);
        let mut _localctx: Rc<ClassParametersContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(620);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(624);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(49,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(621);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(626);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(49,&mut recog.base)?;
			}
			recog.base.set_state(656);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(55,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule classParameter*/
					recog.base.set_state(627);
					recog.classParameter()?;

					recog.base.set_state(644);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(52,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(631);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(628);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(633);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(634);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							recog.base.set_state(638);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(51,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(635);
									recog.base.match_token(NL,&mut recog.err_handler)?;

									}
									} 
								}
								recog.base.set_state(640);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(51,&mut recog.base)?;
							}
							/*InvokeRule classParameter*/
							recog.base.set_state(641);
							recog.classParameter()?;

							}
							} 
						}
						recog.base.set_state(646);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(52,&mut recog.base)?;
					}
					recog.base.set_state(654);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(54,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(650);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(647);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(652);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(653);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					}
				}

				_ => {}
			}
			recog.base.set_state(661);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(658);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(663);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(664);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classParameter ----------------
pub type ClassParameterContextAll<'input> = ClassParameterContext<'input>;


pub type ClassParameterContext<'input> = BaseParserRuleContext<'input,ClassParameterContextExt<'input>>;

#[derive(Clone)]
pub struct ClassParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ClassParameterContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ClassParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classParameter(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_classParameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ClassParameterContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_classParameter(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classParameter }
}
antlr_rust::tid!{ClassParameterContextExt<'a>}

impl<'input> ClassParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassParameterContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ClassParameterContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn rustType(&self) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ASSIGNMENT
fn ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ASSIGNMENT, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token VAL
/// Returns `None` if there is no child corresponding to token VAL
fn VAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(VAL, 0)
}
/// Retrieves first TerminalNode corresponding to token VAR
/// Returns `None` if there is no child corresponding to token VAR
fn VAR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(VAR, 0)
}

}

impl<'input> ClassParameterContextAttrs<'input> for ClassParameterContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classParameter(&mut self,)
	-> Result<Rc<ClassParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 30, RULE_classParameter);
        let mut _localctx: Rc<ClassParameterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(667);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(57,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule modifiers*/
					recog.base.set_state(666);
					recog.modifiers()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(670);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==VAL || _la==VAR {
				{
				recog.base.set_state(669);
				_la = recog.base.input.la(1);
				if { !(_la==VAL || _la==VAR) } {
					recog.err_handler.recover_inline(&mut recog.base)?;

				}
				else {
					if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
					recog.err_handler.report_match(&mut recog.base);
					recog.base.consume(&mut recog.err_handler);
				}
				}
			}

			recog.base.set_state(675);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(672);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(677);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(678);
			recog.simpleIdentifier()?;

			recog.base.set_state(679);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			recog.base.set_state(683);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(680);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(685);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule rustType*/
			recog.base.set_state(686);
			recog.rustType()?;

			recog.base.set_state(701);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(63,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(690);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(687);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(692);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(693);
					recog.base.match_token(ASSIGNMENT,&mut recog.err_handler)?;

					recog.base.set_state(697);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(694);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(699);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule expression*/
					recog.base.set_state(700);
					recog.expression()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- delegationSpecifiers ----------------
pub type DelegationSpecifiersContextAll<'input> = DelegationSpecifiersContext<'input>;


pub type DelegationSpecifiersContext<'input> = BaseParserRuleContext<'input,DelegationSpecifiersContextExt<'input>>;

#[derive(Clone)]
pub struct DelegationSpecifiersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for DelegationSpecifiersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for DelegationSpecifiersContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_delegationSpecifiers(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_delegationSpecifiers(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for DelegationSpecifiersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_delegationSpecifiers(self);
	}
}

impl<'input> CustomRuleContext<'input> for DelegationSpecifiersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_delegationSpecifiers }
	//fn type_rule_index() -> usize where Self: Sized { RULE_delegationSpecifiers }
}
antlr_rust::tid!{DelegationSpecifiersContextExt<'a>}

impl<'input> DelegationSpecifiersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DelegationSpecifiersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DelegationSpecifiersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DelegationSpecifiersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<DelegationSpecifiersContextExt<'input>>{

fn annotatedDelegationSpecifier_all(&self) ->  Vec<Rc<AnnotatedDelegationSpecifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotatedDelegationSpecifier(&self, i: usize) -> Option<Rc<AnnotatedDelegationSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> DelegationSpecifiersContextAttrs<'input> for DelegationSpecifiersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn delegationSpecifiers(&mut self,)
	-> Result<Rc<DelegationSpecifiersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DelegationSpecifiersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 32, RULE_delegationSpecifiers);
        let mut _localctx: Rc<DelegationSpecifiersContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule annotatedDelegationSpecifier*/
			recog.base.set_state(703);
			recog.annotatedDelegationSpecifier()?;

			recog.base.set_state(720);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(66,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(707);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(704);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(709);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(710);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(714);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(65,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(711);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(716);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(65,&mut recog.base)?;
					}
					/*InvokeRule annotatedDelegationSpecifier*/
					recog.base.set_state(717);
					recog.annotatedDelegationSpecifier()?;

					}
					} 
				}
				recog.base.set_state(722);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(66,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- delegationSpecifier ----------------
pub type DelegationSpecifierContextAll<'input> = DelegationSpecifierContext<'input>;


pub type DelegationSpecifierContext<'input> = BaseParserRuleContext<'input,DelegationSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct DelegationSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for DelegationSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for DelegationSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_delegationSpecifier(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_delegationSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for DelegationSpecifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_delegationSpecifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for DelegationSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_delegationSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_delegationSpecifier }
}
antlr_rust::tid!{DelegationSpecifierContextExt<'a>}

impl<'input> DelegationSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DelegationSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DelegationSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DelegationSpecifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<DelegationSpecifierContextExt<'input>>{

fn constructorInvocation(&self) -> Option<Rc<ConstructorInvocationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn explicitDelegation(&self) -> Option<Rc<ExplicitDelegationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn userType(&self) -> Option<Rc<UserTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionType(&self) -> Option<Rc<FunctionTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DelegationSpecifierContextAttrs<'input> for DelegationSpecifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn delegationSpecifier(&mut self,)
	-> Result<Rc<DelegationSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DelegationSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 34, RULE_delegationSpecifier);
        let mut _localctx: Rc<DelegationSpecifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(727);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(67,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule constructorInvocation*/
					recog.base.set_state(723);
					recog.constructorInvocation()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule explicitDelegation*/
					recog.base.set_state(724);
					recog.explicitDelegation()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule userType*/
					recog.base.set_state(725);
					recog.userType()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule functionType*/
					recog.base.set_state(726);
					recog.functionType()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constructorInvocation ----------------
pub type ConstructorInvocationContextAll<'input> = ConstructorInvocationContext<'input>;


pub type ConstructorInvocationContext<'input> = BaseParserRuleContext<'input,ConstructorInvocationContextExt<'input>>;

#[derive(Clone)]
pub struct ConstructorInvocationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ConstructorInvocationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ConstructorInvocationContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constructorInvocation(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_constructorInvocation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ConstructorInvocationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_constructorInvocation(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConstructorInvocationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constructorInvocation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constructorInvocation }
}
antlr_rust::tid!{ConstructorInvocationContextExt<'a>}

impl<'input> ConstructorInvocationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstructorInvocationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstructorInvocationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstructorInvocationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ConstructorInvocationContextExt<'input>>{

fn userType(&self) -> Option<Rc<UserTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn valueArguments(&self) -> Option<Rc<ValueArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstructorInvocationContextAttrs<'input> for ConstructorInvocationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constructorInvocation(&mut self,)
	-> Result<Rc<ConstructorInvocationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstructorInvocationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 36, RULE_constructorInvocation);
        let mut _localctx: Rc<ConstructorInvocationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule userType*/
			recog.base.set_state(729);
			recog.userType()?;

			/*InvokeRule valueArguments*/
			recog.base.set_state(730);
			recog.valueArguments()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotatedDelegationSpecifier ----------------
pub type AnnotatedDelegationSpecifierContextAll<'input> = AnnotatedDelegationSpecifierContext<'input>;


pub type AnnotatedDelegationSpecifierContext<'input> = BaseParserRuleContext<'input,AnnotatedDelegationSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotatedDelegationSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AnnotatedDelegationSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AnnotatedDelegationSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotatedDelegationSpecifier(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_annotatedDelegationSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AnnotatedDelegationSpecifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_annotatedDelegationSpecifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for AnnotatedDelegationSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotatedDelegationSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotatedDelegationSpecifier }
}
antlr_rust::tid!{AnnotatedDelegationSpecifierContextExt<'a>}

impl<'input> AnnotatedDelegationSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotatedDelegationSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotatedDelegationSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotatedDelegationSpecifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AnnotatedDelegationSpecifierContextExt<'input>>{

fn delegationSpecifier(&self) -> Option<Rc<DelegationSpecifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> AnnotatedDelegationSpecifierContextAttrs<'input> for AnnotatedDelegationSpecifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotatedDelegationSpecifier(&mut self,)
	-> Result<Rc<AnnotatedDelegationSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotatedDelegationSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 38, RULE_annotatedDelegationSpecifier);
        let mut _localctx: Rc<AnnotatedDelegationSpecifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(735);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(68,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule annotation*/
					recog.base.set_state(732);
					recog.annotation()?;

					}
					} 
				}
				recog.base.set_state(737);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(68,&mut recog.base)?;
			}
			recog.base.set_state(741);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(738);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(743);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule delegationSpecifier*/
			recog.base.set_state(744);
			recog.delegationSpecifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- explicitDelegation ----------------
pub type ExplicitDelegationContextAll<'input> = ExplicitDelegationContext<'input>;


pub type ExplicitDelegationContext<'input> = BaseParserRuleContext<'input,ExplicitDelegationContextExt<'input>>;

#[derive(Clone)]
pub struct ExplicitDelegationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ExplicitDelegationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ExplicitDelegationContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_explicitDelegation(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_explicitDelegation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ExplicitDelegationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_explicitDelegation(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExplicitDelegationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_explicitDelegation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_explicitDelegation }
}
antlr_rust::tid!{ExplicitDelegationContextExt<'a>}

impl<'input> ExplicitDelegationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExplicitDelegationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExplicitDelegationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExplicitDelegationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ExplicitDelegationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token BY
/// Returns `None` if there is no child corresponding to token BY
fn BY(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(BY, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn userType(&self) -> Option<Rc<UserTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionType(&self) -> Option<Rc<FunctionTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ExplicitDelegationContextAttrs<'input> for ExplicitDelegationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn explicitDelegation(&mut self,)
	-> Result<Rc<ExplicitDelegationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExplicitDelegationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 40, RULE_explicitDelegation);
        let mut _localctx: Rc<ExplicitDelegationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(748);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(70,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule userType*/
					recog.base.set_state(746);
					recog.userType()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule functionType*/
					recog.base.set_state(747);
					recog.functionType()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(753);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(750);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(755);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(756);
			recog.base.match_token(BY,&mut recog.err_handler)?;

			recog.base.set_state(760);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(757);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(762);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule expression*/
			recog.base.set_state(763);
			recog.expression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeParameters ----------------
pub type TypeParametersContextAll<'input> = TypeParametersContext<'input>;


pub type TypeParametersContext<'input> = BaseParserRuleContext<'input,TypeParametersContextExt<'input>>;

#[derive(Clone)]
pub struct TypeParametersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeParametersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeParametersContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeParameters(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_typeParameters(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeParametersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeParameters(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeParametersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeParameters }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeParameters }
}
antlr_rust::tid!{TypeParametersContextExt<'a>}

impl<'input> TypeParametersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeParametersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeParametersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeParametersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeParametersContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LANGLE
/// Returns `None` if there is no child corresponding to token LANGLE
fn LANGLE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LANGLE, 0)
}
fn typeParameter_all(&self) ->  Vec<Rc<TypeParameterContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeParameter(&self, i: usize) -> Option<Rc<TypeParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token RANGLE
/// Returns `None` if there is no child corresponding to token RANGLE
fn RANGLE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RANGLE, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> TypeParametersContextAttrs<'input> for TypeParametersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeParameters(&mut self,)
	-> Result<Rc<TypeParametersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeParametersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 42, RULE_typeParameters);
        let mut _localctx: Rc<TypeParametersContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(765);
			recog.base.match_token(LANGLE,&mut recog.err_handler)?;

			recog.base.set_state(769);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(73,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(766);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(771);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(73,&mut recog.base)?;
			}
			/*InvokeRule typeParameter*/
			recog.base.set_state(772);
			recog.typeParameter()?;

			recog.base.set_state(789);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(76,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(776);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(773);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(778);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(779);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(783);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(75,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(780);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(785);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(75,&mut recog.base)?;
					}
					/*InvokeRule typeParameter*/
					recog.base.set_state(786);
					recog.typeParameter()?;

					}
					} 
				}
				recog.base.set_state(791);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(76,&mut recog.base)?;
			}
			recog.base.set_state(799);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(78,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(795);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(792);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(797);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(798);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(804);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(801);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(806);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(807);
			recog.base.match_token(RANGLE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeParameter ----------------
pub type TypeParameterContextAll<'input> = TypeParameterContext<'input>;


pub type TypeParameterContext<'input> = BaseParserRuleContext<'input,TypeParameterContextExt<'input>>;

#[derive(Clone)]
pub struct TypeParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeParameterContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeParameter(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_typeParameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeParameterContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeParameter(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeParameter }
}
antlr_rust::tid!{TypeParameterContextExt<'a>}

impl<'input> TypeParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeParameterContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeParameterContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeParameterModifiers(&self) -> Option<Rc<TypeParameterModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn rustType(&self) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeParameterContextAttrs<'input> for TypeParameterContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeParameter(&mut self,)
	-> Result<Rc<TypeParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 44, RULE_typeParameter);
        let mut _localctx: Rc<TypeParameterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(810);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(80,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule typeParameterModifiers*/
					recog.base.set_state(809);
					recog.typeParameterModifiers()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(815);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(812);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(817);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(818);
			recog.simpleIdentifier()?;

			recog.base.set_state(833);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(84,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(822);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(819);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(824);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(825);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(829);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(826);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(831);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule rustType*/
					recog.base.set_state(832);
					recog.rustType()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeConstraints ----------------
pub type TypeConstraintsContextAll<'input> = TypeConstraintsContext<'input>;


pub type TypeConstraintsContext<'input> = BaseParserRuleContext<'input,TypeConstraintsContextExt<'input>>;

#[derive(Clone)]
pub struct TypeConstraintsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeConstraintsContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeConstraintsContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeConstraints(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_typeConstraints(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeConstraintsContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeConstraints(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeConstraintsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeConstraints }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeConstraints }
}
antlr_rust::tid!{TypeConstraintsContextExt<'a>}

impl<'input> TypeConstraintsContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeConstraintsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeConstraintsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeConstraintsContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeConstraintsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token WHERE
/// Returns `None` if there is no child corresponding to token WHERE
fn WHERE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(WHERE, 0)
}
fn typeConstraint_all(&self) ->  Vec<Rc<TypeConstraintContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeConstraint(&self, i: usize) -> Option<Rc<TypeConstraintContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> TypeConstraintsContextAttrs<'input> for TypeConstraintsContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeConstraints(&mut self,)
	-> Result<Rc<TypeConstraintsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeConstraintsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 46, RULE_typeConstraints);
        let mut _localctx: Rc<TypeConstraintsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(835);
			recog.base.match_token(WHERE,&mut recog.err_handler)?;

			recog.base.set_state(839);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(836);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(841);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule typeConstraint*/
			recog.base.set_state(842);
			recog.typeConstraint()?;

			recog.base.set_state(859);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(88,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(846);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(843);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(848);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(849);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(853);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(850);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(855);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeConstraint*/
					recog.base.set_state(856);
					recog.typeConstraint()?;

					}
					} 
				}
				recog.base.set_state(861);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(88,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeConstraint ----------------
pub type TypeConstraintContextAll<'input> = TypeConstraintContext<'input>;


pub type TypeConstraintContext<'input> = BaseParserRuleContext<'input,TypeConstraintContextExt<'input>>;

#[derive(Clone)]
pub struct TypeConstraintContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeConstraintContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeConstraintContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeConstraint(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_typeConstraint(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeConstraintContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeConstraint(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeConstraintContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeConstraint }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeConstraint }
}
antlr_rust::tid!{TypeConstraintContextExt<'a>}

impl<'input> TypeConstraintContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeConstraintContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeConstraintContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeConstraintContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeConstraintContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn rustType(&self) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> TypeConstraintContextAttrs<'input> for TypeConstraintContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeConstraint(&mut self,)
	-> Result<Rc<TypeConstraintContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeConstraintContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 48, RULE_typeConstraint);
        let mut _localctx: Rc<TypeConstraintContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(865);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT_NO_WS || _la==AT_PRE_WS {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(862);
				recog.annotation()?;

				}
				}
				recog.base.set_state(867);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(868);
			recog.simpleIdentifier()?;

			recog.base.set_state(872);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(869);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(874);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(875);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			recog.base.set_state(879);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(876);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(881);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule rustType*/
			recog.base.set_state(882);
			recog.rustType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classMemberDeclarations ----------------
pub type ClassMemberDeclarationsContextAll<'input> = ClassMemberDeclarationsContext<'input>;


pub type ClassMemberDeclarationsContext<'input> = BaseParserRuleContext<'input,ClassMemberDeclarationsContextExt<'input>>;

#[derive(Clone)]
pub struct ClassMemberDeclarationsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ClassMemberDeclarationsContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ClassMemberDeclarationsContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classMemberDeclarations(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_classMemberDeclarations(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ClassMemberDeclarationsContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_classMemberDeclarations(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassMemberDeclarationsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classMemberDeclarations }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classMemberDeclarations }
}
antlr_rust::tid!{ClassMemberDeclarationsContextExt<'a>}

impl<'input> ClassMemberDeclarationsContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassMemberDeclarationsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassMemberDeclarationsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassMemberDeclarationsContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ClassMemberDeclarationsContextExt<'input>>{

fn classMemberDeclaration_all(&self) ->  Vec<Rc<ClassMemberDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn classMemberDeclaration(&self, i: usize) -> Option<Rc<ClassMemberDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn semis_all(&self) ->  Vec<Rc<SemisContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn semis(&self, i: usize) -> Option<Rc<SemisContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ClassMemberDeclarationsContextAttrs<'input> for ClassMemberDeclarationsContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classMemberDeclarations(&mut self,)
	-> Result<Rc<ClassMemberDeclarationsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassMemberDeclarationsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 50, RULE_classMemberDeclarations);
        let mut _localctx: Rc<ClassMemberDeclarationsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(890);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 72)) & !0x3f) == 0 && ((1usize << (_la - 72)) & ((1usize << (CLASS - 72)) | (1usize << (INTERFACE - 72)) | (1usize << (FUN - 72)) | (1usize << (OBJECT - 72)) | (1usize << (VAL - 72)) | (1usize << (VAR - 72)) | (1usize << (TYPE_ALIAS - 72)) | (1usize << (CONSTRUCTOR - 72)) | (1usize << (COMPANION - 72)) | (1usize << (INIT - 72)) | (1usize << (PUBLIC - 72)) | (1usize << (PRIVATE - 72)) | (1usize << (PROTECTED - 72)) | (1usize << (INTERNAL - 72)) | (1usize << (ENUM - 72)) | (1usize << (SEALED - 72)) | (1usize << (ANNOTATION - 72)) | (1usize << (DATA - 72)) | (1usize << (INNER - 72)) | (1usize << (VALUE - 72)) | (1usize << (TAILREC - 72)) | (1usize << (OPERATOR - 72)) | (1usize << (INLINE - 72)) | (1usize << (INFIX - 72)) | (1usize << (EXTERNAL - 72)) | (1usize << (SUSPEND - 72)) | (1usize << (OVERRIDE - 72)) | (1usize << (ABSTRACT - 72)) | (1usize << (FINAL - 72)) | (1usize << (OPEN - 72)) | (1usize << (CONST - 72)) | (1usize << (LATEINIT - 72)) | (1usize << (VARARG - 72)) | (1usize << (NOINLINE - 72)) | (1usize << (CROSSINLINE - 72)) | (1usize << (EXPECT - 72)) | (1usize << (ACTUAL - 72)))) != 0) {
				{
				{
				/*InvokeRule classMemberDeclaration*/
				recog.base.set_state(884);
				recog.classMemberDeclaration()?;

				recog.base.set_state(886);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(92,&mut recog.base)? {
					x if x == 1=>{
						{
						/*InvokeRule semis*/
						recog.base.set_state(885);
						recog.semis()?;

						}
					}

					_ => {}
				}
				}
				}
				recog.base.set_state(892);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classMemberDeclaration ----------------
pub type ClassMemberDeclarationContextAll<'input> = ClassMemberDeclarationContext<'input>;


pub type ClassMemberDeclarationContext<'input> = BaseParserRuleContext<'input,ClassMemberDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ClassMemberDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ClassMemberDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ClassMemberDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classMemberDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_classMemberDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ClassMemberDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_classMemberDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassMemberDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classMemberDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classMemberDeclaration }
}
antlr_rust::tid!{ClassMemberDeclarationContextExt<'a>}

impl<'input> ClassMemberDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassMemberDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassMemberDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassMemberDeclarationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ClassMemberDeclarationContextExt<'input>>{

fn declaration(&self) -> Option<Rc<DeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn companionObject(&self) -> Option<Rc<CompanionObjectContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn anonymousInitializer(&self) -> Option<Rc<AnonymousInitializerContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn secondaryConstructor(&self) -> Option<Rc<SecondaryConstructorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassMemberDeclarationContextAttrs<'input> for ClassMemberDeclarationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classMemberDeclaration(&mut self,)
	-> Result<Rc<ClassMemberDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassMemberDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 52, RULE_classMemberDeclaration);
        let mut _localctx: Rc<ClassMemberDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(897);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(94,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule declaration*/
					recog.base.set_state(893);
					recog.declaration()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule companionObject*/
					recog.base.set_state(894);
					recog.companionObject()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule anonymousInitializer*/
					recog.base.set_state(895);
					recog.anonymousInitializer()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule secondaryConstructor*/
					recog.base.set_state(896);
					recog.secondaryConstructor()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- anonymousInitializer ----------------
pub type AnonymousInitializerContextAll<'input> = AnonymousInitializerContext<'input>;


pub type AnonymousInitializerContext<'input> = BaseParserRuleContext<'input,AnonymousInitializerContextExt<'input>>;

#[derive(Clone)]
pub struct AnonymousInitializerContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AnonymousInitializerContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AnonymousInitializerContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_anonymousInitializer(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_anonymousInitializer(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AnonymousInitializerContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_anonymousInitializer(self);
	}
}

impl<'input> CustomRuleContext<'input> for AnonymousInitializerContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_anonymousInitializer }
	//fn type_rule_index() -> usize where Self: Sized { RULE_anonymousInitializer }
}
antlr_rust::tid!{AnonymousInitializerContextExt<'a>}

impl<'input> AnonymousInitializerContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnonymousInitializerContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnonymousInitializerContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnonymousInitializerContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AnonymousInitializerContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INIT
/// Returns `None` if there is no child corresponding to token INIT
fn INIT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INIT, 0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> AnonymousInitializerContextAttrs<'input> for AnonymousInitializerContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn anonymousInitializer(&mut self,)
	-> Result<Rc<AnonymousInitializerContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnonymousInitializerContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 54, RULE_anonymousInitializer);
        let mut _localctx: Rc<AnonymousInitializerContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(899);
			recog.base.match_token(INIT,&mut recog.err_handler)?;

			recog.base.set_state(903);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(900);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(905);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule block*/
			recog.base.set_state(906);
			recog.block()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- companionObject ----------------
pub type CompanionObjectContextAll<'input> = CompanionObjectContext<'input>;


pub type CompanionObjectContext<'input> = BaseParserRuleContext<'input,CompanionObjectContextExt<'input>>;

#[derive(Clone)]
pub struct CompanionObjectContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for CompanionObjectContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for CompanionObjectContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_companionObject(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_companionObject(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for CompanionObjectContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_companionObject(self);
	}
}

impl<'input> CustomRuleContext<'input> for CompanionObjectContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_companionObject }
	//fn type_rule_index() -> usize where Self: Sized { RULE_companionObject }
}
antlr_rust::tid!{CompanionObjectContextExt<'a>}

impl<'input> CompanionObjectContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CompanionObjectContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CompanionObjectContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CompanionObjectContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<CompanionObjectContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token COMPANION
/// Returns `None` if there is no child corresponding to token COMPANION
fn COMPANION(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMPANION, 0)
}
/// Retrieves first TerminalNode corresponding to token OBJECT
/// Returns `None` if there is no child corresponding to token OBJECT
fn OBJECT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OBJECT, 0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn delegationSpecifiers(&self) -> Option<Rc<DelegationSpecifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classBody(&self) -> Option<Rc<ClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CompanionObjectContextAttrs<'input> for CompanionObjectContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn companionObject(&mut self,)
	-> Result<Rc<CompanionObjectContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CompanionObjectContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 56, RULE_companionObject);
        let mut _localctx: Rc<CompanionObjectContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(909);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 107)) & !0x3f) == 0 && ((1usize << (_la - 107)) & ((1usize << (PUBLIC - 107)) | (1usize << (PRIVATE - 107)) | (1usize << (PROTECTED - 107)) | (1usize << (INTERNAL - 107)) | (1usize << (ENUM - 107)) | (1usize << (SEALED - 107)) | (1usize << (ANNOTATION - 107)) | (1usize << (DATA - 107)) | (1usize << (INNER - 107)) | (1usize << (VALUE - 107)) | (1usize << (TAILREC - 107)) | (1usize << (OPERATOR - 107)) | (1usize << (INLINE - 107)) | (1usize << (INFIX - 107)) | (1usize << (EXTERNAL - 107)) | (1usize << (SUSPEND - 107)) | (1usize << (OVERRIDE - 107)) | (1usize << (ABSTRACT - 107)) | (1usize << (FINAL - 107)) | (1usize << (OPEN - 107)) | (1usize << (CONST - 107)) | (1usize << (LATEINIT - 107)) | (1usize << (VARARG - 107)) | (1usize << (NOINLINE - 107)) | (1usize << (CROSSINLINE - 107)) | (1usize << (EXPECT - 107)) | (1usize << (ACTUAL - 107)))) != 0) {
				{
				/*InvokeRule modifiers*/
				recog.base.set_state(908);
				recog.modifiers()?;

				}
			}

			recog.base.set_state(911);
			recog.base.match_token(COMPANION,&mut recog.err_handler)?;

			recog.base.set_state(915);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(912);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(917);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(918);
			recog.base.match_token(OBJECT,&mut recog.err_handler)?;

			recog.base.set_state(926);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(99,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(922);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(919);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(924);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule simpleIdentifier*/
					recog.base.set_state(925);
					recog.simpleIdentifier()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(942);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(102,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(931);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(928);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(933);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(934);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(938);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(101,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(935);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(940);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(101,&mut recog.base)?;
					}
					/*InvokeRule delegationSpecifiers*/
					recog.base.set_state(941);
					recog.delegationSpecifiers()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(951);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(104,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(947);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(944);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(949);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule classBody*/
					recog.base.set_state(950);
					recog.classBody()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionValueParameters ----------------
pub type FunctionValueParametersContextAll<'input> = FunctionValueParametersContext<'input>;


pub type FunctionValueParametersContext<'input> = BaseParserRuleContext<'input,FunctionValueParametersContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionValueParametersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FunctionValueParametersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FunctionValueParametersContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_functionValueParameters(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_functionValueParameters(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FunctionValueParametersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_functionValueParameters(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionValueParametersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionValueParameters }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionValueParameters }
}
antlr_rust::tid!{FunctionValueParametersContextExt<'a>}

impl<'input> FunctionValueParametersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionValueParametersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionValueParametersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionValueParametersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FunctionValueParametersContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn functionValueParameter_all(&self) ->  Vec<Rc<FunctionValueParameterContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn functionValueParameter(&self, i: usize) -> Option<Rc<FunctionValueParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> FunctionValueParametersContextAttrs<'input> for FunctionValueParametersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionValueParameters(&mut self,)
	-> Result<Rc<FunctionValueParametersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionValueParametersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 58, RULE_functionValueParameters);
        let mut _localctx: Rc<FunctionValueParametersContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(953);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(957);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(105,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(954);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(959);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(105,&mut recog.base)?;
			}
			recog.base.set_state(989);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if ((((_la - 40)) & !0x3f) == 0 && ((1usize << (_la - 40)) & ((1usize << (AT_NO_WS - 40)) | (1usize << (AT_PRE_WS - 40)) | (1usize << (FILE - 40)) | (1usize << (FIELD - 40)) | (1usize << (PROPERTY - 40)) | (1usize << (GET - 40)) | (1usize << (SET - 40)) | (1usize << (RECEIVER - 40)) | (1usize << (PARAM - 40)) | (1usize << (SETPARAM - 40)) | (1usize << (DELEGATE - 40)) | (1usize << (IMPORT - 40)) | (1usize << (CONSTRUCTOR - 40)) | (1usize << (BY - 40)) | (1usize << (COMPANION - 40)) | (1usize << (INIT - 40)) | (1usize << (WHERE - 40)) | (1usize << (CATCH - 40)) | (1usize << (FINALLY - 40)))) != 0) || ((((_la - 105)) & !0x3f) == 0 && ((1usize << (_la - 105)) & ((1usize << (OUT - 105)) | (1usize << (DYNAMIC - 105)) | (1usize << (PUBLIC - 105)) | (1usize << (PRIVATE - 105)) | (1usize << (PROTECTED - 105)) | (1usize << (INTERNAL - 105)) | (1usize << (ENUM - 105)) | (1usize << (SEALED - 105)) | (1usize << (ANNOTATION - 105)) | (1usize << (DATA - 105)) | (1usize << (INNER - 105)) | (1usize << (VALUE - 105)) | (1usize << (TAILREC - 105)) | (1usize << (OPERATOR - 105)) | (1usize << (INLINE - 105)) | (1usize << (INFIX - 105)) | (1usize << (EXTERNAL - 105)) | (1usize << (SUSPEND - 105)) | (1usize << (OVERRIDE - 105)) | (1usize << (ABSTRACT - 105)) | (1usize << (FINAL - 105)) | (1usize << (OPEN - 105)) | (1usize << (CONST - 105)) | (1usize << (LATEINIT - 105)) | (1usize << (VARARG - 105)) | (1usize << (NOINLINE - 105)) | (1usize << (CROSSINLINE - 105)) | (1usize << (REIFIED - 105)) | (1usize << (EXPECT - 105)) | (1usize << (ACTUAL - 105)) | (1usize << (Identifier - 105)))) != 0) {
				{
				/*InvokeRule functionValueParameter*/
				recog.base.set_state(960);
				recog.functionValueParameter()?;

				recog.base.set_state(977);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(108,&mut recog.base)?;
				while { _alt!=2 && _alt!=INVALID_ALT } {
					if _alt==1 {
						{
						{
						recog.base.set_state(964);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(961);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(966);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(967);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						recog.base.set_state(971);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(968);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(973);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						/*InvokeRule functionValueParameter*/
						recog.base.set_state(974);
						recog.functionValueParameter()?;

						}
						} 
					}
					recog.base.set_state(979);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(108,&mut recog.base)?;
				}
				recog.base.set_state(987);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(110,&mut recog.base)? {
					x if x == 1=>{
						{
						recog.base.set_state(983);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(980);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(985);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(986);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						}
					}

					_ => {}
				}
				}
			}

			recog.base.set_state(994);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(991);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(996);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(997);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionValueParameter ----------------
pub type FunctionValueParameterContextAll<'input> = FunctionValueParameterContext<'input>;


pub type FunctionValueParameterContext<'input> = BaseParserRuleContext<'input,FunctionValueParameterContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionValueParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FunctionValueParameterContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FunctionValueParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_functionValueParameter(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_functionValueParameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FunctionValueParameterContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_functionValueParameter(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionValueParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionValueParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionValueParameter }
}
antlr_rust::tid!{FunctionValueParameterContextExt<'a>}

impl<'input> FunctionValueParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionValueParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionValueParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionValueParameterContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FunctionValueParameterContextExt<'input>>{

fn parameter(&self) -> Option<Rc<ParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parameterModifiers(&self) -> Option<Rc<ParameterModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ASSIGNMENT
fn ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ASSIGNMENT, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> FunctionValueParameterContextAttrs<'input> for FunctionValueParameterContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionValueParameter(&mut self,)
	-> Result<Rc<FunctionValueParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionValueParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 60, RULE_functionValueParameter);
        let mut _localctx: Rc<FunctionValueParameterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1000);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(113,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule parameterModifiers*/
					recog.base.set_state(999);
					recog.parameterModifiers()?;

					}
				}

				_ => {}
			}
			/*InvokeRule parameter*/
			recog.base.set_state(1002);
			recog.parameter()?;

			recog.base.set_state(1017);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(116,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1006);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1003);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1008);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1009);
					recog.base.match_token(ASSIGNMENT,&mut recog.err_handler)?;

					recog.base.set_state(1013);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1010);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1015);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule expression*/
					recog.base.set_state(1016);
					recog.expression()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionDeclaration ----------------
pub type FunctionDeclarationContextAll<'input> = FunctionDeclarationContext<'input>;


pub type FunctionDeclarationContext<'input> = BaseParserRuleContext<'input,FunctionDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FunctionDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FunctionDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_functionDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_functionDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FunctionDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_functionDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionDeclaration }
}
antlr_rust::tid!{FunctionDeclarationContextExt<'a>}

impl<'input> FunctionDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionDeclarationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FunctionDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FUN
/// Returns `None` if there is no child corresponding to token FUN
fn FUN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FUN, 0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionValueParameters(&self) -> Option<Rc<FunctionValueParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeParameters(&self) -> Option<Rc<TypeParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn receiverType(&self) -> Option<Rc<ReceiverTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn rustType(&self) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeConstraints(&self) -> Option<Rc<TypeConstraintsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionBody(&self) -> Option<Rc<FunctionBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FunctionDeclarationContextAttrs<'input> for FunctionDeclarationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionDeclaration(&mut self,)
	-> Result<Rc<FunctionDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 62, RULE_functionDeclaration);
        let mut _localctx: Rc<FunctionDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1020);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 107)) & !0x3f) == 0 && ((1usize << (_la - 107)) & ((1usize << (PUBLIC - 107)) | (1usize << (PRIVATE - 107)) | (1usize << (PROTECTED - 107)) | (1usize << (INTERNAL - 107)) | (1usize << (ENUM - 107)) | (1usize << (SEALED - 107)) | (1usize << (ANNOTATION - 107)) | (1usize << (DATA - 107)) | (1usize << (INNER - 107)) | (1usize << (VALUE - 107)) | (1usize << (TAILREC - 107)) | (1usize << (OPERATOR - 107)) | (1usize << (INLINE - 107)) | (1usize << (INFIX - 107)) | (1usize << (EXTERNAL - 107)) | (1usize << (SUSPEND - 107)) | (1usize << (OVERRIDE - 107)) | (1usize << (ABSTRACT - 107)) | (1usize << (FINAL - 107)) | (1usize << (OPEN - 107)) | (1usize << (CONST - 107)) | (1usize << (LATEINIT - 107)) | (1usize << (VARARG - 107)) | (1usize << (NOINLINE - 107)) | (1usize << (CROSSINLINE - 107)) | (1usize << (EXPECT - 107)) | (1usize << (ACTUAL - 107)))) != 0) {
				{
				/*InvokeRule modifiers*/
				recog.base.set_state(1019);
				recog.modifiers()?;

				}
			}

			recog.base.set_state(1022);
			recog.base.match_token(FUN,&mut recog.err_handler)?;

			recog.base.set_state(1030);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(119,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1026);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1023);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1028);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeParameters*/
					recog.base.set_state(1029);
					recog.typeParameters()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1047);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(122,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1035);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1032);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1037);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule receiverType*/
					recog.base.set_state(1038);
					recog.receiverType()?;

					recog.base.set_state(1042);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1039);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1044);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1045);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1052);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1049);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1054);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(1055);
			recog.simpleIdentifier()?;

			recog.base.set_state(1059);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1056);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1061);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule functionValueParameters*/
			recog.base.set_state(1062);
			recog.functionValueParameters()?;

			recog.base.set_state(1077);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(127,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1066);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1063);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1068);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1069);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(1073);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1070);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1075);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule rustType*/
					recog.base.set_state(1076);
					recog.rustType()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1086);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(129,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1082);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1079);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1084);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeConstraints*/
					recog.base.set_state(1085);
					recog.typeConstraints()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1095);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(131,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1091);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1088);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1093);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule functionBody*/
					recog.base.set_state(1094);
					recog.functionBody()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionBody ----------------
pub type FunctionBodyContextAll<'input> = FunctionBodyContext<'input>;


pub type FunctionBodyContext<'input> = BaseParserRuleContext<'input,FunctionBodyContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FunctionBodyContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FunctionBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_functionBody(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_functionBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FunctionBodyContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_functionBody(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionBody }
}
antlr_rust::tid!{FunctionBodyContextExt<'a>}

impl<'input> FunctionBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionBodyContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FunctionBodyContextExt<'input>>{

fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ASSIGNMENT
fn ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ASSIGNMENT, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> FunctionBodyContextAttrs<'input> for FunctionBodyContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionBody(&mut self,)
	-> Result<Rc<FunctionBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 64, RULE_functionBody);
        let mut _localctx: Rc<FunctionBodyContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1106);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LCURL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule block*/
					recog.base.set_state(1097);
					recog.block()?;

					}
				}

			 ASSIGNMENT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1098);
					recog.base.match_token(ASSIGNMENT,&mut recog.err_handler)?;

					recog.base.set_state(1102);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1099);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1104);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule expression*/
					recog.base.set_state(1105);
					recog.expression()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variableDeclaration ----------------
pub type VariableDeclarationContextAll<'input> = VariableDeclarationContext<'input>;


pub type VariableDeclarationContext<'input> = BaseParserRuleContext<'input,VariableDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct VariableDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for VariableDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for VariableDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_variableDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_variableDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for VariableDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_variableDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for VariableDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variableDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variableDeclaration }
}
antlr_rust::tid!{VariableDeclarationContextExt<'a>}

impl<'input> VariableDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VariableDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VariableDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VariableDeclarationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<VariableDeclarationContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn rustType(&self) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> VariableDeclarationContextAttrs<'input> for VariableDeclarationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variableDeclaration(&mut self,)
	-> Result<Rc<VariableDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VariableDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 66, RULE_variableDeclaration);
        let mut _localctx: Rc<VariableDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1111);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT_NO_WS || _la==AT_PRE_WS {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(1108);
				recog.annotation()?;

				}
				}
				recog.base.set_state(1113);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1117);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1114);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1119);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(1120);
			recog.simpleIdentifier()?;

			recog.base.set_state(1135);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(138,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1124);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1121);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1126);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1127);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(1131);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1128);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1133);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule rustType*/
					recog.base.set_state(1134);
					recog.rustType()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- multiVariableDeclaration ----------------
pub type MultiVariableDeclarationContextAll<'input> = MultiVariableDeclarationContext<'input>;


pub type MultiVariableDeclarationContext<'input> = BaseParserRuleContext<'input,MultiVariableDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct MultiVariableDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for MultiVariableDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for MultiVariableDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_multiVariableDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_multiVariableDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for MultiVariableDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_multiVariableDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for MultiVariableDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_multiVariableDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_multiVariableDeclaration }
}
antlr_rust::tid!{MultiVariableDeclarationContextExt<'a>}

impl<'input> MultiVariableDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MultiVariableDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MultiVariableDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MultiVariableDeclarationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<MultiVariableDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn variableDeclaration_all(&self) ->  Vec<Rc<VariableDeclarationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableDeclaration(&self, i: usize) -> Option<Rc<VariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> MultiVariableDeclarationContextAttrs<'input> for MultiVariableDeclarationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn multiVariableDeclaration(&mut self,)
	-> Result<Rc<MultiVariableDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MultiVariableDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 68, RULE_multiVariableDeclaration);
        let mut _localctx: Rc<MultiVariableDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1137);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1141);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(139,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1138);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1143);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(139,&mut recog.base)?;
			}
			/*InvokeRule variableDeclaration*/
			recog.base.set_state(1144);
			recog.variableDeclaration()?;

			recog.base.set_state(1161);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(142,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1148);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1145);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1150);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1151);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(1155);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(141,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(1152);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(1157);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(141,&mut recog.base)?;
					}
					/*InvokeRule variableDeclaration*/
					recog.base.set_state(1158);
					recog.variableDeclaration()?;

					}
					} 
				}
				recog.base.set_state(1163);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(142,&mut recog.base)?;
			}
			recog.base.set_state(1171);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(144,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1167);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1164);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1169);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1170);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1176);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1173);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1178);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1179);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- propertyDeclaration ----------------
pub type PropertyDeclarationContextAll<'input> = PropertyDeclarationContext<'input>;


pub type PropertyDeclarationContext<'input> = BaseParserRuleContext<'input,PropertyDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct PropertyDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PropertyDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PropertyDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_propertyDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_propertyDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PropertyDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_propertyDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for PropertyDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_propertyDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_propertyDeclaration }
}
antlr_rust::tid!{PropertyDeclarationContextExt<'a>}

impl<'input> PropertyDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PropertyDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PropertyDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PropertyDeclarationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PropertyDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token VAL
/// Returns `None` if there is no child corresponding to token VAL
fn VAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(VAL, 0)
}
/// Retrieves first TerminalNode corresponding to token VAR
/// Returns `None` if there is no child corresponding to token VAR
fn VAR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(VAR, 0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeParameters(&self) -> Option<Rc<TypeParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn receiverType(&self) -> Option<Rc<ReceiverTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn typeConstraints(&self) -> Option<Rc<TypeConstraintsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMICOLON
/// Returns `None` if there is no child corresponding to token SEMICOLON
fn SEMICOLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SEMICOLON, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn multiVariableDeclaration(&self) -> Option<Rc<MultiVariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn variableDeclaration(&self) -> Option<Rc<VariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ASSIGNMENT
fn ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ASSIGNMENT, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn propertyDelegate(&self) -> Option<Rc<PropertyDelegateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn getter(&self) -> Option<Rc<GetterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn setter(&self) -> Option<Rc<SetterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn semi(&self) -> Option<Rc<SemiContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PropertyDeclarationContextAttrs<'input> for PropertyDeclarationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn propertyDeclaration(&mut self,)
	-> Result<Rc<PropertyDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PropertyDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 70, RULE_propertyDeclaration);
        let mut _localctx: Rc<PropertyDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1182);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 107)) & !0x3f) == 0 && ((1usize << (_la - 107)) & ((1usize << (PUBLIC - 107)) | (1usize << (PRIVATE - 107)) | (1usize << (PROTECTED - 107)) | (1usize << (INTERNAL - 107)) | (1usize << (ENUM - 107)) | (1usize << (SEALED - 107)) | (1usize << (ANNOTATION - 107)) | (1usize << (DATA - 107)) | (1usize << (INNER - 107)) | (1usize << (VALUE - 107)) | (1usize << (TAILREC - 107)) | (1usize << (OPERATOR - 107)) | (1usize << (INLINE - 107)) | (1usize << (INFIX - 107)) | (1usize << (EXTERNAL - 107)) | (1usize << (SUSPEND - 107)) | (1usize << (OVERRIDE - 107)) | (1usize << (ABSTRACT - 107)) | (1usize << (FINAL - 107)) | (1usize << (OPEN - 107)) | (1usize << (CONST - 107)) | (1usize << (LATEINIT - 107)) | (1usize << (VARARG - 107)) | (1usize << (NOINLINE - 107)) | (1usize << (CROSSINLINE - 107)) | (1usize << (EXPECT - 107)) | (1usize << (ACTUAL - 107)))) != 0) {
				{
				/*InvokeRule modifiers*/
				recog.base.set_state(1181);
				recog.modifiers()?;

				}
			}

			recog.base.set_state(1184);
			_la = recog.base.input.la(1);
			if { !(_la==VAL || _la==VAR) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			recog.base.set_state(1192);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(148,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1188);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1185);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1190);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeParameters*/
					recog.base.set_state(1191);
					recog.typeParameters()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1209);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(151,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1197);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1194);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1199);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule receiverType*/
					recog.base.set_state(1200);
					recog.receiverType()?;

					recog.base.set_state(1204);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1201);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1206);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1207);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			{
			recog.base.set_state(1214);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(152,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1211);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1216);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(152,&mut recog.base)?;
			}
			recog.base.set_state(1219);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LPAREN 
				=> {
					{
					/*InvokeRule multiVariableDeclaration*/
					recog.base.set_state(1217);
					recog.multiVariableDeclaration()?;

					}
				}

			 NL | AT_NO_WS | AT_PRE_WS | FILE | FIELD | PROPERTY | GET | SET | RECEIVER |
			 PARAM | SETPARAM | DELEGATE | IMPORT | CONSTRUCTOR | BY | COMPANION |
			 INIT | WHERE | CATCH | FINALLY | OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED |
			 INTERNAL | ENUM | SEALED | ANNOTATION | DATA | INNER | VALUE | TAILREC |
			 OPERATOR | INLINE | INFIX | EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT |
			 FINAL | OPEN | CONST | LATEINIT | VARARG | NOINLINE | CROSSINLINE | REIFIED |
			 EXPECT | ACTUAL | Identifier 
				=> {
					{
					/*InvokeRule variableDeclaration*/
					recog.base.set_state(1218);
					recog.variableDeclaration()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
			recog.base.set_state(1228);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(155,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1224);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1221);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1226);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeConstraints*/
					recog.base.set_state(1227);
					recog.typeConstraints()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1247);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(159,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1233);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1230);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1235);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1245);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 ASSIGNMENT 
						=> {
							{
							recog.base.set_state(1236);
							recog.base.match_token(ASSIGNMENT,&mut recog.err_handler)?;

							recog.base.set_state(1240);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(1237);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(1242);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							/*InvokeRule expression*/
							recog.base.set_state(1243);
							recog.expression()?;

							}
						}

					 BY 
						=> {
							{
							/*InvokeRule propertyDelegate*/
							recog.base.set_state(1244);
							recog.propertyDelegate()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					}
				}

				_ => {}
			}
			recog.base.set_state(1255);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(161,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1250); 
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					loop {
						{
						{
						recog.base.set_state(1249);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1252); 
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if !(_la==NL) {break}
					}
					recog.base.set_state(1254);
					recog.base.match_token(SEMICOLON,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1260);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(162,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1257);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1262);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(162,&mut recog.base)?;
			}
			recog.base.set_state(1293);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(171,&mut recog.base)? {
				1 =>{
					{
					recog.base.set_state(1264);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(163,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule getter*/
							recog.base.set_state(1263);
							recog.getter()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1276);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(166,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1269);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(164,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(1266);
									recog.base.match_token(NL,&mut recog.err_handler)?;

									}
									} 
								}
								recog.base.set_state(1271);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(164,&mut recog.base)?;
							}
							recog.base.set_state(1273);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if ((((_la - -1)) & !0x3f) == 0 && ((1usize << (_la - -1)) & ((1usize << (EOF - -1)) | (1usize << (NL - -1)) | (1usize << (SEMICOLON - -1)))) != 0) {
								{
								/*InvokeRule semi*/
								recog.base.set_state(1272);
								recog.semi()?;

								}
							}

							/*InvokeRule setter*/
							recog.base.set_state(1275);
							recog.setter()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				2 =>{
					{
					recog.base.set_state(1279);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(167,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule setter*/
							recog.base.set_state(1278);
							recog.setter()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1291);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(170,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1284);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(168,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(1281);
									recog.base.match_token(NL,&mut recog.err_handler)?;

									}
									} 
								}
								recog.base.set_state(1286);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(168,&mut recog.base)?;
							}
							recog.base.set_state(1288);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if ((((_la - -1)) & !0x3f) == 0 && ((1usize << (_la - -1)) & ((1usize << (EOF - -1)) | (1usize << (NL - -1)) | (1usize << (SEMICOLON - -1)))) != 0) {
								{
								/*InvokeRule semi*/
								recog.base.set_state(1287);
								recog.semi()?;

								}
							}

							/*InvokeRule getter*/
							recog.base.set_state(1290);
							recog.getter()?;

							}
						}

						_ => {}
					}
					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- propertyDelegate ----------------
pub type PropertyDelegateContextAll<'input> = PropertyDelegateContext<'input>;


pub type PropertyDelegateContext<'input> = BaseParserRuleContext<'input,PropertyDelegateContextExt<'input>>;

#[derive(Clone)]
pub struct PropertyDelegateContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PropertyDelegateContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PropertyDelegateContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_propertyDelegate(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_propertyDelegate(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PropertyDelegateContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_propertyDelegate(self);
	}
}

impl<'input> CustomRuleContext<'input> for PropertyDelegateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_propertyDelegate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_propertyDelegate }
}
antlr_rust::tid!{PropertyDelegateContextExt<'a>}

impl<'input> PropertyDelegateContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PropertyDelegateContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PropertyDelegateContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PropertyDelegateContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PropertyDelegateContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token BY
/// Returns `None` if there is no child corresponding to token BY
fn BY(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(BY, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> PropertyDelegateContextAttrs<'input> for PropertyDelegateContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn propertyDelegate(&mut self,)
	-> Result<Rc<PropertyDelegateContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PropertyDelegateContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 72, RULE_propertyDelegate);
        let mut _localctx: Rc<PropertyDelegateContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1295);
			recog.base.match_token(BY,&mut recog.err_handler)?;

			recog.base.set_state(1299);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1296);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1301);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule expression*/
			recog.base.set_state(1302);
			recog.expression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- getter ----------------
pub type GetterContextAll<'input> = GetterContext<'input>;


pub type GetterContext<'input> = BaseParserRuleContext<'input,GetterContextExt<'input>>;

#[derive(Clone)]
pub struct GetterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for GetterContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for GetterContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_getter(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_getter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for GetterContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_getter(self);
	}
}

impl<'input> CustomRuleContext<'input> for GetterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_getter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_getter }
}
antlr_rust::tid!{GetterContextExt<'a>}

impl<'input> GetterContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<GetterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,GetterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait GetterContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<GetterContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token GET
/// Returns `None` if there is no child corresponding to token GET
fn GET(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(GET, 0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn functionBody(&self) -> Option<Rc<FunctionBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn rustType(&self) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> GetterContextAttrs<'input> for GetterContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn getter(&mut self,)
	-> Result<Rc<GetterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = GetterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 74, RULE_getter);
        let mut _localctx: Rc<GetterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1305);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 107)) & !0x3f) == 0 && ((1usize << (_la - 107)) & ((1usize << (PUBLIC - 107)) | (1usize << (PRIVATE - 107)) | (1usize << (PROTECTED - 107)) | (1usize << (INTERNAL - 107)) | (1usize << (ENUM - 107)) | (1usize << (SEALED - 107)) | (1usize << (ANNOTATION - 107)) | (1usize << (DATA - 107)) | (1usize << (INNER - 107)) | (1usize << (VALUE - 107)) | (1usize << (TAILREC - 107)) | (1usize << (OPERATOR - 107)) | (1usize << (INLINE - 107)) | (1usize << (INFIX - 107)) | (1usize << (EXTERNAL - 107)) | (1usize << (SUSPEND - 107)) | (1usize << (OVERRIDE - 107)) | (1usize << (ABSTRACT - 107)) | (1usize << (FINAL - 107)) | (1usize << (OPEN - 107)) | (1usize << (CONST - 107)) | (1usize << (LATEINIT - 107)) | (1usize << (VARARG - 107)) | (1usize << (NOINLINE - 107)) | (1usize << (CROSSINLINE - 107)) | (1usize << (EXPECT - 107)) | (1usize << (ACTUAL - 107)))) != 0) {
				{
				/*InvokeRule modifiers*/
				recog.base.set_state(1304);
				recog.modifiers()?;

				}
			}

			recog.base.set_state(1307);
			recog.base.match_token(GET,&mut recog.err_handler)?;

			recog.base.set_state(1345);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(180,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1311);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1308);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1313);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1314);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1318);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1315);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1320);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1321);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1336);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(178,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1325);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(1322);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(1327);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(1328);
							recog.base.match_token(COLON,&mut recog.err_handler)?;

							recog.base.set_state(1332);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(1329);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(1334);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							/*InvokeRule rustType*/
							recog.base.set_state(1335);
							recog.rustType()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1341);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1338);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1343);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule functionBody*/
					recog.base.set_state(1344);
					recog.functionBody()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- setter ----------------
pub type SetterContextAll<'input> = SetterContext<'input>;


pub type SetterContext<'input> = BaseParserRuleContext<'input,SetterContextExt<'input>>;

#[derive(Clone)]
pub struct SetterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for SetterContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for SetterContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_setter(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_setter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for SetterContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_setter(self);
	}
}

impl<'input> CustomRuleContext<'input> for SetterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_setter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_setter }
}
antlr_rust::tid!{SetterContextExt<'a>}

impl<'input> SetterContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SetterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SetterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SetterContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<SetterContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SET
/// Returns `None` if there is no child corresponding to token SET
fn SET(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SET, 0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn functionValueParameterWithOptionalType(&self) -> Option<Rc<FunctionValueParameterWithOptionalTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn functionBody(&self) -> Option<Rc<FunctionBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn rustType(&self) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SetterContextAttrs<'input> for SetterContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn setter(&mut self,)
	-> Result<Rc<SetterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SetterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 76, RULE_setter);
        let mut _localctx: Rc<SetterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1348);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 107)) & !0x3f) == 0 && ((1usize << (_la - 107)) & ((1usize << (PUBLIC - 107)) | (1usize << (PRIVATE - 107)) | (1usize << (PROTECTED - 107)) | (1usize << (INTERNAL - 107)) | (1usize << (ENUM - 107)) | (1usize << (SEALED - 107)) | (1usize << (ANNOTATION - 107)) | (1usize << (DATA - 107)) | (1usize << (INNER - 107)) | (1usize << (VALUE - 107)) | (1usize << (TAILREC - 107)) | (1usize << (OPERATOR - 107)) | (1usize << (INLINE - 107)) | (1usize << (INFIX - 107)) | (1usize << (EXTERNAL - 107)) | (1usize << (SUSPEND - 107)) | (1usize << (OVERRIDE - 107)) | (1usize << (ABSTRACT - 107)) | (1usize << (FINAL - 107)) | (1usize << (OPEN - 107)) | (1usize << (CONST - 107)) | (1usize << (LATEINIT - 107)) | (1usize << (VARARG - 107)) | (1usize << (NOINLINE - 107)) | (1usize << (CROSSINLINE - 107)) | (1usize << (EXPECT - 107)) | (1usize << (ACTUAL - 107)))) != 0) {
				{
				/*InvokeRule modifiers*/
				recog.base.set_state(1347);
				recog.modifiers()?;

				}
			}

			recog.base.set_state(1350);
			recog.base.match_token(SET,&mut recog.err_handler)?;

			recog.base.set_state(1405);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(191,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1354);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1351);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1356);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1357);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1361);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1358);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1363);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule functionValueParameterWithOptionalType*/
					recog.base.set_state(1364);
					recog.functionValueParameterWithOptionalType()?;

					recog.base.set_state(1372);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(185,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1368);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(1365);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(1370);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(1371);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1377);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1374);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1379);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1380);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1395);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(189,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1384);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(1381);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(1386);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(1387);
							recog.base.match_token(COLON,&mut recog.err_handler)?;

							recog.base.set_state(1391);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(1388);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(1393);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							/*InvokeRule rustType*/
							recog.base.set_state(1394);
							recog.rustType()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1400);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1397);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1402);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule functionBody*/
					recog.base.set_state(1403);
					recog.functionBody()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parametersWithOptionalType ----------------
pub type ParametersWithOptionalTypeContextAll<'input> = ParametersWithOptionalTypeContext<'input>;


pub type ParametersWithOptionalTypeContext<'input> = BaseParserRuleContext<'input,ParametersWithOptionalTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ParametersWithOptionalTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParametersWithOptionalTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParametersWithOptionalTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_parametersWithOptionalType(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_parametersWithOptionalType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParametersWithOptionalTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parametersWithOptionalType(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParametersWithOptionalTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parametersWithOptionalType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parametersWithOptionalType }
}
antlr_rust::tid!{ParametersWithOptionalTypeContextExt<'a>}

impl<'input> ParametersWithOptionalTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParametersWithOptionalTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParametersWithOptionalTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParametersWithOptionalTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParametersWithOptionalTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn functionValueParameterWithOptionalType_all(&self) ->  Vec<Rc<FunctionValueParameterWithOptionalTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn functionValueParameterWithOptionalType(&self, i: usize) -> Option<Rc<FunctionValueParameterWithOptionalTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> ParametersWithOptionalTypeContextAttrs<'input> for ParametersWithOptionalTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parametersWithOptionalType(&mut self,)
	-> Result<Rc<ParametersWithOptionalTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParametersWithOptionalTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 78, RULE_parametersWithOptionalType);
        let mut _localctx: Rc<ParametersWithOptionalTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1407);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1411);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(192,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1408);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1413);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(192,&mut recog.base)?;
			}
			recog.base.set_state(1443);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if ((((_la - 40)) & !0x3f) == 0 && ((1usize << (_la - 40)) & ((1usize << (AT_NO_WS - 40)) | (1usize << (AT_PRE_WS - 40)) | (1usize << (FILE - 40)) | (1usize << (FIELD - 40)) | (1usize << (PROPERTY - 40)) | (1usize << (GET - 40)) | (1usize << (SET - 40)) | (1usize << (RECEIVER - 40)) | (1usize << (PARAM - 40)) | (1usize << (SETPARAM - 40)) | (1usize << (DELEGATE - 40)) | (1usize << (IMPORT - 40)) | (1usize << (CONSTRUCTOR - 40)) | (1usize << (BY - 40)) | (1usize << (COMPANION - 40)) | (1usize << (INIT - 40)) | (1usize << (WHERE - 40)) | (1usize << (CATCH - 40)) | (1usize << (FINALLY - 40)))) != 0) || ((((_la - 105)) & !0x3f) == 0 && ((1usize << (_la - 105)) & ((1usize << (OUT - 105)) | (1usize << (DYNAMIC - 105)) | (1usize << (PUBLIC - 105)) | (1usize << (PRIVATE - 105)) | (1usize << (PROTECTED - 105)) | (1usize << (INTERNAL - 105)) | (1usize << (ENUM - 105)) | (1usize << (SEALED - 105)) | (1usize << (ANNOTATION - 105)) | (1usize << (DATA - 105)) | (1usize << (INNER - 105)) | (1usize << (VALUE - 105)) | (1usize << (TAILREC - 105)) | (1usize << (OPERATOR - 105)) | (1usize << (INLINE - 105)) | (1usize << (INFIX - 105)) | (1usize << (EXTERNAL - 105)) | (1usize << (SUSPEND - 105)) | (1usize << (OVERRIDE - 105)) | (1usize << (ABSTRACT - 105)) | (1usize << (FINAL - 105)) | (1usize << (OPEN - 105)) | (1usize << (CONST - 105)) | (1usize << (LATEINIT - 105)) | (1usize << (VARARG - 105)) | (1usize << (NOINLINE - 105)) | (1usize << (CROSSINLINE - 105)) | (1usize << (REIFIED - 105)) | (1usize << (EXPECT - 105)) | (1usize << (ACTUAL - 105)) | (1usize << (Identifier - 105)))) != 0) {
				{
				/*InvokeRule functionValueParameterWithOptionalType*/
				recog.base.set_state(1414);
				recog.functionValueParameterWithOptionalType()?;

				recog.base.set_state(1431);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(195,&mut recog.base)?;
				while { _alt!=2 && _alt!=INVALID_ALT } {
					if _alt==1 {
						{
						{
						recog.base.set_state(1418);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(1415);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(1420);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(1421);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						recog.base.set_state(1425);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(1422);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(1427);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						/*InvokeRule functionValueParameterWithOptionalType*/
						recog.base.set_state(1428);
						recog.functionValueParameterWithOptionalType()?;

						}
						} 
					}
					recog.base.set_state(1433);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(195,&mut recog.base)?;
				}
				recog.base.set_state(1441);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(197,&mut recog.base)? {
					x if x == 1=>{
						{
						recog.base.set_state(1437);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(1434);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(1439);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(1440);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						}
					}

					_ => {}
				}
				}
			}

			recog.base.set_state(1448);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1445);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1450);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1451);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionValueParameterWithOptionalType ----------------
pub type FunctionValueParameterWithOptionalTypeContextAll<'input> = FunctionValueParameterWithOptionalTypeContext<'input>;


pub type FunctionValueParameterWithOptionalTypeContext<'input> = BaseParserRuleContext<'input,FunctionValueParameterWithOptionalTypeContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionValueParameterWithOptionalTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FunctionValueParameterWithOptionalTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FunctionValueParameterWithOptionalTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_functionValueParameterWithOptionalType(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_functionValueParameterWithOptionalType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FunctionValueParameterWithOptionalTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_functionValueParameterWithOptionalType(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionValueParameterWithOptionalTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionValueParameterWithOptionalType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionValueParameterWithOptionalType }
}
antlr_rust::tid!{FunctionValueParameterWithOptionalTypeContextExt<'a>}

impl<'input> FunctionValueParameterWithOptionalTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionValueParameterWithOptionalTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionValueParameterWithOptionalTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionValueParameterWithOptionalTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FunctionValueParameterWithOptionalTypeContextExt<'input>>{

fn parameterWithOptionalType(&self) -> Option<Rc<ParameterWithOptionalTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parameterModifiers(&self) -> Option<Rc<ParameterModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ASSIGNMENT
fn ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ASSIGNMENT, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> FunctionValueParameterWithOptionalTypeContextAttrs<'input> for FunctionValueParameterWithOptionalTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionValueParameterWithOptionalType(&mut self,)
	-> Result<Rc<FunctionValueParameterWithOptionalTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionValueParameterWithOptionalTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 80, RULE_functionValueParameterWithOptionalType);
        let mut _localctx: Rc<FunctionValueParameterWithOptionalTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1454);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(200,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule parameterModifiers*/
					recog.base.set_state(1453);
					recog.parameterModifiers()?;

					}
				}

				_ => {}
			}
			/*InvokeRule parameterWithOptionalType*/
			recog.base.set_state(1456);
			recog.parameterWithOptionalType()?;

			recog.base.set_state(1471);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(203,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1460);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1457);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1462);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1463);
					recog.base.match_token(ASSIGNMENT,&mut recog.err_handler)?;

					recog.base.set_state(1467);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1464);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1469);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule expression*/
					recog.base.set_state(1470);
					recog.expression()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parameterWithOptionalType ----------------
pub type ParameterWithOptionalTypeContextAll<'input> = ParameterWithOptionalTypeContext<'input>;


pub type ParameterWithOptionalTypeContext<'input> = BaseParserRuleContext<'input,ParameterWithOptionalTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ParameterWithOptionalTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParameterWithOptionalTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParameterWithOptionalTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_parameterWithOptionalType(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_parameterWithOptionalType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParameterWithOptionalTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parameterWithOptionalType(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParameterWithOptionalTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parameterWithOptionalType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parameterWithOptionalType }
}
antlr_rust::tid!{ParameterWithOptionalTypeContextExt<'a>}

impl<'input> ParameterWithOptionalTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParameterWithOptionalTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParameterWithOptionalTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParameterWithOptionalTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParameterWithOptionalTypeContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn rustType(&self) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ParameterWithOptionalTypeContextAttrs<'input> for ParameterWithOptionalTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parameterWithOptionalType(&mut self,)
	-> Result<Rc<ParameterWithOptionalTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParameterWithOptionalTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 82, RULE_parameterWithOptionalType);
        let mut _localctx: Rc<ParameterWithOptionalTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(1473);
			recog.simpleIdentifier()?;

			recog.base.set_state(1477);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(204,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1474);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1479);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(204,&mut recog.base)?;
			}
			recog.base.set_state(1488);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COLON {
				{
				recog.base.set_state(1480);
				recog.base.match_token(COLON,&mut recog.err_handler)?;

				recog.base.set_state(1484);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				while _la==NL {
					{
					{
					recog.base.set_state(1481);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					}
					recog.base.set_state(1486);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
				}
				/*InvokeRule rustType*/
				recog.base.set_state(1487);
				recog.rustType()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parameter ----------------
pub type ParameterContextAll<'input> = ParameterContext<'input>;


pub type ParameterContext<'input> = BaseParserRuleContext<'input,ParameterContextExt<'input>>;

#[derive(Clone)]
pub struct ParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParameterContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_parameter(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_parameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParameterContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parameter(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parameter }
}
antlr_rust::tid!{ParameterContextExt<'a>}

impl<'input> ParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParameterContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParameterContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn rustType(&self) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ParameterContextAttrs<'input> for ParameterContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parameter(&mut self,)
	-> Result<Rc<ParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 84, RULE_parameter);
        let mut _localctx: Rc<ParameterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(1490);
			recog.simpleIdentifier()?;

			recog.base.set_state(1494);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1491);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1496);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1497);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			recog.base.set_state(1501);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1498);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1503);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule rustType*/
			recog.base.set_state(1504);
			recog.rustType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- objectDeclaration ----------------
pub type ObjectDeclarationContextAll<'input> = ObjectDeclarationContext<'input>;


pub type ObjectDeclarationContext<'input> = BaseParserRuleContext<'input,ObjectDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct ObjectDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ObjectDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ObjectDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_objectDeclaration(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_objectDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ObjectDeclarationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_objectDeclaration(self);
	}
}

impl<'input> CustomRuleContext<'input> for ObjectDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_objectDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_objectDeclaration }
}
antlr_rust::tid!{ObjectDeclarationContextExt<'a>}

impl<'input> ObjectDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ObjectDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ObjectDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ObjectDeclarationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ObjectDeclarationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT
/// Returns `None` if there is no child corresponding to token OBJECT
fn OBJECT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OBJECT, 0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn delegationSpecifiers(&self) -> Option<Rc<DelegationSpecifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classBody(&self) -> Option<Rc<ClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ObjectDeclarationContextAttrs<'input> for ObjectDeclarationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn objectDeclaration(&mut self,)
	-> Result<Rc<ObjectDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ObjectDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 86, RULE_objectDeclaration);
        let mut _localctx: Rc<ObjectDeclarationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1507);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 107)) & !0x3f) == 0 && ((1usize << (_la - 107)) & ((1usize << (PUBLIC - 107)) | (1usize << (PRIVATE - 107)) | (1usize << (PROTECTED - 107)) | (1usize << (INTERNAL - 107)) | (1usize << (ENUM - 107)) | (1usize << (SEALED - 107)) | (1usize << (ANNOTATION - 107)) | (1usize << (DATA - 107)) | (1usize << (INNER - 107)) | (1usize << (VALUE - 107)) | (1usize << (TAILREC - 107)) | (1usize << (OPERATOR - 107)) | (1usize << (INLINE - 107)) | (1usize << (INFIX - 107)) | (1usize << (EXTERNAL - 107)) | (1usize << (SUSPEND - 107)) | (1usize << (OVERRIDE - 107)) | (1usize << (ABSTRACT - 107)) | (1usize << (FINAL - 107)) | (1usize << (OPEN - 107)) | (1usize << (CONST - 107)) | (1usize << (LATEINIT - 107)) | (1usize << (VARARG - 107)) | (1usize << (NOINLINE - 107)) | (1usize << (CROSSINLINE - 107)) | (1usize << (EXPECT - 107)) | (1usize << (ACTUAL - 107)))) != 0) {
				{
				/*InvokeRule modifiers*/
				recog.base.set_state(1506);
				recog.modifiers()?;

				}
			}

			recog.base.set_state(1509);
			recog.base.match_token(OBJECT,&mut recog.err_handler)?;

			recog.base.set_state(1513);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1510);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1515);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(1516);
			recog.simpleIdentifier()?;

			recog.base.set_state(1531);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(213,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1520);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1517);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1522);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1523);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(1527);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(212,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(1524);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(1529);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(212,&mut recog.base)?;
					}
					/*InvokeRule delegationSpecifiers*/
					recog.base.set_state(1530);
					recog.delegationSpecifiers()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1540);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(215,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1536);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1533);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1538);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule classBody*/
					recog.base.set_state(1539);
					recog.classBody()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- secondaryConstructor ----------------
pub type SecondaryConstructorContextAll<'input> = SecondaryConstructorContext<'input>;


pub type SecondaryConstructorContext<'input> = BaseParserRuleContext<'input,SecondaryConstructorContextExt<'input>>;

#[derive(Clone)]
pub struct SecondaryConstructorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for SecondaryConstructorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for SecondaryConstructorContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_secondaryConstructor(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_secondaryConstructor(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for SecondaryConstructorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_secondaryConstructor(self);
	}
}

impl<'input> CustomRuleContext<'input> for SecondaryConstructorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_secondaryConstructor }
	//fn type_rule_index() -> usize where Self: Sized { RULE_secondaryConstructor }
}
antlr_rust::tid!{SecondaryConstructorContextExt<'a>}

impl<'input> SecondaryConstructorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SecondaryConstructorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SecondaryConstructorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SecondaryConstructorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<SecondaryConstructorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CONSTRUCTOR
/// Returns `None` if there is no child corresponding to token CONSTRUCTOR
fn CONSTRUCTOR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CONSTRUCTOR, 0)
}
fn functionValueParameters(&self) -> Option<Rc<FunctionValueParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn constructorDelegationCall(&self) -> Option<Rc<ConstructorDelegationCallContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SecondaryConstructorContextAttrs<'input> for SecondaryConstructorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn secondaryConstructor(&mut self,)
	-> Result<Rc<SecondaryConstructorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SecondaryConstructorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 88, RULE_secondaryConstructor);
        let mut _localctx: Rc<SecondaryConstructorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1543);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AT_NO_WS || _la==AT_PRE_WS || ((((_la - 107)) & !0x3f) == 0 && ((1usize << (_la - 107)) & ((1usize << (PUBLIC - 107)) | (1usize << (PRIVATE - 107)) | (1usize << (PROTECTED - 107)) | (1usize << (INTERNAL - 107)) | (1usize << (ENUM - 107)) | (1usize << (SEALED - 107)) | (1usize << (ANNOTATION - 107)) | (1usize << (DATA - 107)) | (1usize << (INNER - 107)) | (1usize << (VALUE - 107)) | (1usize << (TAILREC - 107)) | (1usize << (OPERATOR - 107)) | (1usize << (INLINE - 107)) | (1usize << (INFIX - 107)) | (1usize << (EXTERNAL - 107)) | (1usize << (SUSPEND - 107)) | (1usize << (OVERRIDE - 107)) | (1usize << (ABSTRACT - 107)) | (1usize << (FINAL - 107)) | (1usize << (OPEN - 107)) | (1usize << (CONST - 107)) | (1usize << (LATEINIT - 107)) | (1usize << (VARARG - 107)) | (1usize << (NOINLINE - 107)) | (1usize << (CROSSINLINE - 107)) | (1usize << (EXPECT - 107)) | (1usize << (ACTUAL - 107)))) != 0) {
				{
				/*InvokeRule modifiers*/
				recog.base.set_state(1542);
				recog.modifiers()?;

				}
			}

			recog.base.set_state(1545);
			recog.base.match_token(CONSTRUCTOR,&mut recog.err_handler)?;

			recog.base.set_state(1549);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1546);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1551);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule functionValueParameters*/
			recog.base.set_state(1552);
			recog.functionValueParameters()?;

			recog.base.set_state(1567);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(220,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1556);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1553);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1558);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1559);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(1563);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1560);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1565);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule constructorDelegationCall*/
					recog.base.set_state(1566);
					recog.constructorDelegationCall()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1572);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(221,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1569);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1574);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(221,&mut recog.base)?;
			}
			recog.base.set_state(1576);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LCURL {
				{
				/*InvokeRule block*/
				recog.base.set_state(1575);
				recog.block()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constructorDelegationCall ----------------
pub type ConstructorDelegationCallContextAll<'input> = ConstructorDelegationCallContext<'input>;


pub type ConstructorDelegationCallContext<'input> = BaseParserRuleContext<'input,ConstructorDelegationCallContextExt<'input>>;

#[derive(Clone)]
pub struct ConstructorDelegationCallContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ConstructorDelegationCallContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ConstructorDelegationCallContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constructorDelegationCall(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_constructorDelegationCall(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ConstructorDelegationCallContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_constructorDelegationCall(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConstructorDelegationCallContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constructorDelegationCall }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constructorDelegationCall }
}
antlr_rust::tid!{ConstructorDelegationCallContextExt<'a>}

impl<'input> ConstructorDelegationCallContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstructorDelegationCallContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstructorDelegationCallContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstructorDelegationCallContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ConstructorDelegationCallContextExt<'input>>{

fn valueArguments(&self) -> Option<Rc<ValueArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token THIS
/// Returns `None` if there is no child corresponding to token THIS
fn THIS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(THIS, 0)
}
/// Retrieves first TerminalNode corresponding to token SUPER
/// Returns `None` if there is no child corresponding to token SUPER
fn SUPER(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUPER, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ConstructorDelegationCallContextAttrs<'input> for ConstructorDelegationCallContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constructorDelegationCall(&mut self,)
	-> Result<Rc<ConstructorDelegationCallContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstructorDelegationCallContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 90, RULE_constructorDelegationCall);
        let mut _localctx: Rc<ConstructorDelegationCallContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1578);
			_la = recog.base.input.la(1);
			if { !(_la==THIS || _la==SUPER) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			recog.base.set_state(1582);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1579);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1584);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule valueArguments*/
			recog.base.set_state(1585);
			recog.valueArguments()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumClassBody ----------------
pub type EnumClassBodyContextAll<'input> = EnumClassBodyContext<'input>;


pub type EnumClassBodyContext<'input> = BaseParserRuleContext<'input,EnumClassBodyContextExt<'input>>;

#[derive(Clone)]
pub struct EnumClassBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for EnumClassBodyContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for EnumClassBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumClassBody(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_enumClassBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for EnumClassBodyContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_enumClassBody(self);
	}
}

impl<'input> CustomRuleContext<'input> for EnumClassBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumClassBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumClassBody }
}
antlr_rust::tid!{EnumClassBodyContextExt<'a>}

impl<'input> EnumClassBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumClassBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumClassBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumClassBodyContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<EnumClassBodyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LCURL
/// Returns `None` if there is no child corresponding to token LCURL
fn LCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LCURL, 0)
}
/// Retrieves first TerminalNode corresponding to token RCURL
/// Returns `None` if there is no child corresponding to token RCURL
fn RCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RCURL, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn enumEntries(&self) -> Option<Rc<EnumEntriesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMICOLON
/// Returns `None` if there is no child corresponding to token SEMICOLON
fn SEMICOLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SEMICOLON, 0)
}
fn classMemberDeclarations(&self) -> Option<Rc<ClassMemberDeclarationsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> EnumClassBodyContextAttrs<'input> for EnumClassBodyContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumClassBody(&mut self,)
	-> Result<Rc<EnumClassBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumClassBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 92, RULE_enumClassBody);
        let mut _localctx: Rc<EnumClassBodyContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1587);
			recog.base.match_token(LCURL,&mut recog.err_handler)?;

			recog.base.set_state(1591);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(224,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1588);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1593);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(224,&mut recog.base)?;
			}
			recog.base.set_state(1595);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if ((((_la - 40)) & !0x3f) == 0 && ((1usize << (_la - 40)) & ((1usize << (AT_NO_WS - 40)) | (1usize << (AT_PRE_WS - 40)) | (1usize << (FILE - 40)) | (1usize << (FIELD - 40)) | (1usize << (PROPERTY - 40)) | (1usize << (GET - 40)) | (1usize << (SET - 40)) | (1usize << (RECEIVER - 40)) | (1usize << (PARAM - 40)) | (1usize << (SETPARAM - 40)) | (1usize << (DELEGATE - 40)) | (1usize << (IMPORT - 40)) | (1usize << (CONSTRUCTOR - 40)) | (1usize << (BY - 40)) | (1usize << (COMPANION - 40)) | (1usize << (INIT - 40)) | (1usize << (WHERE - 40)) | (1usize << (CATCH - 40)) | (1usize << (FINALLY - 40)))) != 0) || ((((_la - 105)) & !0x3f) == 0 && ((1usize << (_la - 105)) & ((1usize << (OUT - 105)) | (1usize << (DYNAMIC - 105)) | (1usize << (PUBLIC - 105)) | (1usize << (PRIVATE - 105)) | (1usize << (PROTECTED - 105)) | (1usize << (INTERNAL - 105)) | (1usize << (ENUM - 105)) | (1usize << (SEALED - 105)) | (1usize << (ANNOTATION - 105)) | (1usize << (DATA - 105)) | (1usize << (INNER - 105)) | (1usize << (VALUE - 105)) | (1usize << (TAILREC - 105)) | (1usize << (OPERATOR - 105)) | (1usize << (INLINE - 105)) | (1usize << (INFIX - 105)) | (1usize << (EXTERNAL - 105)) | (1usize << (SUSPEND - 105)) | (1usize << (OVERRIDE - 105)) | (1usize << (ABSTRACT - 105)) | (1usize << (FINAL - 105)) | (1usize << (OPEN - 105)) | (1usize << (CONST - 105)) | (1usize << (LATEINIT - 105)) | (1usize << (VARARG - 105)) | (1usize << (NOINLINE - 105)) | (1usize << (CROSSINLINE - 105)) | (1usize << (REIFIED - 105)) | (1usize << (EXPECT - 105)) | (1usize << (ACTUAL - 105)) | (1usize << (Identifier - 105)))) != 0) {
				{
				/*InvokeRule enumEntries*/
				recog.base.set_state(1594);
				recog.enumEntries()?;

				}
			}

			recog.base.set_state(1611);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(228,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1600);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1597);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1602);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1603);
					recog.base.match_token(SEMICOLON,&mut recog.err_handler)?;

					recog.base.set_state(1607);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(227,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(1604);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(1609);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(227,&mut recog.base)?;
					}
					/*InvokeRule classMemberDeclarations*/
					recog.base.set_state(1610);
					recog.classMemberDeclarations()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1616);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1613);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1618);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1619);
			recog.base.match_token(RCURL,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumEntries ----------------
pub type EnumEntriesContextAll<'input> = EnumEntriesContext<'input>;


pub type EnumEntriesContext<'input> = BaseParserRuleContext<'input,EnumEntriesContextExt<'input>>;

#[derive(Clone)]
pub struct EnumEntriesContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for EnumEntriesContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for EnumEntriesContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumEntries(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_enumEntries(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for EnumEntriesContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_enumEntries(self);
	}
}

impl<'input> CustomRuleContext<'input> for EnumEntriesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumEntries }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumEntries }
}
antlr_rust::tid!{EnumEntriesContextExt<'a>}

impl<'input> EnumEntriesContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumEntriesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumEntriesContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumEntriesContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<EnumEntriesContextExt<'input>>{

fn enumEntry_all(&self) ->  Vec<Rc<EnumEntryContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn enumEntry(&self, i: usize) -> Option<Rc<EnumEntryContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> EnumEntriesContextAttrs<'input> for EnumEntriesContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumEntries(&mut self,)
	-> Result<Rc<EnumEntriesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumEntriesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 94, RULE_enumEntries);
        let mut _localctx: Rc<EnumEntriesContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule enumEntry*/
			recog.base.set_state(1621);
			recog.enumEntry()?;

			recog.base.set_state(1638);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(232,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1625);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1622);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1627);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1628);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(1632);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1629);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1634);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule enumEntry*/
					recog.base.set_state(1635);
					recog.enumEntry()?;

					}
					} 
				}
				recog.base.set_state(1640);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(232,&mut recog.base)?;
			}
			recog.base.set_state(1644);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(233,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1641);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1646);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(233,&mut recog.base)?;
			}
			recog.base.set_state(1648);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				recog.base.set_state(1647);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- enumEntry ----------------
pub type EnumEntryContextAll<'input> = EnumEntryContext<'input>;


pub type EnumEntryContext<'input> = BaseParserRuleContext<'input,EnumEntryContextExt<'input>>;

#[derive(Clone)]
pub struct EnumEntryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for EnumEntryContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for EnumEntryContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_enumEntry(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_enumEntry(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for EnumEntryContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_enumEntry(self);
	}
}

impl<'input> CustomRuleContext<'input> for EnumEntryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_enumEntry }
	//fn type_rule_index() -> usize where Self: Sized { RULE_enumEntry }
}
antlr_rust::tid!{EnumEntryContextExt<'a>}

impl<'input> EnumEntryContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EnumEntryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EnumEntryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EnumEntryContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<EnumEntryContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn modifiers(&self) -> Option<Rc<ModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn valueArguments(&self) -> Option<Rc<ValueArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classBody(&self) -> Option<Rc<ClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> EnumEntryContextAttrs<'input> for EnumEntryContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn enumEntry(&mut self,)
	-> Result<Rc<EnumEntryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EnumEntryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 96, RULE_enumEntry);
        let mut _localctx: Rc<EnumEntryContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1657);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(236,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule modifiers*/
					recog.base.set_state(1650);
					recog.modifiers()?;

					recog.base.set_state(1654);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1651);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1656);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

				_ => {}
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(1659);
			recog.simpleIdentifier()?;

			recog.base.set_state(1667);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(238,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1663);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1660);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1665);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule valueArguments*/
					recog.base.set_state(1666);
					recog.valueArguments()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1676);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(240,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1672);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1669);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1674);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule classBody*/
					recog.base.set_state(1675);
					recog.classBody()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- rustType ----------------
pub type RustTypeContextAll<'input> = RustTypeContext<'input>;


pub type RustTypeContext<'input> = BaseParserRuleContext<'input,RustTypeContextExt<'input>>;

#[derive(Clone)]
pub struct RustTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for RustTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for RustTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_rustType(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_rustType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for RustTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_rustType(self);
	}
}

impl<'input> CustomRuleContext<'input> for RustTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_rustType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_rustType }
}
antlr_rust::tid!{RustTypeContextExt<'a>}

impl<'input> RustTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RustTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RustTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RustTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<RustTypeContextExt<'input>>{

fn parenthesizedType(&self) -> Option<Rc<ParenthesizedTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn nullableType(&self) -> Option<Rc<NullableTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeReference(&self) -> Option<Rc<TypeReferenceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionType(&self) -> Option<Rc<FunctionTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeModifiers(&self) -> Option<Rc<TypeModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RustTypeContextAttrs<'input> for RustTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn rustType(&mut self,)
	-> Result<Rc<RustTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RustTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 98, RULE_rustType);
        let mut _localctx: Rc<RustTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1679);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(241,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule typeModifiers*/
					recog.base.set_state(1678);
					recog.typeModifiers()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1685);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(242,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule parenthesizedType*/
					recog.base.set_state(1681);
					recog.parenthesizedType()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule nullableType*/
					recog.base.set_state(1682);
					recog.nullableType()?;

					}
				}
			,
				3 =>{
					{
					/*InvokeRule typeReference*/
					recog.base.set_state(1683);
					recog.typeReference()?;

					}
				}
			,
				4 =>{
					{
					/*InvokeRule functionType*/
					recog.base.set_state(1684);
					recog.functionType()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeReference ----------------
pub type TypeReferenceContextAll<'input> = TypeReferenceContext<'input>;


pub type TypeReferenceContext<'input> = BaseParserRuleContext<'input,TypeReferenceContextExt<'input>>;

#[derive(Clone)]
pub struct TypeReferenceContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeReferenceContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeReferenceContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeReference(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_typeReference(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeReferenceContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeReference(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeReferenceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeReference }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeReference }
}
antlr_rust::tid!{TypeReferenceContextExt<'a>}

impl<'input> TypeReferenceContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeReferenceContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeReferenceContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeReferenceContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeReferenceContextExt<'input>>{

fn userType(&self) -> Option<Rc<UserTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DYNAMIC
/// Returns `None` if there is no child corresponding to token DYNAMIC
fn DYNAMIC(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DYNAMIC, 0)
}

}

impl<'input> TypeReferenceContextAttrs<'input> for TypeReferenceContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeReference(&mut self,)
	-> Result<Rc<TypeReferenceContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeReferenceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 100, RULE_typeReference);
        let mut _localctx: Rc<TypeReferenceContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1689);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(243,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule userType*/
					recog.base.set_state(1687);
					recog.userType()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1688);
					recog.base.match_token(DYNAMIC,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- nullableType ----------------
pub type NullableTypeContextAll<'input> = NullableTypeContext<'input>;


pub type NullableTypeContext<'input> = BaseParserRuleContext<'input,NullableTypeContextExt<'input>>;

#[derive(Clone)]
pub struct NullableTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for NullableTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for NullableTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_nullableType(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_nullableType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for NullableTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_nullableType(self);
	}
}

impl<'input> CustomRuleContext<'input> for NullableTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nullableType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nullableType }
}
antlr_rust::tid!{NullableTypeContextExt<'a>}

impl<'input> NullableTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NullableTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NullableTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NullableTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<NullableTypeContextExt<'input>>{

fn typeReference(&self) -> Option<Rc<TypeReferenceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parenthesizedType(&self) -> Option<Rc<ParenthesizedTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn quest_all(&self) ->  Vec<Rc<QuestContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn quest(&self, i: usize) -> Option<Rc<QuestContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> NullableTypeContextAttrs<'input> for NullableTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn nullableType(&mut self,)
	-> Result<Rc<NullableTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NullableTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 102, RULE_nullableType);
        let mut _localctx: Rc<NullableTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1693);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 FILE | FIELD | PROPERTY | GET | SET | RECEIVER | PARAM | SETPARAM | DELEGATE |
			 IMPORT | CONSTRUCTOR | BY | COMPANION | INIT | WHERE | CATCH | FINALLY |
			 OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED |
			 ANNOTATION | DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX |
			 EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT |
			 VARARG | NOINLINE | CROSSINLINE | REIFIED | EXPECT | ACTUAL | Identifier 
				=> {
					{
					/*InvokeRule typeReference*/
					recog.base.set_state(1691);
					recog.typeReference()?;

					}
				}

			 LPAREN 
				=> {
					{
					/*InvokeRule parenthesizedType*/
					recog.base.set_state(1692);
					recog.parenthesizedType()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(1698);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1695);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1700);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1702); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					{
					/*InvokeRule quest*/
					recog.base.set_state(1701);
					recog.quest()?;

					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(1704); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(246,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- quest ----------------
pub type QuestContextAll<'input> = QuestContext<'input>;


pub type QuestContext<'input> = BaseParserRuleContext<'input,QuestContextExt<'input>>;

#[derive(Clone)]
pub struct QuestContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for QuestContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for QuestContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_quest(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_quest(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for QuestContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_quest(self);
	}
}

impl<'input> CustomRuleContext<'input> for QuestContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_quest }
	//fn type_rule_index() -> usize where Self: Sized { RULE_quest }
}
antlr_rust::tid!{QuestContextExt<'a>}

impl<'input> QuestContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<QuestContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,QuestContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait QuestContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<QuestContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token QUEST_NO_WS
/// Returns `None` if there is no child corresponding to token QUEST_NO_WS
fn QUEST_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(QUEST_NO_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token QUEST_WS
/// Returns `None` if there is no child corresponding to token QUEST_WS
fn QUEST_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(QUEST_WS, 0)
}

}

impl<'input> QuestContextAttrs<'input> for QuestContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn quest(&mut self,)
	-> Result<Rc<QuestContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = QuestContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 104, RULE_quest);
        let mut _localctx: Rc<QuestContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1706);
			_la = recog.base.input.la(1);
			if { !(_la==QUEST_WS || _la==QUEST_NO_WS) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- userType ----------------
pub type UserTypeContextAll<'input> = UserTypeContext<'input>;


pub type UserTypeContext<'input> = BaseParserRuleContext<'input,UserTypeContextExt<'input>>;

#[derive(Clone)]
pub struct UserTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for UserTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for UserTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_userType(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_userType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for UserTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_userType(self);
	}
}

impl<'input> CustomRuleContext<'input> for UserTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_userType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_userType }
}
antlr_rust::tid!{UserTypeContextExt<'a>}

impl<'input> UserTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UserTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UserTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UserTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<UserTypeContextExt<'input>>{

fn simpleUserType_all(&self) ->  Vec<Rc<SimpleUserTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn simpleUserType(&self, i: usize) -> Option<Rc<SimpleUserTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> UserTypeContextAttrs<'input> for UserTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn userType(&mut self,)
	-> Result<Rc<UserTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UserTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 106, RULE_userType);
        let mut _localctx: Rc<UserTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule simpleUserType*/
			recog.base.set_state(1708);
			recog.simpleUserType()?;

			recog.base.set_state(1725);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(249,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1712);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1709);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1714);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1715);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(1719);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1716);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1721);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule simpleUserType*/
					recog.base.set_state(1722);
					recog.simpleUserType()?;

					}
					} 
				}
				recog.base.set_state(1727);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(249,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- simpleUserType ----------------
pub type SimpleUserTypeContextAll<'input> = SimpleUserTypeContext<'input>;


pub type SimpleUserTypeContext<'input> = BaseParserRuleContext<'input,SimpleUserTypeContextExt<'input>>;

#[derive(Clone)]
pub struct SimpleUserTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for SimpleUserTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for SimpleUserTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_simpleUserType(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_simpleUserType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for SimpleUserTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_simpleUserType(self);
	}
}

impl<'input> CustomRuleContext<'input> for SimpleUserTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_simpleUserType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_simpleUserType }
}
antlr_rust::tid!{SimpleUserTypeContextExt<'a>}

impl<'input> SimpleUserTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SimpleUserTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SimpleUserTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SimpleUserTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<SimpleUserTypeContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> SimpleUserTypeContextAttrs<'input> for SimpleUserTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn simpleUserType(&mut self,)
	-> Result<Rc<SimpleUserTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SimpleUserTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 108, RULE_simpleUserType);
        let mut _localctx: Rc<SimpleUserTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(1728);
			recog.simpleIdentifier()?;

			recog.base.set_state(1736);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(251,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1732);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1729);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1734);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeArguments*/
					recog.base.set_state(1735);
					recog.typeArguments()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeProjection ----------------
pub type TypeProjectionContextAll<'input> = TypeProjectionContext<'input>;


pub type TypeProjectionContext<'input> = BaseParserRuleContext<'input,TypeProjectionContextExt<'input>>;

#[derive(Clone)]
pub struct TypeProjectionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeProjectionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeProjectionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeProjection(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_typeProjection(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeProjectionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeProjection(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeProjectionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeProjection }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeProjection }
}
antlr_rust::tid!{TypeProjectionContextExt<'a>}

impl<'input> TypeProjectionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeProjectionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeProjectionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeProjectionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeProjectionContextExt<'input>>{

fn rustType(&self) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeProjectionModifiers(&self) -> Option<Rc<TypeProjectionModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token MULT
/// Returns `None` if there is no child corresponding to token MULT
fn MULT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MULT, 0)
}

}

impl<'input> TypeProjectionContextAttrs<'input> for TypeProjectionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeProjection(&mut self,)
	-> Result<Rc<TypeProjectionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeProjectionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 110, RULE_typeProjection);
        let mut _localctx: Rc<TypeProjectionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1743);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LPAREN | AT_NO_WS | AT_PRE_WS | FILE | FIELD | PROPERTY | GET | SET |
			 RECEIVER | PARAM | SETPARAM | DELEGATE | IMPORT | CONSTRUCTOR | BY |
			 COMPANION | INIT | WHERE | CATCH | FINALLY | IN | OUT | DYNAMIC | PUBLIC |
			 PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED | ANNOTATION | DATA |
			 INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX | EXTERNAL | SUSPEND |
			 OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT | VARARG | NOINLINE |
			 CROSSINLINE | REIFIED | EXPECT | ACTUAL | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(1739);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(252,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule typeProjectionModifiers*/
							recog.base.set_state(1738);
							recog.typeProjectionModifiers()?;

							}
						}

						_ => {}
					}
					/*InvokeRule rustType*/
					recog.base.set_state(1741);
					recog.rustType()?;

					}
				}

			 MULT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(1742);
					recog.base.match_token(MULT,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeProjectionModifiers ----------------
pub type TypeProjectionModifiersContextAll<'input> = TypeProjectionModifiersContext<'input>;


pub type TypeProjectionModifiersContext<'input> = BaseParserRuleContext<'input,TypeProjectionModifiersContextExt<'input>>;

#[derive(Clone)]
pub struct TypeProjectionModifiersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeProjectionModifiersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeProjectionModifiersContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeProjectionModifiers(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_typeProjectionModifiers(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeProjectionModifiersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeProjectionModifiers(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeProjectionModifiersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeProjectionModifiers }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeProjectionModifiers }
}
antlr_rust::tid!{TypeProjectionModifiersContextExt<'a>}

impl<'input> TypeProjectionModifiersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeProjectionModifiersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeProjectionModifiersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeProjectionModifiersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeProjectionModifiersContextExt<'input>>{

fn typeProjectionModifier_all(&self) ->  Vec<Rc<TypeProjectionModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeProjectionModifier(&self, i: usize) -> Option<Rc<TypeProjectionModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TypeProjectionModifiersContextAttrs<'input> for TypeProjectionModifiersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeProjectionModifiers(&mut self,)
	-> Result<Rc<TypeProjectionModifiersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeProjectionModifiersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 112, RULE_typeProjectionModifiers);
        let mut _localctx: Rc<TypeProjectionModifiersContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1746); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					{
					/*InvokeRule typeProjectionModifier*/
					recog.base.set_state(1745);
					recog.typeProjectionModifier()?;

					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(1748); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(254,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeProjectionModifier ----------------
pub type TypeProjectionModifierContextAll<'input> = TypeProjectionModifierContext<'input>;


pub type TypeProjectionModifierContext<'input> = BaseParserRuleContext<'input,TypeProjectionModifierContextExt<'input>>;

#[derive(Clone)]
pub struct TypeProjectionModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeProjectionModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeProjectionModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeProjectionModifier(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_typeProjectionModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeProjectionModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeProjectionModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeProjectionModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeProjectionModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeProjectionModifier }
}
antlr_rust::tid!{TypeProjectionModifierContextExt<'a>}

impl<'input> TypeProjectionModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeProjectionModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeProjectionModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeProjectionModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeProjectionModifierContextExt<'input>>{

fn varianceModifier(&self) -> Option<Rc<VarianceModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeProjectionModifierContextAttrs<'input> for TypeProjectionModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeProjectionModifier(&mut self,)
	-> Result<Rc<TypeProjectionModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeProjectionModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 114, RULE_typeProjectionModifier);
        let mut _localctx: Rc<TypeProjectionModifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1758);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 IN | OUT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule varianceModifier*/
					recog.base.set_state(1750);
					recog.varianceModifier()?;

					recog.base.set_state(1754);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1751);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1756);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

			 AT_NO_WS | AT_PRE_WS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1757);
					recog.annotation()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionType ----------------
pub type FunctionTypeContextAll<'input> = FunctionTypeContext<'input>;


pub type FunctionTypeContext<'input> = BaseParserRuleContext<'input,FunctionTypeContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FunctionTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FunctionTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_functionType(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_functionType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FunctionTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_functionType(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionType }
}
antlr_rust::tid!{FunctionTypeContextExt<'a>}

impl<'input> FunctionTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FunctionTypeContextExt<'input>>{

fn functionTypeParameters(&self) -> Option<Rc<FunctionTypeParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ARROW
/// Returns `None` if there is no child corresponding to token ARROW
fn ARROW(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ARROW, 0)
}
fn rustType(&self) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn receiverType(&self) -> Option<Rc<ReceiverTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> FunctionTypeContextAttrs<'input> for FunctionTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionType(&mut self,)
	-> Result<Rc<FunctionTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 116, RULE_functionType);
        let mut _localctx: Rc<FunctionTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1774);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(259,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule receiverType*/
					recog.base.set_state(1760);
					recog.receiverType()?;

					recog.base.set_state(1764);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1761);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1766);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1767);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(1771);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1768);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1773);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

				_ => {}
			}
			/*InvokeRule functionTypeParameters*/
			recog.base.set_state(1776);
			recog.functionTypeParameters()?;

			recog.base.set_state(1780);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1777);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1782);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1783);
			recog.base.match_token(ARROW,&mut recog.err_handler)?;

			recog.base.set_state(1787);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1784);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1789);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule rustType*/
			recog.base.set_state(1790);
			recog.rustType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionTypeParameters ----------------
pub type FunctionTypeParametersContextAll<'input> = FunctionTypeParametersContext<'input>;


pub type FunctionTypeParametersContext<'input> = BaseParserRuleContext<'input,FunctionTypeParametersContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionTypeParametersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FunctionTypeParametersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FunctionTypeParametersContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_functionTypeParameters(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_functionTypeParameters(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FunctionTypeParametersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_functionTypeParameters(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionTypeParametersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionTypeParameters }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionTypeParameters }
}
antlr_rust::tid!{FunctionTypeParametersContextExt<'a>}

impl<'input> FunctionTypeParametersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionTypeParametersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionTypeParametersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionTypeParametersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FunctionTypeParametersContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn parameter_all(&self) ->  Vec<Rc<ParameterContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn parameter(&self, i: usize) -> Option<Rc<ParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn rustType_all(&self) ->  Vec<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn rustType(&self, i: usize) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> FunctionTypeParametersContextAttrs<'input> for FunctionTypeParametersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionTypeParameters(&mut self,)
	-> Result<Rc<FunctionTypeParametersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionTypeParametersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 118, RULE_functionTypeParameters);
        let mut _localctx: Rc<FunctionTypeParametersContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1792);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1796);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(262,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1793);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1798);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(262,&mut recog.base)?;
			}
			recog.base.set_state(1801);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(263,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule parameter*/
					recog.base.set_state(1799);
					recog.parameter()?;

					}
				}

				x if x == 2=>{
					{
					/*InvokeRule rustType*/
					recog.base.set_state(1800);
					recog.rustType()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1822);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(267,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1806);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1803);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1808);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1809);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(1813);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1810);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1815);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1818);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(266,&mut recog.base)? {
						1 =>{
							{
							/*InvokeRule parameter*/
							recog.base.set_state(1816);
							recog.parameter()?;

							}
						}
					,
						2 =>{
							{
							/*InvokeRule rustType*/
							recog.base.set_state(1817);
							recog.rustType()?;

							}
						}

						_ => {}
					}
					}
					} 
				}
				recog.base.set_state(1824);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(267,&mut recog.base)?;
			}
			recog.base.set_state(1832);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(269,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(1828);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(1825);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(1830);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1831);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1837);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1834);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1839);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1840);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parenthesizedType ----------------
pub type ParenthesizedTypeContextAll<'input> = ParenthesizedTypeContext<'input>;


pub type ParenthesizedTypeContext<'input> = BaseParserRuleContext<'input,ParenthesizedTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ParenthesizedTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParenthesizedTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParenthesizedTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_parenthesizedType(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_parenthesizedType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParenthesizedTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parenthesizedType(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParenthesizedTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parenthesizedType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parenthesizedType }
}
antlr_rust::tid!{ParenthesizedTypeContextExt<'a>}

impl<'input> ParenthesizedTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParenthesizedTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParenthesizedTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParenthesizedTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParenthesizedTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn rustType(&self) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ParenthesizedTypeContextAttrs<'input> for ParenthesizedTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parenthesizedType(&mut self,)
	-> Result<Rc<ParenthesizedTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParenthesizedTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 120, RULE_parenthesizedType);
        let mut _localctx: Rc<ParenthesizedTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1842);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1846);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1843);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1848);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule rustType*/
			recog.base.set_state(1849);
			recog.rustType()?;

			recog.base.set_state(1853);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1850);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1855);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1856);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- receiverType ----------------
pub type ReceiverTypeContextAll<'input> = ReceiverTypeContext<'input>;


pub type ReceiverTypeContext<'input> = BaseParserRuleContext<'input,ReceiverTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ReceiverTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ReceiverTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ReceiverTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_receiverType(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_receiverType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ReceiverTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_receiverType(self);
	}
}

impl<'input> CustomRuleContext<'input> for ReceiverTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_receiverType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_receiverType }
}
antlr_rust::tid!{ReceiverTypeContextExt<'a>}

impl<'input> ReceiverTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReceiverTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReceiverTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReceiverTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ReceiverTypeContextExt<'input>>{

fn parenthesizedType(&self) -> Option<Rc<ParenthesizedTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn nullableType(&self) -> Option<Rc<NullableTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeReference(&self) -> Option<Rc<TypeReferenceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeModifiers(&self) -> Option<Rc<TypeModifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ReceiverTypeContextAttrs<'input> for ReceiverTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn receiverType(&mut self,)
	-> Result<Rc<ReceiverTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReceiverTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 122, RULE_receiverType);
        let mut _localctx: Rc<ReceiverTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1859);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(273,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule typeModifiers*/
					recog.base.set_state(1858);
					recog.typeModifiers()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(1864);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(274,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule parenthesizedType*/
					recog.base.set_state(1861);
					recog.parenthesizedType()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule nullableType*/
					recog.base.set_state(1862);
					recog.nullableType()?;

					}
				}
			,
				3 =>{
					{
					/*InvokeRule typeReference*/
					recog.base.set_state(1863);
					recog.typeReference()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parenthesizedUserType ----------------
pub type ParenthesizedUserTypeContextAll<'input> = ParenthesizedUserTypeContext<'input>;


pub type ParenthesizedUserTypeContext<'input> = BaseParserRuleContext<'input,ParenthesizedUserTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ParenthesizedUserTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParenthesizedUserTypeContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParenthesizedUserTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_parenthesizedUserType(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_parenthesizedUserType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParenthesizedUserTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parenthesizedUserType(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParenthesizedUserTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parenthesizedUserType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parenthesizedUserType }
}
antlr_rust::tid!{ParenthesizedUserTypeContextExt<'a>}

impl<'input> ParenthesizedUserTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParenthesizedUserTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParenthesizedUserTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParenthesizedUserTypeContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParenthesizedUserTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn userType(&self) -> Option<Rc<UserTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parenthesizedUserType(&self) -> Option<Rc<ParenthesizedUserTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ParenthesizedUserTypeContextAttrs<'input> for ParenthesizedUserTypeContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parenthesizedUserType(&mut self,)
	-> Result<Rc<ParenthesizedUserTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParenthesizedUserTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 124, RULE_parenthesizedUserType);
        let mut _localctx: Rc<ParenthesizedUserTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1866);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1870);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1867);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1872);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1875);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 FILE | FIELD | PROPERTY | GET | SET | RECEIVER | PARAM | SETPARAM | DELEGATE |
			 IMPORT | CONSTRUCTOR | BY | COMPANION | INIT | WHERE | CATCH | FINALLY |
			 OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED |
			 ANNOTATION | DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX |
			 EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT |
			 VARARG | NOINLINE | CROSSINLINE | REIFIED | EXPECT | ACTUAL | Identifier 
				=> {
					{
					/*InvokeRule userType*/
					recog.base.set_state(1873);
					recog.userType()?;

					}
				}

			 LPAREN 
				=> {
					{
					/*InvokeRule parenthesizedUserType*/
					recog.base.set_state(1874);
					recog.parenthesizedUserType()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(1880);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1877);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1882);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1883);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- statements ----------------
pub type StatementsContextAll<'input> = StatementsContext<'input>;


pub type StatementsContext<'input> = BaseParserRuleContext<'input,StatementsContextExt<'input>>;

#[derive(Clone)]
pub struct StatementsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for StatementsContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for StatementsContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_statements(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_statements(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for StatementsContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_statements(self);
	}
}

impl<'input> CustomRuleContext<'input> for StatementsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statements }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statements }
}
antlr_rust::tid!{StatementsContextExt<'a>}

impl<'input> StatementsContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StatementsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StatementsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StatementsContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<StatementsContextExt<'input>>{

fn statement_all(&self) ->  Vec<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn statement(&self, i: usize) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn semis_all(&self) ->  Vec<Rc<SemisContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn semis(&self, i: usize) -> Option<Rc<SemisContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> StatementsContextAttrs<'input> for StatementsContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn statements(&mut self,)
	-> Result<Rc<StatementsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StatementsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 126, RULE_statements);
        let mut _localctx: Rc<StatementsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1894);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << LPAREN) | (1usize << LSQUARE) | (1usize << LCURL) | (1usize << ADD) | (1usize << SUB) | (1usize << INCR) | (1usize << DECR) | (1usize << EXCL_WS) | (1usize << EXCL_NO_WS) | (1usize << COLONCOLON) | (1usize << AT_NO_WS) | (1usize << AT_PRE_WS) | (1usize << RETURN_AT) | (1usize << CONTINUE_AT) | (1usize << BREAK_AT) | (1usize << THIS_AT) | (1usize << SUPER_AT) | (1usize << FILE) | (1usize << FIELD) | (1usize << PROPERTY))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (GET - 64)) | (1usize << (SET - 64)) | (1usize << (RECEIVER - 64)) | (1usize << (PARAM - 64)) | (1usize << (SETPARAM - 64)) | (1usize << (DELEGATE - 64)) | (1usize << (IMPORT - 64)) | (1usize << (CLASS - 64)) | (1usize << (INTERFACE - 64)) | (1usize << (FUN - 64)) | (1usize << (OBJECT - 64)) | (1usize << (VAL - 64)) | (1usize << (VAR - 64)) | (1usize << (TYPE_ALIAS - 64)) | (1usize << (CONSTRUCTOR - 64)) | (1usize << (BY - 64)) | (1usize << (COMPANION - 64)) | (1usize << (INIT - 64)) | (1usize << (THIS - 64)) | (1usize << (SUPER - 64)) | (1usize << (WHERE - 64)) | (1usize << (IF - 64)) | (1usize << (WHEN - 64)) | (1usize << (TRY - 64)) | (1usize << (CATCH - 64)) | (1usize << (FINALLY - 64)) | (1usize << (FOR - 64)) | (1usize << (DO - 64)) | (1usize << (WHILE - 64)) | (1usize << (THROW - 64)) | (1usize << (RETURN - 64)) | (1usize << (CONTINUE - 64)) | (1usize << (BREAK - 64)) | (1usize << (OUT - 64)) | (1usize << (DYNAMIC - 64)) | (1usize << (PUBLIC - 64)) | (1usize << (PRIVATE - 64)) | (1usize << (PROTECTED - 64)) | (1usize << (INTERNAL - 64)) | (1usize << (ENUM - 64)) | (1usize << (SEALED - 64)) | (1usize << (ANNOTATION - 64)) | (1usize << (DATA - 64)) | (1usize << (INNER - 64)) | (1usize << (VALUE - 64)) | (1usize << (TAILREC - 64)) | (1usize << (OPERATOR - 64)) | (1usize << (INLINE - 64)) | (1usize << (INFIX - 64)) | (1usize << (EXTERNAL - 64)) | (1usize << (SUSPEND - 64)) | (1usize << (OVERRIDE - 64)) | (1usize << (ABSTRACT - 64)) | (1usize << (FINAL - 64)) | (1usize << (OPEN - 64)) | (1usize << (CONST - 64)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (LATEINIT - 128)) | (1usize << (VARARG - 128)) | (1usize << (NOINLINE - 128)) | (1usize << (CROSSINLINE - 128)) | (1usize << (REIFIED - 128)) | (1usize << (EXPECT - 128)) | (1usize << (ACTUAL - 128)) | (1usize << (RealLiteral - 128)) | (1usize << (IntegerLiteral - 128)) | (1usize << (HexLiteral - 128)) | (1usize << (BinLiteral - 128)) | (1usize << (UnsignedLiteral - 128)) | (1usize << (LongLiteral - 128)) | (1usize << (BooleanLiteral - 128)) | (1usize << (NullLiteral - 128)) | (1usize << (CharacterLiteral - 128)) | (1usize << (Identifier - 128)) | (1usize << (QUOTE_OPEN - 128)) | (1usize << (TRIPLE_QUOTE_OPEN - 128)))) != 0) {
				{
				/*InvokeRule statement*/
				recog.base.set_state(1885);
				recog.statement()?;

				recog.base.set_state(1891);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(278,&mut recog.base)?;
				while { _alt!=2 && _alt!=INVALID_ALT } {
					if _alt==1 {
						{
						{
						/*InvokeRule semis*/
						recog.base.set_state(1886);
						recog.semis()?;

						/*InvokeRule statement*/
						recog.base.set_state(1887);
						recog.statement()?;

						}
						} 
					}
					recog.base.set_state(1893);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(278,&mut recog.base)?;
				}
				}
			}

			recog.base.set_state(1897);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(280,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule semis*/
					recog.base.set_state(1896);
					recog.semis()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- statement ----------------
pub type StatementContextAll<'input> = StatementContext<'input>;


pub type StatementContext<'input> = BaseParserRuleContext<'input,StatementContextExt<'input>>;

#[derive(Clone)]
pub struct StatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for StatementContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for StatementContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_statement(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_statement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for StatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_statement(self);
	}
}

impl<'input> CustomRuleContext<'input> for StatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}
antlr_rust::tid!{StatementContextExt<'a>}

impl<'input> StatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StatementContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<StatementContextExt<'input>>{

fn declaration(&self) -> Option<Rc<DeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignment(&self) -> Option<Rc<AssignmentContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn loopStatement(&self) -> Option<Rc<LoopStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn label_all(&self) ->  Vec<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn label(&self, i: usize) -> Option<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> StatementContextAttrs<'input> for StatementContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn statement(&mut self,)
	-> Result<Rc<StatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 128, RULE_statement);
        let mut _localctx: Rc<StatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1903);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(282,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					recog.base.set_state(1901);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 FILE | FIELD | PROPERTY | GET | SET | RECEIVER | PARAM | SETPARAM |
					 DELEGATE | IMPORT | CONSTRUCTOR | BY | COMPANION | INIT | WHERE | CATCH |
					 FINALLY | OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED | INTERNAL |
					 ENUM | SEALED | ANNOTATION | DATA | INNER | VALUE | TAILREC | OPERATOR |
					 INLINE | INFIX | EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT | FINAL |
					 OPEN | CONST | LATEINIT | VARARG | NOINLINE | CROSSINLINE | REIFIED |
					 EXPECT | ACTUAL | Identifier 
						=> {
							{
							/*InvokeRule label*/
							recog.base.set_state(1899);
							recog.label()?;

							}
						}

					 AT_NO_WS | AT_PRE_WS 
						=> {
							{
							/*InvokeRule annotation*/
							recog.base.set_state(1900);
							recog.annotation()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					} 
				}
				recog.base.set_state(1905);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(282,&mut recog.base)?;
			}
			recog.base.set_state(1910);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(283,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule declaration*/
					recog.base.set_state(1906);
					recog.declaration()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule assignment*/
					recog.base.set_state(1907);
					recog.assignment()?;

					}
				}
			,
				3 =>{
					{
					/*InvokeRule loopStatement*/
					recog.base.set_state(1908);
					recog.loopStatement()?;

					}
				}
			,
				4 =>{
					{
					/*InvokeRule expression*/
					recog.base.set_state(1909);
					recog.expression()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- label ----------------
pub type LabelContextAll<'input> = LabelContext<'input>;


pub type LabelContext<'input> = BaseParserRuleContext<'input,LabelContextExt<'input>>;

#[derive(Clone)]
pub struct LabelContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for LabelContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for LabelContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_label(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_label(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for LabelContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_label(self);
	}
}

impl<'input> CustomRuleContext<'input> for LabelContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_label }
	//fn type_rule_index() -> usize where Self: Sized { RULE_label }
}
antlr_rust::tid!{LabelContextExt<'a>}

impl<'input> LabelContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LabelContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LabelContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LabelContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<LabelContextExt<'input>>{

fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token AT_NO_WS
/// Returns `None` if there is no child corresponding to token AT_NO_WS
fn AT_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_NO_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token AT_POST_WS
/// Returns `None` if there is no child corresponding to token AT_POST_WS
fn AT_POST_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_POST_WS, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> LabelContextAttrs<'input> for LabelContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn label(&mut self,)
	-> Result<Rc<LabelContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LabelContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 130, RULE_label);
        let mut _localctx: Rc<LabelContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(1912);
			recog.simpleIdentifier()?;

			recog.base.set_state(1913);
			_la = recog.base.input.la(1);
			if { !(_la==AT_NO_WS || _la==AT_POST_WS) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			recog.base.set_state(1917);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(284,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1914);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1919);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(284,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- controlStructureBody ----------------
pub type ControlStructureBodyContextAll<'input> = ControlStructureBodyContext<'input>;


pub type ControlStructureBodyContext<'input> = BaseParserRuleContext<'input,ControlStructureBodyContextExt<'input>>;

#[derive(Clone)]
pub struct ControlStructureBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ControlStructureBodyContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ControlStructureBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_controlStructureBody(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_controlStructureBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ControlStructureBodyContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_controlStructureBody(self);
	}
}

impl<'input> CustomRuleContext<'input> for ControlStructureBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_controlStructureBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_controlStructureBody }
}
antlr_rust::tid!{ControlStructureBodyContextExt<'a>}

impl<'input> ControlStructureBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ControlStructureBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ControlStructureBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ControlStructureBodyContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ControlStructureBodyContextExt<'input>>{

fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ControlStructureBodyContextAttrs<'input> for ControlStructureBodyContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn controlStructureBody(&mut self,)
	-> Result<Rc<ControlStructureBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ControlStructureBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 132, RULE_controlStructureBody);
        let mut _localctx: Rc<ControlStructureBodyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1922);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(285,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule block*/
					recog.base.set_state(1920);
					recog.block()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule statement*/
					recog.base.set_state(1921);
					recog.statement()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- block ----------------
pub type BlockContextAll<'input> = BlockContext<'input>;


pub type BlockContext<'input> = BaseParserRuleContext<'input,BlockContextExt<'input>>;

#[derive(Clone)]
pub struct BlockContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for BlockContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for BlockContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_block(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_block(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for BlockContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_block(self);
	}
}

impl<'input> CustomRuleContext<'input> for BlockContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_block }
	//fn type_rule_index() -> usize where Self: Sized { RULE_block }
}
antlr_rust::tid!{BlockContextExt<'a>}

impl<'input> BlockContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BlockContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BlockContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BlockContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<BlockContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LCURL
/// Returns `None` if there is no child corresponding to token LCURL
fn LCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LCURL, 0)
}
fn statements(&self) -> Option<Rc<StatementsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RCURL
/// Returns `None` if there is no child corresponding to token RCURL
fn RCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RCURL, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> BlockContextAttrs<'input> for BlockContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn block(&mut self,)
	-> Result<Rc<BlockContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BlockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 134, RULE_block);
        let mut _localctx: Rc<BlockContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1924);
			recog.base.match_token(LCURL,&mut recog.err_handler)?;

			recog.base.set_state(1928);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(286,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1925);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1930);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(286,&mut recog.base)?;
			}
			/*InvokeRule statements*/
			recog.base.set_state(1931);
			recog.statements()?;

			recog.base.set_state(1935);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1932);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1937);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1938);
			recog.base.match_token(RCURL,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- loopStatement ----------------
pub type LoopStatementContextAll<'input> = LoopStatementContext<'input>;


pub type LoopStatementContext<'input> = BaseParserRuleContext<'input,LoopStatementContextExt<'input>>;

#[derive(Clone)]
pub struct LoopStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for LoopStatementContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for LoopStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_loopStatement(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_loopStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for LoopStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_loopStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for LoopStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_loopStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_loopStatement }
}
antlr_rust::tid!{LoopStatementContextExt<'a>}

impl<'input> LoopStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LoopStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LoopStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LoopStatementContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<LoopStatementContextExt<'input>>{

fn forStatement(&self) -> Option<Rc<ForStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn whileStatement(&self) -> Option<Rc<WhileStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn doWhileStatement(&self) -> Option<Rc<DoWhileStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LoopStatementContextAttrs<'input> for LoopStatementContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn loopStatement(&mut self,)
	-> Result<Rc<LoopStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LoopStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 136, RULE_loopStatement);
        let mut _localctx: Rc<LoopStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(1943);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 FOR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule forStatement*/
					recog.base.set_state(1940);
					recog.forStatement()?;

					}
				}

			 WHILE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule whileStatement*/
					recog.base.set_state(1941);
					recog.whileStatement()?;

					}
				}

			 DO 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule doWhileStatement*/
					recog.base.set_state(1942);
					recog.doWhileStatement()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- forStatement ----------------
pub type ForStatementContextAll<'input> = ForStatementContext<'input>;


pub type ForStatementContext<'input> = BaseParserRuleContext<'input,ForStatementContextExt<'input>>;

#[derive(Clone)]
pub struct ForStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ForStatementContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ForStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_forStatement(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_forStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ForStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_forStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for ForStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_forStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_forStatement }
}
antlr_rust::tid!{ForStatementContextExt<'a>}

impl<'input> ForStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ForStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ForStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ForStatementContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ForStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FOR
/// Returns `None` if there is no child corresponding to token FOR
fn FOR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FOR, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token IN
/// Returns `None` if there is no child corresponding to token IN
fn IN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(IN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn variableDeclaration(&self) -> Option<Rc<VariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn multiVariableDeclaration(&self) -> Option<Rc<MultiVariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn controlStructureBody(&self) -> Option<Rc<ControlStructureBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ForStatementContextAttrs<'input> for ForStatementContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn forStatement(&mut self,)
	-> Result<Rc<ForStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ForStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 138, RULE_forStatement);
        let mut _localctx: Rc<ForStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1945);
			recog.base.match_token(FOR,&mut recog.err_handler)?;

			recog.base.set_state(1949);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1946);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1951);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1952);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1956);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(290,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule annotation*/
					recog.base.set_state(1953);
					recog.annotation()?;

					}
					} 
				}
				recog.base.set_state(1958);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(290,&mut recog.base)?;
			}
			recog.base.set_state(1961);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 NL | AT_NO_WS | AT_PRE_WS | FILE | FIELD | PROPERTY | GET | SET | RECEIVER |
			 PARAM | SETPARAM | DELEGATE | IMPORT | CONSTRUCTOR | BY | COMPANION |
			 INIT | WHERE | CATCH | FINALLY | OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED |
			 INTERNAL | ENUM | SEALED | ANNOTATION | DATA | INNER | VALUE | TAILREC |
			 OPERATOR | INLINE | INFIX | EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT |
			 FINAL | OPEN | CONST | LATEINIT | VARARG | NOINLINE | CROSSINLINE | REIFIED |
			 EXPECT | ACTUAL | Identifier 
				=> {
					{
					/*InvokeRule variableDeclaration*/
					recog.base.set_state(1959);
					recog.variableDeclaration()?;

					}
				}

			 LPAREN 
				=> {
					{
					/*InvokeRule multiVariableDeclaration*/
					recog.base.set_state(1960);
					recog.multiVariableDeclaration()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(1963);
			recog.base.match_token(IN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1964);
			recog.expression()?;

			recog.base.set_state(1965);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1969);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(292,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1966);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(1971);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(292,&mut recog.base)?;
			}
			recog.base.set_state(1973);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(293,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule controlStructureBody*/
					recog.base.set_state(1972);
					recog.controlStructureBody()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- whileStatement ----------------
pub type WhileStatementContextAll<'input> = WhileStatementContext<'input>;


pub type WhileStatementContext<'input> = BaseParserRuleContext<'input,WhileStatementContextExt<'input>>;

#[derive(Clone)]
pub struct WhileStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for WhileStatementContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for WhileStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_whileStatement(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_whileStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for WhileStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_whileStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for WhileStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_whileStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_whileStatement }
}
antlr_rust::tid!{WhileStatementContextExt<'a>}

impl<'input> WhileStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WhileStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WhileStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WhileStatementContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<WhileStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token WHILE
/// Returns `None` if there is no child corresponding to token WHILE
fn WHILE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(WHILE, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn controlStructureBody(&self) -> Option<Rc<ControlStructureBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMICOLON
/// Returns `None` if there is no child corresponding to token SEMICOLON
fn SEMICOLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SEMICOLON, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> WhileStatementContextAttrs<'input> for WhileStatementContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn whileStatement(&mut self,)
	-> Result<Rc<WhileStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WhileStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 140, RULE_whileStatement);
        let mut _localctx: Rc<WhileStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1975);
			recog.base.match_token(WHILE,&mut recog.err_handler)?;

			recog.base.set_state(1979);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1976);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1981);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1982);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(1983);
			recog.expression()?;

			recog.base.set_state(1984);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			recog.base.set_state(1988);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(1985);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(1990);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(1993);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LPAREN | LSQUARE | LCURL | ADD | SUB | INCR | DECR | EXCL_WS | EXCL_NO_WS |
			 COLONCOLON | AT_NO_WS | AT_PRE_WS | RETURN_AT | CONTINUE_AT | BREAK_AT |
			 THIS_AT | SUPER_AT | FILE | FIELD | PROPERTY | GET | SET | RECEIVER |
			 PARAM | SETPARAM | DELEGATE | IMPORT | CLASS | INTERFACE | FUN | OBJECT |
			 VAL | VAR | TYPE_ALIAS | CONSTRUCTOR | BY | COMPANION | INIT | THIS |
			 SUPER | WHERE | IF | WHEN | TRY | CATCH | FINALLY | FOR | DO | WHILE |
			 THROW | RETURN | CONTINUE | BREAK | OUT | DYNAMIC | PUBLIC | PRIVATE |
			 PROTECTED | INTERNAL | ENUM | SEALED | ANNOTATION | DATA | INNER | VALUE |
			 TAILREC | OPERATOR | INLINE | INFIX | EXTERNAL | SUSPEND | OVERRIDE |
			 ABSTRACT | FINAL | OPEN | CONST | LATEINIT | VARARG | NOINLINE | CROSSINLINE |
			 REIFIED | EXPECT | ACTUAL | RealLiteral | IntegerLiteral | HexLiteral |
			 BinLiteral | UnsignedLiteral | LongLiteral | BooleanLiteral | NullLiteral |
			 CharacterLiteral | Identifier | QUOTE_OPEN | TRIPLE_QUOTE_OPEN 
				=> {
					{
					/*InvokeRule controlStructureBody*/
					recog.base.set_state(1991);
					recog.controlStructureBody()?;

					}
				}

			 SEMICOLON 
				=> {
					{
					recog.base.set_state(1992);
					recog.base.match_token(SEMICOLON,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- doWhileStatement ----------------
pub type DoWhileStatementContextAll<'input> = DoWhileStatementContext<'input>;


pub type DoWhileStatementContext<'input> = BaseParserRuleContext<'input,DoWhileStatementContextExt<'input>>;

#[derive(Clone)]
pub struct DoWhileStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for DoWhileStatementContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for DoWhileStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_doWhileStatement(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_doWhileStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for DoWhileStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_doWhileStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for DoWhileStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_doWhileStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_doWhileStatement }
}
antlr_rust::tid!{DoWhileStatementContextExt<'a>}

impl<'input> DoWhileStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DoWhileStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DoWhileStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DoWhileStatementContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<DoWhileStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DO
/// Returns `None` if there is no child corresponding to token DO
fn DO(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DO, 0)
}
/// Retrieves first TerminalNode corresponding to token WHILE
/// Returns `None` if there is no child corresponding to token WHILE
fn WHILE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(WHILE, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn controlStructureBody(&self) -> Option<Rc<ControlStructureBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DoWhileStatementContextAttrs<'input> for DoWhileStatementContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn doWhileStatement(&mut self,)
	-> Result<Rc<DoWhileStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DoWhileStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 142, RULE_doWhileStatement);
        let mut _localctx: Rc<DoWhileStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1995);
			recog.base.match_token(DO,&mut recog.err_handler)?;

			recog.base.set_state(1999);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(297,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(1996);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2001);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(297,&mut recog.base)?;
			}
			recog.base.set_state(2003);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(298,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule controlStructureBody*/
					recog.base.set_state(2002);
					recog.controlStructureBody()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2008);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2005);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2010);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2011);
			recog.base.match_token(WHILE,&mut recog.err_handler)?;

			recog.base.set_state(2015);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2012);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2017);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2018);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2019);
			recog.expression()?;

			recog.base.set_state(2020);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignment ----------------
pub type AssignmentContextAll<'input> = AssignmentContext<'input>;


pub type AssignmentContext<'input> = BaseParserRuleContext<'input,AssignmentContextExt<'input>>;

#[derive(Clone)]
pub struct AssignmentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AssignmentContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AssignmentContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_assignment(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_assignment(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AssignmentContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_assignment(self);
	}
}

impl<'input> CustomRuleContext<'input> for AssignmentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignment }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignment }
}
antlr_rust::tid!{AssignmentContextExt<'a>}

impl<'input> AssignmentContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignmentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignmentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignmentContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AssignmentContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn directlyAssignableExpression(&self) -> Option<Rc<DirectlyAssignableExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ASSIGNMENT
fn ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ASSIGNMENT, 0)
}
fn assignableExpression(&self) -> Option<Rc<AssignableExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignmentAndOperator(&self) -> Option<Rc<AssignmentAndOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> AssignmentContextAttrs<'input> for AssignmentContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignment(&mut self,)
	-> Result<Rc<AssignmentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignmentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 144, RULE_assignment);
        let mut _localctx: Rc<AssignmentContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2028);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(301,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule directlyAssignableExpression*/
					recog.base.set_state(2022);
					recog.directlyAssignableExpression()?;

					recog.base.set_state(2023);
					recog.base.match_token(ASSIGNMENT,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule assignableExpression*/
					recog.base.set_state(2025);
					recog.assignableExpression()?;

					/*InvokeRule assignmentAndOperator*/
					recog.base.set_state(2026);
					recog.assignmentAndOperator()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2033);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2030);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2035);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule expression*/
			recog.base.set_state(2036);
			recog.expression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- semi ----------------
pub type SemiContextAll<'input> = SemiContext<'input>;


pub type SemiContext<'input> = BaseParserRuleContext<'input,SemiContextExt<'input>>;

#[derive(Clone)]
pub struct SemiContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for SemiContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for SemiContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_semi(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_semi(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for SemiContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_semi(self);
	}
}

impl<'input> CustomRuleContext<'input> for SemiContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_semi }
	//fn type_rule_index() -> usize where Self: Sized { RULE_semi }
}
antlr_rust::tid!{SemiContextExt<'a>}

impl<'input> SemiContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SemiContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SemiContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SemiContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<SemiContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SEMICOLON
/// Returns `None` if there is no child corresponding to token SEMICOLON
fn SEMICOLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SEMICOLON, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token EOF
/// Returns `None` if there is no child corresponding to token EOF
fn EOF(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EOF, 0)
}

}

impl<'input> SemiContextAttrs<'input> for SemiContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn semi(&mut self,)
	-> Result<Rc<SemiContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SemiContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 146, RULE_semi);
        let mut _localctx: Rc<SemiContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(2046);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 NL | SEMICOLON 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2038);
					_la = recog.base.input.la(1);
					if { !(_la==NL || _la==SEMICOLON) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(2042);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(303,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2039);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2044);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(303,&mut recog.base)?;
					}
					}
				}

			 EOF 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2045);
					recog.base.match_token(EOF,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- semis ----------------
pub type SemisContextAll<'input> = SemisContext<'input>;


pub type SemisContext<'input> = BaseParserRuleContext<'input,SemisContextExt<'input>>;

#[derive(Clone)]
pub struct SemisContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for SemisContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for SemisContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_semis(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_semis(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for SemisContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_semis(self);
	}
}

impl<'input> CustomRuleContext<'input> for SemisContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_semis }
	//fn type_rule_index() -> usize where Self: Sized { RULE_semis }
}
antlr_rust::tid!{SemisContextExt<'a>}

impl<'input> SemisContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SemisContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SemisContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SemisContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<SemisContextExt<'input>>{

/// Retrieves all `TerminalNode`s corresponding to token SEMICOLON in current rule
fn SEMICOLON_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token SEMICOLON, starting from 0.
/// Returns `None` if number of children corresponding to token SEMICOLON is less or equal than `i`.
fn SEMICOLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SEMICOLON, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token EOF
/// Returns `None` if there is no child corresponding to token EOF
fn EOF(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EOF, 0)
}

}

impl<'input> SemisContextAttrs<'input> for SemisContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn semis(&mut self,)
	-> Result<Rc<SemisContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SemisContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 148, RULE_semis);
        let mut _localctx: Rc<SemisContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(2054);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 NL | SEMICOLON 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2049); 
					recog.err_handler.sync(&mut recog.base)?;
					_alt = 1;
					loop {
						match _alt {
						    x if x == 1=>
							{
							{
							recog.base.set_state(2048);
							_la = recog.base.input.la(1);
							if { !(_la==NL || _la==SEMICOLON) } {
								recog.err_handler.recover_inline(&mut recog.base)?;

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							}
							}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
						}
						recog.base.set_state(2051); 
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(305,&mut recog.base)?;
						if _alt==2 || _alt==INVALID_ALT { break }
					}
					}
				}

			 EOF 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2053);
					recog.base.match_token(EOF,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- expression ----------------
pub type ExpressionContextAll<'input> = ExpressionContext<'input>;


pub type ExpressionContext<'input> = BaseParserRuleContext<'input,ExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_expression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_expression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_expression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}
antlr_rust::tid!{ExpressionContextExt<'a>}

impl<'input> ExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ExpressionContextExt<'input>>{

fn disjunction(&self) -> Option<Rc<DisjunctionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExpressionContextAttrs<'input> for ExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn expression(&mut self,)
	-> Result<Rc<ExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 150, RULE_expression);
        let mut _localctx: Rc<ExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule disjunction*/
			recog.base.set_state(2056);
			recog.disjunction()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- disjunction ----------------
pub type DisjunctionContextAll<'input> = DisjunctionContext<'input>;


pub type DisjunctionContext<'input> = BaseParserRuleContext<'input,DisjunctionContextExt<'input>>;

#[derive(Clone)]
pub struct DisjunctionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for DisjunctionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for DisjunctionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_disjunction(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_disjunction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for DisjunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_disjunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for DisjunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_disjunction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_disjunction }
}
antlr_rust::tid!{DisjunctionContextExt<'a>}

impl<'input> DisjunctionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DisjunctionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DisjunctionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DisjunctionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<DisjunctionContextExt<'input>>{

fn conjunction_all(&self) ->  Vec<Rc<ConjunctionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn conjunction(&self, i: usize) -> Option<Rc<ConjunctionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token DISJ in current rule
fn DISJ_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DISJ, starting from 0.
/// Returns `None` if number of children corresponding to token DISJ is less or equal than `i`.
fn DISJ(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DISJ, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> DisjunctionContextAttrs<'input> for DisjunctionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn disjunction(&mut self,)
	-> Result<Rc<DisjunctionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DisjunctionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 152, RULE_disjunction);
        let mut _localctx: Rc<DisjunctionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule conjunction*/
			recog.base.set_state(2058);
			recog.conjunction()?;

			recog.base.set_state(2075);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(309,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2062);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2059);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2064);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2065);
					recog.base.match_token(DISJ,&mut recog.err_handler)?;

					recog.base.set_state(2069);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2066);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2071);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule conjunction*/
					recog.base.set_state(2072);
					recog.conjunction()?;

					}
					} 
				}
				recog.base.set_state(2077);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(309,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- conjunction ----------------
pub type ConjunctionContextAll<'input> = ConjunctionContext<'input>;


pub type ConjunctionContext<'input> = BaseParserRuleContext<'input,ConjunctionContextExt<'input>>;

#[derive(Clone)]
pub struct ConjunctionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ConjunctionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ConjunctionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_conjunction(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_conjunction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ConjunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_conjunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConjunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_conjunction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_conjunction }
}
antlr_rust::tid!{ConjunctionContextExt<'a>}

impl<'input> ConjunctionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConjunctionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConjunctionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConjunctionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ConjunctionContextExt<'input>>{

fn equality_all(&self) ->  Vec<Rc<EqualityContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn equality(&self, i: usize) -> Option<Rc<EqualityContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token CONJ in current rule
fn CONJ_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token CONJ, starting from 0.
/// Returns `None` if number of children corresponding to token CONJ is less or equal than `i`.
fn CONJ(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CONJ, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ConjunctionContextAttrs<'input> for ConjunctionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn conjunction(&mut self,)
	-> Result<Rc<ConjunctionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConjunctionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 154, RULE_conjunction);
        let mut _localctx: Rc<ConjunctionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule equality*/
			recog.base.set_state(2078);
			recog.equality()?;

			recog.base.set_state(2095);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(312,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2082);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2079);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2084);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2085);
					recog.base.match_token(CONJ,&mut recog.err_handler)?;

					recog.base.set_state(2089);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2086);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2091);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule equality*/
					recog.base.set_state(2092);
					recog.equality()?;

					}
					} 
				}
				recog.base.set_state(2097);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(312,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- equality ----------------
pub type EqualityContextAll<'input> = EqualityContext<'input>;


pub type EqualityContext<'input> = BaseParserRuleContext<'input,EqualityContextExt<'input>>;

#[derive(Clone)]
pub struct EqualityContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for EqualityContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for EqualityContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_equality(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_equality(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for EqualityContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_equality(self);
	}
}

impl<'input> CustomRuleContext<'input> for EqualityContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_equality }
	//fn type_rule_index() -> usize where Self: Sized { RULE_equality }
}
antlr_rust::tid!{EqualityContextExt<'a>}

impl<'input> EqualityContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EqualityContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EqualityContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EqualityContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<EqualityContextExt<'input>>{

fn comparison_all(&self) ->  Vec<Rc<ComparisonContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn comparison(&self, i: usize) -> Option<Rc<ComparisonContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn equalityOperator_all(&self) ->  Vec<Rc<EqualityOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn equalityOperator(&self, i: usize) -> Option<Rc<EqualityOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> EqualityContextAttrs<'input> for EqualityContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn equality(&mut self,)
	-> Result<Rc<EqualityContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EqualityContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 156, RULE_equality);
        let mut _localctx: Rc<EqualityContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule comparison*/
			recog.base.set_state(2098);
			recog.comparison()?;

			recog.base.set_state(2110);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(314,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule equalityOperator*/
					recog.base.set_state(2099);
					recog.equalityOperator()?;

					recog.base.set_state(2103);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2100);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2105);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule comparison*/
					recog.base.set_state(2106);
					recog.comparison()?;

					}
					} 
				}
				recog.base.set_state(2112);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(314,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- comparison ----------------
pub type ComparisonContextAll<'input> = ComparisonContext<'input>;


pub type ComparisonContext<'input> = BaseParserRuleContext<'input,ComparisonContextExt<'input>>;

#[derive(Clone)]
pub struct ComparisonContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ComparisonContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ComparisonContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_comparison(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_comparison(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ComparisonContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_comparison(self);
	}
}

impl<'input> CustomRuleContext<'input> for ComparisonContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_comparison }
	//fn type_rule_index() -> usize where Self: Sized { RULE_comparison }
}
antlr_rust::tid!{ComparisonContextExt<'a>}

impl<'input> ComparisonContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ComparisonContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ComparisonContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ComparisonContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ComparisonContextExt<'input>>{

fn genericCallLikeComparison_all(&self) ->  Vec<Rc<GenericCallLikeComparisonContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn genericCallLikeComparison(&self, i: usize) -> Option<Rc<GenericCallLikeComparisonContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn comparisonOperator_all(&self) ->  Vec<Rc<ComparisonOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn comparisonOperator(&self, i: usize) -> Option<Rc<ComparisonOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ComparisonContextAttrs<'input> for ComparisonContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn comparison(&mut self,)
	-> Result<Rc<ComparisonContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ComparisonContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 158, RULE_comparison);
        let mut _localctx: Rc<ComparisonContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule genericCallLikeComparison*/
			recog.base.set_state(2113);
			recog.genericCallLikeComparison()?;

			recog.base.set_state(2125);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(316,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule comparisonOperator*/
					recog.base.set_state(2114);
					recog.comparisonOperator()?;

					recog.base.set_state(2118);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2115);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2120);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule genericCallLikeComparison*/
					recog.base.set_state(2121);
					recog.genericCallLikeComparison()?;

					}
					} 
				}
				recog.base.set_state(2127);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(316,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- genericCallLikeComparison ----------------
pub type GenericCallLikeComparisonContextAll<'input> = GenericCallLikeComparisonContext<'input>;


pub type GenericCallLikeComparisonContext<'input> = BaseParserRuleContext<'input,GenericCallLikeComparisonContextExt<'input>>;

#[derive(Clone)]
pub struct GenericCallLikeComparisonContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for GenericCallLikeComparisonContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for GenericCallLikeComparisonContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_genericCallLikeComparison(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_genericCallLikeComparison(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for GenericCallLikeComparisonContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_genericCallLikeComparison(self);
	}
}

impl<'input> CustomRuleContext<'input> for GenericCallLikeComparisonContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_genericCallLikeComparison }
	//fn type_rule_index() -> usize where Self: Sized { RULE_genericCallLikeComparison }
}
antlr_rust::tid!{GenericCallLikeComparisonContextExt<'a>}

impl<'input> GenericCallLikeComparisonContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<GenericCallLikeComparisonContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,GenericCallLikeComparisonContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait GenericCallLikeComparisonContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<GenericCallLikeComparisonContextExt<'input>>{

fn infixOperation(&self) -> Option<Rc<InfixOperationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn callSuffix_all(&self) ->  Vec<Rc<CallSuffixContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn callSuffix(&self, i: usize) -> Option<Rc<CallSuffixContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> GenericCallLikeComparisonContextAttrs<'input> for GenericCallLikeComparisonContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn genericCallLikeComparison(&mut self,)
	-> Result<Rc<GenericCallLikeComparisonContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = GenericCallLikeComparisonContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 160, RULE_genericCallLikeComparison);
        let mut _localctx: Rc<GenericCallLikeComparisonContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule infixOperation*/
			recog.base.set_state(2128);
			recog.infixOperation()?;

			recog.base.set_state(2132);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(317,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule callSuffix*/
					recog.base.set_state(2129);
					recog.callSuffix()?;

					}
					} 
				}
				recog.base.set_state(2134);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(317,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- infixOperation ----------------
pub type InfixOperationContextAll<'input> = InfixOperationContext<'input>;


pub type InfixOperationContext<'input> = BaseParserRuleContext<'input,InfixOperationContextExt<'input>>;

#[derive(Clone)]
pub struct InfixOperationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for InfixOperationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for InfixOperationContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_infixOperation(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_infixOperation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for InfixOperationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_infixOperation(self);
	}
}

impl<'input> CustomRuleContext<'input> for InfixOperationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_infixOperation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_infixOperation }
}
antlr_rust::tid!{InfixOperationContextExt<'a>}

impl<'input> InfixOperationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InfixOperationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InfixOperationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InfixOperationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<InfixOperationContextExt<'input>>{

fn elvisExpression_all(&self) ->  Vec<Rc<ElvisExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn elvisExpression(&self, i: usize) -> Option<Rc<ElvisExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn inOperator_all(&self) ->  Vec<Rc<InOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn inOperator(&self, i: usize) -> Option<Rc<InOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn isOperator_all(&self) ->  Vec<Rc<IsOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn isOperator(&self, i: usize) -> Option<Rc<IsOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn rustType_all(&self) ->  Vec<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn rustType(&self, i: usize) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> InfixOperationContextAttrs<'input> for InfixOperationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn infixOperation(&mut self,)
	-> Result<Rc<InfixOperationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InfixOperationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 162, RULE_infixOperation);
        let mut _localctx: Rc<InfixOperationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule elvisExpression*/
			recog.base.set_state(2135);
			recog.elvisExpression()?;

			recog.base.set_state(2156);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(321,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					recog.base.set_state(2154);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 IN | NOT_IN 
						=> {
							{
							/*InvokeRule inOperator*/
							recog.base.set_state(2136);
							recog.inOperator()?;

							recog.base.set_state(2140);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(2137);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(2142);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							/*InvokeRule elvisExpression*/
							recog.base.set_state(2143);
							recog.elvisExpression()?;

							}
						}

					 IS | NOT_IS 
						=> {
							{
							/*InvokeRule isOperator*/
							recog.base.set_state(2145);
							recog.isOperator()?;

							recog.base.set_state(2149);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(2146);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(2151);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							/*InvokeRule rustType*/
							recog.base.set_state(2152);
							recog.rustType()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					} 
				}
				recog.base.set_state(2158);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(321,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- elvisExpression ----------------
pub type ElvisExpressionContextAll<'input> = ElvisExpressionContext<'input>;


pub type ElvisExpressionContext<'input> = BaseParserRuleContext<'input,ElvisExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ElvisExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ElvisExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ElvisExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_elvisExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_elvisExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ElvisExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_elvisExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ElvisExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_elvisExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_elvisExpression }
}
antlr_rust::tid!{ElvisExpressionContextExt<'a>}

impl<'input> ElvisExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ElvisExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ElvisExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ElvisExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ElvisExpressionContextExt<'input>>{

fn infixFunctionCall_all(&self) ->  Vec<Rc<InfixFunctionCallContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn infixFunctionCall(&self, i: usize) -> Option<Rc<InfixFunctionCallContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn elvis_all(&self) ->  Vec<Rc<ElvisContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn elvis(&self, i: usize) -> Option<Rc<ElvisContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ElvisExpressionContextAttrs<'input> for ElvisExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn elvisExpression(&mut self,)
	-> Result<Rc<ElvisExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ElvisExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 164, RULE_elvisExpression);
        let mut _localctx: Rc<ElvisExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule infixFunctionCall*/
			recog.base.set_state(2159);
			recog.infixFunctionCall()?;

			recog.base.set_state(2177);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(324,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2163);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2160);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2165);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule elvis*/
					recog.base.set_state(2166);
					recog.elvis()?;

					recog.base.set_state(2170);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2167);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2172);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule infixFunctionCall*/
					recog.base.set_state(2173);
					recog.infixFunctionCall()?;

					}
					} 
				}
				recog.base.set_state(2179);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(324,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- elvis ----------------
pub type ElvisContextAll<'input> = ElvisContext<'input>;


pub type ElvisContext<'input> = BaseParserRuleContext<'input,ElvisContextExt<'input>>;

#[derive(Clone)]
pub struct ElvisContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ElvisContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ElvisContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_elvis(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_elvis(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ElvisContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_elvis(self);
	}
}

impl<'input> CustomRuleContext<'input> for ElvisContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_elvis }
	//fn type_rule_index() -> usize where Self: Sized { RULE_elvis }
}
antlr_rust::tid!{ElvisContextExt<'a>}

impl<'input> ElvisContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ElvisContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ElvisContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ElvisContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ElvisContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token QUEST_NO_WS
/// Returns `None` if there is no child corresponding to token QUEST_NO_WS
fn QUEST_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(QUEST_NO_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}

}

impl<'input> ElvisContextAttrs<'input> for ElvisContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn elvis(&mut self,)
	-> Result<Rc<ElvisContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ElvisContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 166, RULE_elvis);
        let mut _localctx: Rc<ElvisContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2180);
			recog.base.match_token(QUEST_NO_WS,&mut recog.err_handler)?;

			recog.base.set_state(2181);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- infixFunctionCall ----------------
pub type InfixFunctionCallContextAll<'input> = InfixFunctionCallContext<'input>;


pub type InfixFunctionCallContext<'input> = BaseParserRuleContext<'input,InfixFunctionCallContextExt<'input>>;

#[derive(Clone)]
pub struct InfixFunctionCallContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for InfixFunctionCallContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for InfixFunctionCallContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_infixFunctionCall(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_infixFunctionCall(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for InfixFunctionCallContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_infixFunctionCall(self);
	}
}

impl<'input> CustomRuleContext<'input> for InfixFunctionCallContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_infixFunctionCall }
	//fn type_rule_index() -> usize where Self: Sized { RULE_infixFunctionCall }
}
antlr_rust::tid!{InfixFunctionCallContextExt<'a>}

impl<'input> InfixFunctionCallContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InfixFunctionCallContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InfixFunctionCallContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InfixFunctionCallContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<InfixFunctionCallContextExt<'input>>{

fn rangeExpression_all(&self) ->  Vec<Rc<RangeExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn rangeExpression(&self, i: usize) -> Option<Rc<RangeExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn simpleIdentifier_all(&self) ->  Vec<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn simpleIdentifier(&self, i: usize) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> InfixFunctionCallContextAttrs<'input> for InfixFunctionCallContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn infixFunctionCall(&mut self,)
	-> Result<Rc<InfixFunctionCallContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InfixFunctionCallContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 168, RULE_infixFunctionCall);
        let mut _localctx: Rc<InfixFunctionCallContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule rangeExpression*/
			recog.base.set_state(2183);
			recog.rangeExpression()?;

			recog.base.set_state(2195);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(326,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule simpleIdentifier*/
					recog.base.set_state(2184);
					recog.simpleIdentifier()?;

					recog.base.set_state(2188);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2185);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2190);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule rangeExpression*/
					recog.base.set_state(2191);
					recog.rangeExpression()?;

					}
					} 
				}
				recog.base.set_state(2197);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(326,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- rangeExpression ----------------
pub type RangeExpressionContextAll<'input> = RangeExpressionContext<'input>;


pub type RangeExpressionContext<'input> = BaseParserRuleContext<'input,RangeExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct RangeExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for RangeExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for RangeExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_rangeExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_rangeExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for RangeExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_rangeExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for RangeExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_rangeExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_rangeExpression }
}
antlr_rust::tid!{RangeExpressionContextExt<'a>}

impl<'input> RangeExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RangeExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RangeExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RangeExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<RangeExpressionContextExt<'input>>{

fn additiveExpression_all(&self) ->  Vec<Rc<AdditiveExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn additiveExpression(&self, i: usize) -> Option<Rc<AdditiveExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token RANGE in current rule
fn RANGE_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RANGE, starting from 0.
/// Returns `None` if number of children corresponding to token RANGE is less or equal than `i`.
fn RANGE(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RANGE, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> RangeExpressionContextAttrs<'input> for RangeExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn rangeExpression(&mut self,)
	-> Result<Rc<RangeExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RangeExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 170, RULE_rangeExpression);
        let mut _localctx: Rc<RangeExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule additiveExpression*/
			recog.base.set_state(2198);
			recog.additiveExpression()?;

			recog.base.set_state(2209);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(328,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2199);
					recog.base.match_token(RANGE,&mut recog.err_handler)?;

					recog.base.set_state(2203);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2200);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2205);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule additiveExpression*/
					recog.base.set_state(2206);
					recog.additiveExpression()?;

					}
					} 
				}
				recog.base.set_state(2211);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(328,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- additiveExpression ----------------
pub type AdditiveExpressionContextAll<'input> = AdditiveExpressionContext<'input>;


pub type AdditiveExpressionContext<'input> = BaseParserRuleContext<'input,AdditiveExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct AdditiveExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AdditiveExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AdditiveExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_additiveExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_additiveExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AdditiveExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_additiveExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for AdditiveExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_additiveExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_additiveExpression }
}
antlr_rust::tid!{AdditiveExpressionContextExt<'a>}

impl<'input> AdditiveExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AdditiveExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AdditiveExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AdditiveExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AdditiveExpressionContextExt<'input>>{

fn multiplicativeExpression_all(&self) ->  Vec<Rc<MultiplicativeExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn multiplicativeExpression(&self, i: usize) -> Option<Rc<MultiplicativeExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn additiveOperator_all(&self) ->  Vec<Rc<AdditiveOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn additiveOperator(&self, i: usize) -> Option<Rc<AdditiveOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> AdditiveExpressionContextAttrs<'input> for AdditiveExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn additiveExpression(&mut self,)
	-> Result<Rc<AdditiveExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AdditiveExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 172, RULE_additiveExpression);
        let mut _localctx: Rc<AdditiveExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule multiplicativeExpression*/
			recog.base.set_state(2212);
			recog.multiplicativeExpression()?;

			recog.base.set_state(2224);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(330,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule additiveOperator*/
					recog.base.set_state(2213);
					recog.additiveOperator()?;

					recog.base.set_state(2217);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2214);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2219);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule multiplicativeExpression*/
					recog.base.set_state(2220);
					recog.multiplicativeExpression()?;

					}
					} 
				}
				recog.base.set_state(2226);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(330,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- multiplicativeExpression ----------------
pub type MultiplicativeExpressionContextAll<'input> = MultiplicativeExpressionContext<'input>;


pub type MultiplicativeExpressionContext<'input> = BaseParserRuleContext<'input,MultiplicativeExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct MultiplicativeExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for MultiplicativeExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for MultiplicativeExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_multiplicativeExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_multiplicativeExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for MultiplicativeExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_multiplicativeExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for MultiplicativeExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_multiplicativeExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_multiplicativeExpression }
}
antlr_rust::tid!{MultiplicativeExpressionContextExt<'a>}

impl<'input> MultiplicativeExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MultiplicativeExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MultiplicativeExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MultiplicativeExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<MultiplicativeExpressionContextExt<'input>>{

fn asExpression_all(&self) ->  Vec<Rc<AsExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn asExpression(&self, i: usize) -> Option<Rc<AsExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn multiplicativeOperator_all(&self) ->  Vec<Rc<MultiplicativeOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn multiplicativeOperator(&self, i: usize) -> Option<Rc<MultiplicativeOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> MultiplicativeExpressionContextAttrs<'input> for MultiplicativeExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn multiplicativeExpression(&mut self,)
	-> Result<Rc<MultiplicativeExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MultiplicativeExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 174, RULE_multiplicativeExpression);
        let mut _localctx: Rc<MultiplicativeExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule asExpression*/
			recog.base.set_state(2227);
			recog.asExpression()?;

			recog.base.set_state(2239);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(332,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule multiplicativeOperator*/
					recog.base.set_state(2228);
					recog.multiplicativeOperator()?;

					recog.base.set_state(2232);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2229);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2234);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule asExpression*/
					recog.base.set_state(2235);
					recog.asExpression()?;

					}
					} 
				}
				recog.base.set_state(2241);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(332,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- asExpression ----------------
pub type AsExpressionContextAll<'input> = AsExpressionContext<'input>;


pub type AsExpressionContext<'input> = BaseParserRuleContext<'input,AsExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct AsExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AsExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AsExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_asExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_asExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AsExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_asExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for AsExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_asExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_asExpression }
}
antlr_rust::tid!{AsExpressionContextExt<'a>}

impl<'input> AsExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AsExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AsExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AsExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AsExpressionContextExt<'input>>{

fn prefixUnaryExpression(&self) -> Option<Rc<PrefixUnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn asOperator_all(&self) ->  Vec<Rc<AsOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn asOperator(&self, i: usize) -> Option<Rc<AsOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn rustType_all(&self) ->  Vec<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn rustType(&self, i: usize) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> AsExpressionContextAttrs<'input> for AsExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn asExpression(&mut self,)
	-> Result<Rc<AsExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AsExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 176, RULE_asExpression);
        let mut _localctx: Rc<AsExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule prefixUnaryExpression*/
			recog.base.set_state(2242);
			recog.prefixUnaryExpression()?;

			recog.base.set_state(2260);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(335,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2246);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2243);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2248);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule asOperator*/
					recog.base.set_state(2249);
					recog.asOperator()?;

					recog.base.set_state(2253);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2250);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2255);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule rustType*/
					recog.base.set_state(2256);
					recog.rustType()?;

					}
					} 
				}
				recog.base.set_state(2262);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(335,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- prefixUnaryExpression ----------------
pub type PrefixUnaryExpressionContextAll<'input> = PrefixUnaryExpressionContext<'input>;


pub type PrefixUnaryExpressionContext<'input> = BaseParserRuleContext<'input,PrefixUnaryExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PrefixUnaryExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PrefixUnaryExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PrefixUnaryExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_prefixUnaryExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_prefixUnaryExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PrefixUnaryExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_prefixUnaryExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for PrefixUnaryExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_prefixUnaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_prefixUnaryExpression }
}
antlr_rust::tid!{PrefixUnaryExpressionContextExt<'a>}

impl<'input> PrefixUnaryExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrefixUnaryExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrefixUnaryExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrefixUnaryExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PrefixUnaryExpressionContextExt<'input>>{

fn postfixUnaryExpression(&self) -> Option<Rc<PostfixUnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn unaryPrefix_all(&self) ->  Vec<Rc<UnaryPrefixContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn unaryPrefix(&self, i: usize) -> Option<Rc<UnaryPrefixContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> PrefixUnaryExpressionContextAttrs<'input> for PrefixUnaryExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn prefixUnaryExpression(&mut self,)
	-> Result<Rc<PrefixUnaryExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrefixUnaryExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 178, RULE_prefixUnaryExpression);
        let mut _localctx: Rc<PrefixUnaryExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2266);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(336,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule unaryPrefix*/
					recog.base.set_state(2263);
					recog.unaryPrefix()?;

					}
					} 
				}
				recog.base.set_state(2268);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(336,&mut recog.base)?;
			}
			/*InvokeRule postfixUnaryExpression*/
			recog.base.set_state(2269);
			recog.postfixUnaryExpression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unaryPrefix ----------------
pub type UnaryPrefixContextAll<'input> = UnaryPrefixContext<'input>;


pub type UnaryPrefixContext<'input> = BaseParserRuleContext<'input,UnaryPrefixContextExt<'input>>;

#[derive(Clone)]
pub struct UnaryPrefixContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for UnaryPrefixContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for UnaryPrefixContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unaryPrefix(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_unaryPrefix(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for UnaryPrefixContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_unaryPrefix(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnaryPrefixContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unaryPrefix }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unaryPrefix }
}
antlr_rust::tid!{UnaryPrefixContextExt<'a>}

impl<'input> UnaryPrefixContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnaryPrefixContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnaryPrefixContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnaryPrefixContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<UnaryPrefixContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn label(&self) -> Option<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn prefixUnaryOperator(&self) -> Option<Rc<PrefixUnaryOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> UnaryPrefixContextAttrs<'input> for UnaryPrefixContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unaryPrefix(&mut self,)
	-> Result<Rc<UnaryPrefixContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnaryPrefixContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 180, RULE_unaryPrefix);
        let mut _localctx: Rc<UnaryPrefixContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2280);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT_NO_WS | AT_PRE_WS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(2271);
					recog.annotation()?;

					}
				}

			 FILE | FIELD | PROPERTY | GET | SET | RECEIVER | PARAM | SETPARAM | DELEGATE |
			 IMPORT | CONSTRUCTOR | BY | COMPANION | INIT | WHERE | CATCH | FINALLY |
			 OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED |
			 ANNOTATION | DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX |
			 EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT |
			 VARARG | NOINLINE | CROSSINLINE | REIFIED | EXPECT | ACTUAL | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule label*/
					recog.base.set_state(2272);
					recog.label()?;

					}
				}

			 ADD | SUB | INCR | DECR | EXCL_WS | EXCL_NO_WS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule prefixUnaryOperator*/
					recog.base.set_state(2273);
					recog.prefixUnaryOperator()?;

					recog.base.set_state(2277);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2274);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2279);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- postfixUnaryExpression ----------------
pub type PostfixUnaryExpressionContextAll<'input> = PostfixUnaryExpressionContext<'input>;


pub type PostfixUnaryExpressionContext<'input> = BaseParserRuleContext<'input,PostfixUnaryExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PostfixUnaryExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PostfixUnaryExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PostfixUnaryExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_postfixUnaryExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_postfixUnaryExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PostfixUnaryExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_postfixUnaryExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for PostfixUnaryExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_postfixUnaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_postfixUnaryExpression }
}
antlr_rust::tid!{PostfixUnaryExpressionContextExt<'a>}

impl<'input> PostfixUnaryExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PostfixUnaryExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PostfixUnaryExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PostfixUnaryExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PostfixUnaryExpressionContextExt<'input>>{

fn primaryExpression(&self) -> Option<Rc<PrimaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn postfixUnarySuffix_all(&self) ->  Vec<Rc<PostfixUnarySuffixContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn postfixUnarySuffix(&self, i: usize) -> Option<Rc<PostfixUnarySuffixContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> PostfixUnaryExpressionContextAttrs<'input> for PostfixUnaryExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn postfixUnaryExpression(&mut self,)
	-> Result<Rc<PostfixUnaryExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PostfixUnaryExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 182, RULE_postfixUnaryExpression);
        let mut _localctx: Rc<PostfixUnaryExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule primaryExpression*/
			recog.base.set_state(2282);
			recog.primaryExpression()?;

			recog.base.set_state(2286);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(339,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule postfixUnarySuffix*/
					recog.base.set_state(2283);
					recog.postfixUnarySuffix()?;

					}
					} 
				}
				recog.base.set_state(2288);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(339,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- postfixUnarySuffix ----------------
pub type PostfixUnarySuffixContextAll<'input> = PostfixUnarySuffixContext<'input>;


pub type PostfixUnarySuffixContext<'input> = BaseParserRuleContext<'input,PostfixUnarySuffixContextExt<'input>>;

#[derive(Clone)]
pub struct PostfixUnarySuffixContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PostfixUnarySuffixContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PostfixUnarySuffixContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_postfixUnarySuffix(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_postfixUnarySuffix(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PostfixUnarySuffixContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_postfixUnarySuffix(self);
	}
}

impl<'input> CustomRuleContext<'input> for PostfixUnarySuffixContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_postfixUnarySuffix }
	//fn type_rule_index() -> usize where Self: Sized { RULE_postfixUnarySuffix }
}
antlr_rust::tid!{PostfixUnarySuffixContextExt<'a>}

impl<'input> PostfixUnarySuffixContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PostfixUnarySuffixContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PostfixUnarySuffixContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PostfixUnarySuffixContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PostfixUnarySuffixContextExt<'input>>{

fn postfixUnaryOperator(&self) -> Option<Rc<PostfixUnaryOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn callSuffix(&self) -> Option<Rc<CallSuffixContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexingSuffix(&self) -> Option<Rc<IndexingSuffixContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn navigationSuffix(&self) -> Option<Rc<NavigationSuffixContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PostfixUnarySuffixContextAttrs<'input> for PostfixUnarySuffixContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn postfixUnarySuffix(&mut self,)
	-> Result<Rc<PostfixUnarySuffixContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PostfixUnarySuffixContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 184, RULE_postfixUnarySuffix);
        let mut _localctx: Rc<PostfixUnarySuffixContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2294);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(340,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule postfixUnaryOperator*/
					recog.base.set_state(2289);
					recog.postfixUnaryOperator()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule typeArguments*/
					recog.base.set_state(2290);
					recog.typeArguments()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule callSuffix*/
					recog.base.set_state(2291);
					recog.callSuffix()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule indexingSuffix*/
					recog.base.set_state(2292);
					recog.indexingSuffix()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule navigationSuffix*/
					recog.base.set_state(2293);
					recog.navigationSuffix()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- directlyAssignableExpression ----------------
pub type DirectlyAssignableExpressionContextAll<'input> = DirectlyAssignableExpressionContext<'input>;


pub type DirectlyAssignableExpressionContext<'input> = BaseParserRuleContext<'input,DirectlyAssignableExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct DirectlyAssignableExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for DirectlyAssignableExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for DirectlyAssignableExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_directlyAssignableExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_directlyAssignableExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for DirectlyAssignableExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_directlyAssignableExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for DirectlyAssignableExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_directlyAssignableExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_directlyAssignableExpression }
}
antlr_rust::tid!{DirectlyAssignableExpressionContextExt<'a>}

impl<'input> DirectlyAssignableExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DirectlyAssignableExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DirectlyAssignableExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DirectlyAssignableExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<DirectlyAssignableExpressionContextExt<'input>>{

fn postfixUnaryExpression(&self) -> Option<Rc<PostfixUnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn assignableSuffix(&self) -> Option<Rc<AssignableSuffixContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parenthesizedDirectlyAssignableExpression(&self) -> Option<Rc<ParenthesizedDirectlyAssignableExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DirectlyAssignableExpressionContextAttrs<'input> for DirectlyAssignableExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn directlyAssignableExpression(&mut self,)
	-> Result<Rc<DirectlyAssignableExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DirectlyAssignableExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 186, RULE_directlyAssignableExpression);
        let mut _localctx: Rc<DirectlyAssignableExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2301);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(341,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule postfixUnaryExpression*/
					recog.base.set_state(2296);
					recog.postfixUnaryExpression()?;

					/*InvokeRule assignableSuffix*/
					recog.base.set_state(2297);
					recog.assignableSuffix()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule simpleIdentifier*/
					recog.base.set_state(2299);
					recog.simpleIdentifier()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule parenthesizedDirectlyAssignableExpression*/
					recog.base.set_state(2300);
					recog.parenthesizedDirectlyAssignableExpression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parenthesizedDirectlyAssignableExpression ----------------
pub type ParenthesizedDirectlyAssignableExpressionContextAll<'input> = ParenthesizedDirectlyAssignableExpressionContext<'input>;


pub type ParenthesizedDirectlyAssignableExpressionContext<'input> = BaseParserRuleContext<'input,ParenthesizedDirectlyAssignableExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ParenthesizedDirectlyAssignableExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParenthesizedDirectlyAssignableExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParenthesizedDirectlyAssignableExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_parenthesizedDirectlyAssignableExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_parenthesizedDirectlyAssignableExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParenthesizedDirectlyAssignableExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parenthesizedDirectlyAssignableExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParenthesizedDirectlyAssignableExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parenthesizedDirectlyAssignableExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parenthesizedDirectlyAssignableExpression }
}
antlr_rust::tid!{ParenthesizedDirectlyAssignableExpressionContextExt<'a>}

impl<'input> ParenthesizedDirectlyAssignableExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParenthesizedDirectlyAssignableExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParenthesizedDirectlyAssignableExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParenthesizedDirectlyAssignableExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParenthesizedDirectlyAssignableExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn directlyAssignableExpression(&self) -> Option<Rc<DirectlyAssignableExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ParenthesizedDirectlyAssignableExpressionContextAttrs<'input> for ParenthesizedDirectlyAssignableExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parenthesizedDirectlyAssignableExpression(&mut self,)
	-> Result<Rc<ParenthesizedDirectlyAssignableExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParenthesizedDirectlyAssignableExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 188, RULE_parenthesizedDirectlyAssignableExpression);
        let mut _localctx: Rc<ParenthesizedDirectlyAssignableExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2303);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2307);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2304);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2309);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule directlyAssignableExpression*/
			recog.base.set_state(2310);
			recog.directlyAssignableExpression()?;

			recog.base.set_state(2314);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2311);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2316);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2317);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignableExpression ----------------
pub type AssignableExpressionContextAll<'input> = AssignableExpressionContext<'input>;


pub type AssignableExpressionContext<'input> = BaseParserRuleContext<'input,AssignableExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct AssignableExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AssignableExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AssignableExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_assignableExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_assignableExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AssignableExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_assignableExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for AssignableExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignableExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignableExpression }
}
antlr_rust::tid!{AssignableExpressionContextExt<'a>}

impl<'input> AssignableExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignableExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignableExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignableExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AssignableExpressionContextExt<'input>>{

fn prefixUnaryExpression(&self) -> Option<Rc<PrefixUnaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parenthesizedAssignableExpression(&self) -> Option<Rc<ParenthesizedAssignableExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AssignableExpressionContextAttrs<'input> for AssignableExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignableExpression(&mut self,)
	-> Result<Rc<AssignableExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignableExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 190, RULE_assignableExpression);
        let mut _localctx: Rc<AssignableExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2321);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(344,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule prefixUnaryExpression*/
					recog.base.set_state(2319);
					recog.prefixUnaryExpression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule parenthesizedAssignableExpression*/
					recog.base.set_state(2320);
					recog.parenthesizedAssignableExpression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parenthesizedAssignableExpression ----------------
pub type ParenthesizedAssignableExpressionContextAll<'input> = ParenthesizedAssignableExpressionContext<'input>;


pub type ParenthesizedAssignableExpressionContext<'input> = BaseParserRuleContext<'input,ParenthesizedAssignableExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ParenthesizedAssignableExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParenthesizedAssignableExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParenthesizedAssignableExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_parenthesizedAssignableExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_parenthesizedAssignableExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParenthesizedAssignableExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parenthesizedAssignableExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParenthesizedAssignableExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parenthesizedAssignableExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parenthesizedAssignableExpression }
}
antlr_rust::tid!{ParenthesizedAssignableExpressionContextExt<'a>}

impl<'input> ParenthesizedAssignableExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParenthesizedAssignableExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParenthesizedAssignableExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParenthesizedAssignableExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParenthesizedAssignableExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn assignableExpression(&self) -> Option<Rc<AssignableExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ParenthesizedAssignableExpressionContextAttrs<'input> for ParenthesizedAssignableExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parenthesizedAssignableExpression(&mut self,)
	-> Result<Rc<ParenthesizedAssignableExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParenthesizedAssignableExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 192, RULE_parenthesizedAssignableExpression);
        let mut _localctx: Rc<ParenthesizedAssignableExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2323);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2327);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2324);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2329);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule assignableExpression*/
			recog.base.set_state(2330);
			recog.assignableExpression()?;

			recog.base.set_state(2334);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2331);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2336);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2337);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignableSuffix ----------------
pub type AssignableSuffixContextAll<'input> = AssignableSuffixContext<'input>;


pub type AssignableSuffixContext<'input> = BaseParserRuleContext<'input,AssignableSuffixContextExt<'input>>;

#[derive(Clone)]
pub struct AssignableSuffixContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AssignableSuffixContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AssignableSuffixContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_assignableSuffix(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_assignableSuffix(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AssignableSuffixContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_assignableSuffix(self);
	}
}

impl<'input> CustomRuleContext<'input> for AssignableSuffixContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignableSuffix }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignableSuffix }
}
antlr_rust::tid!{AssignableSuffixContextExt<'a>}

impl<'input> AssignableSuffixContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignableSuffixContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignableSuffixContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignableSuffixContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AssignableSuffixContextExt<'input>>{

fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexingSuffix(&self) -> Option<Rc<IndexingSuffixContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn navigationSuffix(&self) -> Option<Rc<NavigationSuffixContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AssignableSuffixContextAttrs<'input> for AssignableSuffixContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignableSuffix(&mut self,)
	-> Result<Rc<AssignableSuffixContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignableSuffixContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 194, RULE_assignableSuffix);
        let mut _localctx: Rc<AssignableSuffixContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2342);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LANGLE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule typeArguments*/
					recog.base.set_state(2339);
					recog.typeArguments()?;

					}
				}

			 LSQUARE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule indexingSuffix*/
					recog.base.set_state(2340);
					recog.indexingSuffix()?;

					}
				}

			 NL | DOT | COLONCOLON | QUEST_NO_WS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule navigationSuffix*/
					recog.base.set_state(2341);
					recog.navigationSuffix()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- indexingSuffix ----------------
pub type IndexingSuffixContextAll<'input> = IndexingSuffixContext<'input>;


pub type IndexingSuffixContext<'input> = BaseParserRuleContext<'input,IndexingSuffixContextExt<'input>>;

#[derive(Clone)]
pub struct IndexingSuffixContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for IndexingSuffixContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for IndexingSuffixContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_indexingSuffix(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_indexingSuffix(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for IndexingSuffixContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_indexingSuffix(self);
	}
}

impl<'input> CustomRuleContext<'input> for IndexingSuffixContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_indexingSuffix }
	//fn type_rule_index() -> usize where Self: Sized { RULE_indexingSuffix }
}
antlr_rust::tid!{IndexingSuffixContextExt<'a>}

impl<'input> IndexingSuffixContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IndexingSuffixContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IndexingSuffixContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IndexingSuffixContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<IndexingSuffixContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LSQUARE
/// Returns `None` if there is no child corresponding to token LSQUARE
fn LSQUARE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LSQUARE, 0)
}
fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token RSQUARE
/// Returns `None` if there is no child corresponding to token RSQUARE
fn RSQUARE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RSQUARE, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> IndexingSuffixContextAttrs<'input> for IndexingSuffixContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn indexingSuffix(&mut self,)
	-> Result<Rc<IndexingSuffixContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IndexingSuffixContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 196, RULE_indexingSuffix);
        let mut _localctx: Rc<IndexingSuffixContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2344);
			recog.base.match_token(LSQUARE,&mut recog.err_handler)?;

			recog.base.set_state(2348);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2345);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2350);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule expression*/
			recog.base.set_state(2351);
			recog.expression()?;

			recog.base.set_state(2368);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(351,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2355);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2352);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2357);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2358);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(2362);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2359);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2364);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule expression*/
					recog.base.set_state(2365);
					recog.expression()?;

					}
					} 
				}
				recog.base.set_state(2370);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(351,&mut recog.base)?;
			}
			recog.base.set_state(2378);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(353,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2374);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2371);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2376);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2377);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2383);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2380);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2385);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2386);
			recog.base.match_token(RSQUARE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- navigationSuffix ----------------
pub type NavigationSuffixContextAll<'input> = NavigationSuffixContext<'input>;


pub type NavigationSuffixContext<'input> = BaseParserRuleContext<'input,NavigationSuffixContextExt<'input>>;

#[derive(Clone)]
pub struct NavigationSuffixContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for NavigationSuffixContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for NavigationSuffixContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_navigationSuffix(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_navigationSuffix(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for NavigationSuffixContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_navigationSuffix(self);
	}
}

impl<'input> CustomRuleContext<'input> for NavigationSuffixContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_navigationSuffix }
	//fn type_rule_index() -> usize where Self: Sized { RULE_navigationSuffix }
}
antlr_rust::tid!{NavigationSuffixContextExt<'a>}

impl<'input> NavigationSuffixContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NavigationSuffixContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NavigationSuffixContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NavigationSuffixContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<NavigationSuffixContextExt<'input>>{

fn memberAccessOperator(&self) -> Option<Rc<MemberAccessOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parenthesizedExpression(&self) -> Option<Rc<ParenthesizedExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token CLASS
/// Returns `None` if there is no child corresponding to token CLASS
fn CLASS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CLASS, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> NavigationSuffixContextAttrs<'input> for NavigationSuffixContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn navigationSuffix(&mut self,)
	-> Result<Rc<NavigationSuffixContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NavigationSuffixContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 198, RULE_navigationSuffix);
        let mut _localctx: Rc<NavigationSuffixContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule memberAccessOperator*/
			recog.base.set_state(2388);
			recog.memberAccessOperator()?;

			recog.base.set_state(2392);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2389);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2394);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2398);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 FILE | FIELD | PROPERTY | GET | SET | RECEIVER | PARAM | SETPARAM | DELEGATE |
			 IMPORT | CONSTRUCTOR | BY | COMPANION | INIT | WHERE | CATCH | FINALLY |
			 OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED |
			 ANNOTATION | DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX |
			 EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT |
			 VARARG | NOINLINE | CROSSINLINE | REIFIED | EXPECT | ACTUAL | Identifier 
				=> {
					{
					/*InvokeRule simpleIdentifier*/
					recog.base.set_state(2395);
					recog.simpleIdentifier()?;

					}
				}

			 LPAREN 
				=> {
					{
					/*InvokeRule parenthesizedExpression*/
					recog.base.set_state(2396);
					recog.parenthesizedExpression()?;

					}
				}

			 CLASS 
				=> {
					{
					recog.base.set_state(2397);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- callSuffix ----------------
pub type CallSuffixContextAll<'input> = CallSuffixContext<'input>;


pub type CallSuffixContext<'input> = BaseParserRuleContext<'input,CallSuffixContextExt<'input>>;

#[derive(Clone)]
pub struct CallSuffixContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for CallSuffixContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for CallSuffixContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_callSuffix(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_callSuffix(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for CallSuffixContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_callSuffix(self);
	}
}

impl<'input> CustomRuleContext<'input> for CallSuffixContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_callSuffix }
	//fn type_rule_index() -> usize where Self: Sized { RULE_callSuffix }
}
antlr_rust::tid!{CallSuffixContextExt<'a>}

impl<'input> CallSuffixContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CallSuffixContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CallSuffixContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CallSuffixContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<CallSuffixContextExt<'input>>{

fn annotatedLambda(&self) -> Option<Rc<AnnotatedLambdaContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn valueArguments(&self) -> Option<Rc<ValueArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeArguments(&self) -> Option<Rc<TypeArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CallSuffixContextAttrs<'input> for CallSuffixContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn callSuffix(&mut self,)
	-> Result<Rc<CallSuffixContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CallSuffixContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 200, RULE_callSuffix);
        let mut _localctx: Rc<CallSuffixContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2401);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LANGLE {
				{
				/*InvokeRule typeArguments*/
				recog.base.set_state(2400);
				recog.typeArguments()?;

				}
			}

			recog.base.set_state(2408);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(359,&mut recog.base)? {
				1 =>{
					{
					recog.base.set_state(2404);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LPAREN {
						{
						/*InvokeRule valueArguments*/
						recog.base.set_state(2403);
						recog.valueArguments()?;

						}
					}

					/*InvokeRule annotatedLambda*/
					recog.base.set_state(2406);
					recog.annotatedLambda()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule valueArguments*/
					recog.base.set_state(2407);
					recog.valueArguments()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotatedLambda ----------------
pub type AnnotatedLambdaContextAll<'input> = AnnotatedLambdaContext<'input>;


pub type AnnotatedLambdaContext<'input> = BaseParserRuleContext<'input,AnnotatedLambdaContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotatedLambdaContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AnnotatedLambdaContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AnnotatedLambdaContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotatedLambda(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_annotatedLambda(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AnnotatedLambdaContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_annotatedLambda(self);
	}
}

impl<'input> CustomRuleContext<'input> for AnnotatedLambdaContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotatedLambda }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotatedLambda }
}
antlr_rust::tid!{AnnotatedLambdaContextExt<'a>}

impl<'input> AnnotatedLambdaContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotatedLambdaContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotatedLambdaContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotatedLambdaContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AnnotatedLambdaContextExt<'input>>{

fn lambdaLiteral(&self) -> Option<Rc<LambdaLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn label(&self) -> Option<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> AnnotatedLambdaContextAttrs<'input> for AnnotatedLambdaContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotatedLambda(&mut self,)
	-> Result<Rc<AnnotatedLambdaContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotatedLambdaContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 202, RULE_annotatedLambda);
        let mut _localctx: Rc<AnnotatedLambdaContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2413);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT_NO_WS || _la==AT_PRE_WS {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(2410);
				recog.annotation()?;

				}
				}
				recog.base.set_state(2415);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2417);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if ((((_la - 61)) & !0x3f) == 0 && ((1usize << (_la - 61)) & ((1usize << (FILE - 61)) | (1usize << (FIELD - 61)) | (1usize << (PROPERTY - 61)) | (1usize << (GET - 61)) | (1usize << (SET - 61)) | (1usize << (RECEIVER - 61)) | (1usize << (PARAM - 61)) | (1usize << (SETPARAM - 61)) | (1usize << (DELEGATE - 61)) | (1usize << (IMPORT - 61)) | (1usize << (CONSTRUCTOR - 61)) | (1usize << (BY - 61)) | (1usize << (COMPANION - 61)) | (1usize << (INIT - 61)) | (1usize << (WHERE - 61)) | (1usize << (CATCH - 61)) | (1usize << (FINALLY - 61)) | (1usize << (OUT - 61)) | (1usize << (DYNAMIC - 61)) | (1usize << (PUBLIC - 61)) | (1usize << (PRIVATE - 61)) | (1usize << (PROTECTED - 61)) | (1usize << (INTERNAL - 61)) | (1usize << (ENUM - 61)) | (1usize << (SEALED - 61)) | (1usize << (ANNOTATION - 61)) | (1usize << (DATA - 61)) | (1usize << (INNER - 61)) | (1usize << (VALUE - 61)) | (1usize << (TAILREC - 61)) | (1usize << (OPERATOR - 61)) | (1usize << (INLINE - 61)) | (1usize << (INFIX - 61)) | (1usize << (EXTERNAL - 61)) | (1usize << (SUSPEND - 61)) | (1usize << (OVERRIDE - 61)) | (1usize << (ABSTRACT - 61)))) != 0) || ((((_la - 125)) & !0x3f) == 0 && ((1usize << (_la - 125)) & ((1usize << (FINAL - 125)) | (1usize << (OPEN - 125)) | (1usize << (CONST - 125)) | (1usize << (LATEINIT - 125)) | (1usize << (VARARG - 125)) | (1usize << (NOINLINE - 125)) | (1usize << (CROSSINLINE - 125)) | (1usize << (REIFIED - 125)) | (1usize << (EXPECT - 125)) | (1usize << (ACTUAL - 125)) | (1usize << (Identifier - 125)))) != 0) {
				{
				/*InvokeRule label*/
				recog.base.set_state(2416);
				recog.label()?;

				}
			}

			recog.base.set_state(2422);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2419);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2424);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule lambdaLiteral*/
			recog.base.set_state(2425);
			recog.lambdaLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeArguments ----------------
pub type TypeArgumentsContextAll<'input> = TypeArgumentsContext<'input>;


pub type TypeArgumentsContext<'input> = BaseParserRuleContext<'input,TypeArgumentsContextExt<'input>>;

#[derive(Clone)]
pub struct TypeArgumentsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeArgumentsContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeArgumentsContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeArguments(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_typeArguments(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeArgumentsContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeArguments(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeArgumentsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeArguments }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeArguments }
}
antlr_rust::tid!{TypeArgumentsContextExt<'a>}

impl<'input> TypeArgumentsContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeArgumentsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeArgumentsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeArgumentsContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeArgumentsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LANGLE
/// Returns `None` if there is no child corresponding to token LANGLE
fn LANGLE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LANGLE, 0)
}
fn typeProjection_all(&self) ->  Vec<Rc<TypeProjectionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeProjection(&self, i: usize) -> Option<Rc<TypeProjectionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token RANGLE
/// Returns `None` if there is no child corresponding to token RANGLE
fn RANGLE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RANGLE, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> TypeArgumentsContextAttrs<'input> for TypeArgumentsContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeArguments(&mut self,)
	-> Result<Rc<TypeArgumentsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeArgumentsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 204, RULE_typeArguments);
        let mut _localctx: Rc<TypeArgumentsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2427);
			recog.base.match_token(LANGLE,&mut recog.err_handler)?;

			recog.base.set_state(2431);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2428);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2433);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule typeProjection*/
			recog.base.set_state(2434);
			recog.typeProjection()?;

			recog.base.set_state(2451);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(366,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2438);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2435);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2440);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2441);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(2445);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2442);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2447);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeProjection*/
					recog.base.set_state(2448);
					recog.typeProjection()?;

					}
					} 
				}
				recog.base.set_state(2453);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(366,&mut recog.base)?;
			}
			recog.base.set_state(2461);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(368,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2457);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2454);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2459);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2460);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2466);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2463);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2468);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2469);
			recog.base.match_token(RANGLE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- valueArguments ----------------
pub type ValueArgumentsContextAll<'input> = ValueArgumentsContext<'input>;


pub type ValueArgumentsContext<'input> = BaseParserRuleContext<'input,ValueArgumentsContextExt<'input>>;

#[derive(Clone)]
pub struct ValueArgumentsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ValueArgumentsContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ValueArgumentsContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_valueArguments(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_valueArguments(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ValueArgumentsContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_valueArguments(self);
	}
}

impl<'input> CustomRuleContext<'input> for ValueArgumentsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_valueArguments }
	//fn type_rule_index() -> usize where Self: Sized { RULE_valueArguments }
}
antlr_rust::tid!{ValueArgumentsContextExt<'a>}

impl<'input> ValueArgumentsContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ValueArgumentsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ValueArgumentsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ValueArgumentsContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ValueArgumentsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn valueArgument_all(&self) ->  Vec<Rc<ValueArgumentContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn valueArgument(&self, i: usize) -> Option<Rc<ValueArgumentContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> ValueArgumentsContextAttrs<'input> for ValueArgumentsContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn valueArguments(&mut self,)
	-> Result<Rc<ValueArgumentsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ValueArgumentsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 206, RULE_valueArguments);
        let mut _localctx: Rc<ValueArgumentsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2471);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2475);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(370,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2472);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2477);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(370,&mut recog.base)?;
			}
			recog.base.set_state(2513);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << NL) | (1usize << LPAREN) | (1usize << LSQUARE) | (1usize << LCURL) | (1usize << MULT) | (1usize << ADD) | (1usize << SUB) | (1usize << INCR) | (1usize << DECR) | (1usize << EXCL_WS) | (1usize << EXCL_NO_WS) | (1usize << COLONCOLON) | (1usize << AT_NO_WS) | (1usize << AT_PRE_WS) | (1usize << RETURN_AT) | (1usize << CONTINUE_AT) | (1usize << BREAK_AT) | (1usize << THIS_AT) | (1usize << SUPER_AT) | (1usize << FILE) | (1usize << FIELD) | (1usize << PROPERTY))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (GET - 64)) | (1usize << (SET - 64)) | (1usize << (RECEIVER - 64)) | (1usize << (PARAM - 64)) | (1usize << (SETPARAM - 64)) | (1usize << (DELEGATE - 64)) | (1usize << (IMPORT - 64)) | (1usize << (FUN - 64)) | (1usize << (OBJECT - 64)) | (1usize << (CONSTRUCTOR - 64)) | (1usize << (BY - 64)) | (1usize << (COMPANION - 64)) | (1usize << (INIT - 64)) | (1usize << (THIS - 64)) | (1usize << (SUPER - 64)) | (1usize << (WHERE - 64)) | (1usize << (IF - 64)) | (1usize << (WHEN - 64)) | (1usize << (TRY - 64)) | (1usize << (CATCH - 64)) | (1usize << (FINALLY - 64)) | (1usize << (THROW - 64)) | (1usize << (RETURN - 64)) | (1usize << (CONTINUE - 64)) | (1usize << (BREAK - 64)) | (1usize << (OUT - 64)) | (1usize << (DYNAMIC - 64)) | (1usize << (PUBLIC - 64)) | (1usize << (PRIVATE - 64)) | (1usize << (PROTECTED - 64)) | (1usize << (INTERNAL - 64)) | (1usize << (ENUM - 64)) | (1usize << (SEALED - 64)) | (1usize << (ANNOTATION - 64)) | (1usize << (DATA - 64)) | (1usize << (INNER - 64)) | (1usize << (VALUE - 64)) | (1usize << (TAILREC - 64)) | (1usize << (OPERATOR - 64)) | (1usize << (INLINE - 64)) | (1usize << (INFIX - 64)) | (1usize << (EXTERNAL - 64)) | (1usize << (SUSPEND - 64)) | (1usize << (OVERRIDE - 64)) | (1usize << (ABSTRACT - 64)) | (1usize << (FINAL - 64)) | (1usize << (OPEN - 64)) | (1usize << (CONST - 64)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (LATEINIT - 128)) | (1usize << (VARARG - 128)) | (1usize << (NOINLINE - 128)) | (1usize << (CROSSINLINE - 128)) | (1usize << (REIFIED - 128)) | (1usize << (EXPECT - 128)) | (1usize << (ACTUAL - 128)) | (1usize << (RealLiteral - 128)) | (1usize << (IntegerLiteral - 128)) | (1usize << (HexLiteral - 128)) | (1usize << (BinLiteral - 128)) | (1usize << (UnsignedLiteral - 128)) | (1usize << (LongLiteral - 128)) | (1usize << (BooleanLiteral - 128)) | (1usize << (NullLiteral - 128)) | (1usize << (CharacterLiteral - 128)) | (1usize << (Identifier - 128)) | (1usize << (QUOTE_OPEN - 128)) | (1usize << (TRIPLE_QUOTE_OPEN - 128)))) != 0) {
				{
				/*InvokeRule valueArgument*/
				recog.base.set_state(2478);
				recog.valueArgument()?;

				recog.base.set_state(2495);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(373,&mut recog.base)?;
				while { _alt!=2 && _alt!=INVALID_ALT } {
					if _alt==1 {
						{
						{
						recog.base.set_state(2482);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(2479);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(2484);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(2485);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						recog.base.set_state(2489);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(372,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(2486);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								} 
							}
							recog.base.set_state(2491);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(372,&mut recog.base)?;
						}
						/*InvokeRule valueArgument*/
						recog.base.set_state(2492);
						recog.valueArgument()?;

						}
						} 
					}
					recog.base.set_state(2497);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(373,&mut recog.base)?;
				}
				recog.base.set_state(2505);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(375,&mut recog.base)? {
					x if x == 1=>{
						{
						recog.base.set_state(2501);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(2498);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(2503);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(2504);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						}
					}

					_ => {}
				}
				recog.base.set_state(2510);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				while _la==NL {
					{
					{
					recog.base.set_state(2507);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					}
					recog.base.set_state(2512);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
				}
				}
			}

			recog.base.set_state(2515);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- valueArgument ----------------
pub type ValueArgumentContextAll<'input> = ValueArgumentContext<'input>;


pub type ValueArgumentContext<'input> = BaseParserRuleContext<'input,ValueArgumentContextExt<'input>>;

#[derive(Clone)]
pub struct ValueArgumentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ValueArgumentContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ValueArgumentContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_valueArgument(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_valueArgument(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ValueArgumentContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_valueArgument(self);
	}
}

impl<'input> CustomRuleContext<'input> for ValueArgumentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_valueArgument }
	//fn type_rule_index() -> usize where Self: Sized { RULE_valueArgument }
}
antlr_rust::tid!{ValueArgumentContextExt<'a>}

impl<'input> ValueArgumentContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ValueArgumentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ValueArgumentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ValueArgumentContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ValueArgumentContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ASSIGNMENT
fn ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ASSIGNMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token MULT
/// Returns `None` if there is no child corresponding to token MULT
fn MULT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MULT, 0)
}

}

impl<'input> ValueArgumentContextAttrs<'input> for ValueArgumentContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn valueArgument(&mut self,)
	-> Result<Rc<ValueArgumentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ValueArgumentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 208, RULE_valueArgument);
        let mut _localctx: Rc<ValueArgumentContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2518);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(378,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule annotation*/
					recog.base.set_state(2517);
					recog.annotation()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2523);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(379,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2520);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2525);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(379,&mut recog.base)?;
			}
			recog.base.set_state(2540);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(382,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule simpleIdentifier*/
					recog.base.set_state(2526);
					recog.simpleIdentifier()?;

					recog.base.set_state(2530);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2527);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2532);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2533);
					recog.base.match_token(ASSIGNMENT,&mut recog.err_handler)?;

					recog.base.set_state(2537);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(381,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2534);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2539);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(381,&mut recog.base)?;
					}
					}
				}

				_ => {}
			}
			recog.base.set_state(2543);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==MULT {
				{
				recog.base.set_state(2542);
				recog.base.match_token(MULT,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(2548);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2545);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2550);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule expression*/
			recog.base.set_state(2551);
			recog.expression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primaryExpression ----------------
pub type PrimaryExpressionContextAll<'input> = PrimaryExpressionContext<'input>;


pub type PrimaryExpressionContext<'input> = BaseParserRuleContext<'input,PrimaryExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PrimaryExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PrimaryExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_primaryExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_primaryExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PrimaryExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_primaryExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for PrimaryExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}
antlr_rust::tid!{PrimaryExpressionContextExt<'a>}

impl<'input> PrimaryExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimaryExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PrimaryExpressionContextExt<'input>>{

fn parenthesizedExpression(&self) -> Option<Rc<ParenthesizedExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn literalConstant(&self) -> Option<Rc<LiteralConstantContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn callableReference(&self) -> Option<Rc<CallableReferenceContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionLiteral(&self) -> Option<Rc<FunctionLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn objectLiteral(&self) -> Option<Rc<ObjectLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn collectionLiteral(&self) -> Option<Rc<CollectionLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn thisExpression(&self) -> Option<Rc<ThisExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn superExpression(&self) -> Option<Rc<SuperExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifExpression(&self) -> Option<Rc<IfExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn whenExpression(&self) -> Option<Rc<WhenExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn tryExpression(&self) -> Option<Rc<TryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn jumpExpression(&self) -> Option<Rc<JumpExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PrimaryExpressionContextAttrs<'input> for PrimaryExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primaryExpression(&mut self,)
	-> Result<Rc<PrimaryExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimaryExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 210, RULE_primaryExpression);
        let mut _localctx: Rc<PrimaryExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2567);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(385,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule parenthesizedExpression*/
					recog.base.set_state(2553);
					recog.parenthesizedExpression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule simpleIdentifier*/
					recog.base.set_state(2554);
					recog.simpleIdentifier()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule literalConstant*/
					recog.base.set_state(2555);
					recog.literalConstant()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule stringLiteral*/
					recog.base.set_state(2556);
					recog.stringLiteral()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule callableReference*/
					recog.base.set_state(2557);
					recog.callableReference()?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule functionLiteral*/
					recog.base.set_state(2558);
					recog.functionLiteral()?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule objectLiteral*/
					recog.base.set_state(2559);
					recog.objectLiteral()?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule collectionLiteral*/
					recog.base.set_state(2560);
					recog.collectionLiteral()?;

					}
				}
			,
				9 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule thisExpression*/
					recog.base.set_state(2561);
					recog.thisExpression()?;

					}
				}
			,
				10 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					/*InvokeRule superExpression*/
					recog.base.set_state(2562);
					recog.superExpression()?;

					}
				}
			,
				11 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					/*InvokeRule ifExpression*/
					recog.base.set_state(2563);
					recog.ifExpression()?;

					}
				}
			,
				12 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 12);
					recog.base.enter_outer_alt(None, 12);
					{
					/*InvokeRule whenExpression*/
					recog.base.set_state(2564);
					recog.whenExpression()?;

					}
				}
			,
				13 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 13);
					recog.base.enter_outer_alt(None, 13);
					{
					/*InvokeRule tryExpression*/
					recog.base.set_state(2565);
					recog.tryExpression()?;

					}
				}
			,
				14 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 14);
					recog.base.enter_outer_alt(None, 14);
					{
					/*InvokeRule jumpExpression*/
					recog.base.set_state(2566);
					recog.jumpExpression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parenthesizedExpression ----------------
pub type ParenthesizedExpressionContextAll<'input> = ParenthesizedExpressionContext<'input>;


pub type ParenthesizedExpressionContext<'input> = BaseParserRuleContext<'input,ParenthesizedExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ParenthesizedExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParenthesizedExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParenthesizedExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_parenthesizedExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_parenthesizedExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParenthesizedExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parenthesizedExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParenthesizedExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parenthesizedExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parenthesizedExpression }
}
antlr_rust::tid!{ParenthesizedExpressionContextExt<'a>}

impl<'input> ParenthesizedExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParenthesizedExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParenthesizedExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParenthesizedExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParenthesizedExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ParenthesizedExpressionContextAttrs<'input> for ParenthesizedExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parenthesizedExpression(&mut self,)
	-> Result<Rc<ParenthesizedExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParenthesizedExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 212, RULE_parenthesizedExpression);
        let mut _localctx: Rc<ParenthesizedExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2569);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2573);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2570);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2575);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule expression*/
			recog.base.set_state(2576);
			recog.expression()?;

			recog.base.set_state(2580);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2577);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2582);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2583);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- collectionLiteral ----------------
pub type CollectionLiteralContextAll<'input> = CollectionLiteralContext<'input>;


pub type CollectionLiteralContext<'input> = BaseParserRuleContext<'input,CollectionLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct CollectionLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for CollectionLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for CollectionLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_collectionLiteral(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_collectionLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for CollectionLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_collectionLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for CollectionLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_collectionLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_collectionLiteral }
}
antlr_rust::tid!{CollectionLiteralContextExt<'a>}

impl<'input> CollectionLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CollectionLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CollectionLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CollectionLiteralContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<CollectionLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LSQUARE
/// Returns `None` if there is no child corresponding to token LSQUARE
fn LSQUARE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LSQUARE, 0)
}
/// Retrieves first TerminalNode corresponding to token RSQUARE
/// Returns `None` if there is no child corresponding to token RSQUARE
fn RSQUARE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RSQUARE, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> CollectionLiteralContextAttrs<'input> for CollectionLiteralContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn collectionLiteral(&mut self,)
	-> Result<Rc<CollectionLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CollectionLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 214, RULE_collectionLiteral);
        let mut _localctx: Rc<CollectionLiteralContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2585);
			recog.base.match_token(LSQUARE,&mut recog.err_handler)?;

			recog.base.set_state(2589);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2586);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2591);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2627);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << LPAREN) | (1usize << LSQUARE) | (1usize << LCURL) | (1usize << ADD) | (1usize << SUB) | (1usize << INCR) | (1usize << DECR) | (1usize << EXCL_WS) | (1usize << EXCL_NO_WS) | (1usize << COLONCOLON) | (1usize << AT_NO_WS) | (1usize << AT_PRE_WS) | (1usize << RETURN_AT) | (1usize << CONTINUE_AT) | (1usize << BREAK_AT) | (1usize << THIS_AT) | (1usize << SUPER_AT) | (1usize << FILE) | (1usize << FIELD) | (1usize << PROPERTY))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (GET - 64)) | (1usize << (SET - 64)) | (1usize << (RECEIVER - 64)) | (1usize << (PARAM - 64)) | (1usize << (SETPARAM - 64)) | (1usize << (DELEGATE - 64)) | (1usize << (IMPORT - 64)) | (1usize << (FUN - 64)) | (1usize << (OBJECT - 64)) | (1usize << (CONSTRUCTOR - 64)) | (1usize << (BY - 64)) | (1usize << (COMPANION - 64)) | (1usize << (INIT - 64)) | (1usize << (THIS - 64)) | (1usize << (SUPER - 64)) | (1usize << (WHERE - 64)) | (1usize << (IF - 64)) | (1usize << (WHEN - 64)) | (1usize << (TRY - 64)) | (1usize << (CATCH - 64)) | (1usize << (FINALLY - 64)) | (1usize << (THROW - 64)) | (1usize << (RETURN - 64)) | (1usize << (CONTINUE - 64)) | (1usize << (BREAK - 64)) | (1usize << (OUT - 64)) | (1usize << (DYNAMIC - 64)) | (1usize << (PUBLIC - 64)) | (1usize << (PRIVATE - 64)) | (1usize << (PROTECTED - 64)) | (1usize << (INTERNAL - 64)) | (1usize << (ENUM - 64)) | (1usize << (SEALED - 64)) | (1usize << (ANNOTATION - 64)) | (1usize << (DATA - 64)) | (1usize << (INNER - 64)) | (1usize << (VALUE - 64)) | (1usize << (TAILREC - 64)) | (1usize << (OPERATOR - 64)) | (1usize << (INLINE - 64)) | (1usize << (INFIX - 64)) | (1usize << (EXTERNAL - 64)) | (1usize << (SUSPEND - 64)) | (1usize << (OVERRIDE - 64)) | (1usize << (ABSTRACT - 64)) | (1usize << (FINAL - 64)) | (1usize << (OPEN - 64)) | (1usize << (CONST - 64)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (LATEINIT - 128)) | (1usize << (VARARG - 128)) | (1usize << (NOINLINE - 128)) | (1usize << (CROSSINLINE - 128)) | (1usize << (REIFIED - 128)) | (1usize << (EXPECT - 128)) | (1usize << (ACTUAL - 128)) | (1usize << (RealLiteral - 128)) | (1usize << (IntegerLiteral - 128)) | (1usize << (HexLiteral - 128)) | (1usize << (BinLiteral - 128)) | (1usize << (UnsignedLiteral - 128)) | (1usize << (LongLiteral - 128)) | (1usize << (BooleanLiteral - 128)) | (1usize << (NullLiteral - 128)) | (1usize << (CharacterLiteral - 128)) | (1usize << (Identifier - 128)) | (1usize << (QUOTE_OPEN - 128)) | (1usize << (TRIPLE_QUOTE_OPEN - 128)))) != 0) {
				{
				/*InvokeRule expression*/
				recog.base.set_state(2592);
				recog.expression()?;

				recog.base.set_state(2609);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(391,&mut recog.base)?;
				while { _alt!=2 && _alt!=INVALID_ALT } {
					if _alt==1 {
						{
						{
						recog.base.set_state(2596);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(2593);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(2598);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(2599);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						recog.base.set_state(2603);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(2600);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(2605);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						/*InvokeRule expression*/
						recog.base.set_state(2606);
						recog.expression()?;

						}
						} 
					}
					recog.base.set_state(2611);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(391,&mut recog.base)?;
				}
				recog.base.set_state(2619);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(393,&mut recog.base)? {
					x if x == 1=>{
						{
						recog.base.set_state(2615);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==NL {
							{
							{
							recog.base.set_state(2612);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							}
							recog.base.set_state(2617);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(2618);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						}
					}

					_ => {}
				}
				recog.base.set_state(2624);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				while _la==NL {
					{
					{
					recog.base.set_state(2621);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					}
					recog.base.set_state(2626);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
				}
				}
			}

			recog.base.set_state(2629);
			recog.base.match_token(RSQUARE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- literalConstant ----------------
pub type LiteralConstantContextAll<'input> = LiteralConstantContext<'input>;


pub type LiteralConstantContext<'input> = BaseParserRuleContext<'input,LiteralConstantContextExt<'input>>;

#[derive(Clone)]
pub struct LiteralConstantContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for LiteralConstantContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for LiteralConstantContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_literalConstant(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_literalConstant(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for LiteralConstantContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_literalConstant(self);
	}
}

impl<'input> CustomRuleContext<'input> for LiteralConstantContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_literalConstant }
	//fn type_rule_index() -> usize where Self: Sized { RULE_literalConstant }
}
antlr_rust::tid!{LiteralConstantContextExt<'a>}

impl<'input> LiteralConstantContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LiteralConstantContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LiteralConstantContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LiteralConstantContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<LiteralConstantContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token BooleanLiteral
/// Returns `None` if there is no child corresponding to token BooleanLiteral
fn BooleanLiteral(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(BooleanLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token IntegerLiteral
/// Returns `None` if there is no child corresponding to token IntegerLiteral
fn IntegerLiteral(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(IntegerLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token HexLiteral
/// Returns `None` if there is no child corresponding to token HexLiteral
fn HexLiteral(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(HexLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token BinLiteral
/// Returns `None` if there is no child corresponding to token BinLiteral
fn BinLiteral(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(BinLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token CharacterLiteral
/// Returns `None` if there is no child corresponding to token CharacterLiteral
fn CharacterLiteral(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CharacterLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token RealLiteral
/// Returns `None` if there is no child corresponding to token RealLiteral
fn RealLiteral(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RealLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token NullLiteral
/// Returns `None` if there is no child corresponding to token NullLiteral
fn NullLiteral(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NullLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token LongLiteral
/// Returns `None` if there is no child corresponding to token LongLiteral
fn LongLiteral(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LongLiteral, 0)
}
/// Retrieves first TerminalNode corresponding to token UnsignedLiteral
/// Returns `None` if there is no child corresponding to token UnsignedLiteral
fn UnsignedLiteral(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(UnsignedLiteral, 0)
}

}

impl<'input> LiteralConstantContextAttrs<'input> for LiteralConstantContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn literalConstant(&mut self,)
	-> Result<Rc<LiteralConstantContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LiteralConstantContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 216, RULE_literalConstant);
        let mut _localctx: Rc<LiteralConstantContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2631);
			_la = recog.base.input.la(1);
			if { !(((((_la - 135)) & !0x3f) == 0 && ((1usize << (_la - 135)) & ((1usize << (RealLiteral - 135)) | (1usize << (IntegerLiteral - 135)) | (1usize << (HexLiteral - 135)) | (1usize << (BinLiteral - 135)) | (1usize << (UnsignedLiteral - 135)) | (1usize << (LongLiteral - 135)) | (1usize << (BooleanLiteral - 135)) | (1usize << (NullLiteral - 135)) | (1usize << (CharacterLiteral - 135)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- stringLiteral ----------------
pub type StringLiteralContextAll<'input> = StringLiteralContext<'input>;


pub type StringLiteralContext<'input> = BaseParserRuleContext<'input,StringLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct StringLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for StringLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for StringLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_stringLiteral(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_stringLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for StringLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_stringLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for StringLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_stringLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_stringLiteral }
}
antlr_rust::tid!{StringLiteralContextExt<'a>}

impl<'input> StringLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StringLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StringLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StringLiteralContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<StringLiteralContextExt<'input>>{

fn lineStringLiteral(&self) -> Option<Rc<LineStringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn multiLineStringLiteral(&self) -> Option<Rc<MultiLineStringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> StringLiteralContextAttrs<'input> for StringLiteralContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn stringLiteral(&mut self,)
	-> Result<Rc<StringLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StringLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 218, RULE_stringLiteral);
        let mut _localctx: Rc<StringLiteralContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2635);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 QUOTE_OPEN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule lineStringLiteral*/
					recog.base.set_state(2633);
					recog.lineStringLiteral()?;

					}
				}

			 TRIPLE_QUOTE_OPEN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule multiLineStringLiteral*/
					recog.base.set_state(2634);
					recog.multiLineStringLiteral()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lineStringLiteral ----------------
pub type LineStringLiteralContextAll<'input> = LineStringLiteralContext<'input>;


pub type LineStringLiteralContext<'input> = BaseParserRuleContext<'input,LineStringLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct LineStringLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for LineStringLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for LineStringLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lineStringLiteral(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_lineStringLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for LineStringLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_lineStringLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for LineStringLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lineStringLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lineStringLiteral }
}
antlr_rust::tid!{LineStringLiteralContextExt<'a>}

impl<'input> LineStringLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LineStringLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LineStringLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LineStringLiteralContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<LineStringLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token QUOTE_OPEN
/// Returns `None` if there is no child corresponding to token QUOTE_OPEN
fn QUOTE_OPEN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(QUOTE_OPEN, 0)
}
/// Retrieves first TerminalNode corresponding to token QUOTE_CLOSE
/// Returns `None` if there is no child corresponding to token QUOTE_CLOSE
fn QUOTE_CLOSE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(QUOTE_CLOSE, 0)
}
fn lineStringContent_all(&self) ->  Vec<Rc<LineStringContentContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn lineStringContent(&self, i: usize) -> Option<Rc<LineStringContentContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn lineStringExpression_all(&self) ->  Vec<Rc<LineStringExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn lineStringExpression(&self, i: usize) -> Option<Rc<LineStringExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> LineStringLiteralContextAttrs<'input> for LineStringLiteralContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lineStringLiteral(&mut self,)
	-> Result<Rc<LineStringLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LineStringLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 220, RULE_lineStringLiteral);
        let mut _localctx: Rc<LineStringLiteralContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2637);
			recog.base.match_token(QUOTE_OPEN,&mut recog.err_handler)?;

			recog.base.set_state(2642);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while ((((_la - 159)) & !0x3f) == 0 && ((1usize << (_la - 159)) & ((1usize << (LineStrRef - 159)) | (1usize << (LineStrText - 159)) | (1usize << (LineStrEscapedChar - 159)) | (1usize << (LineStrExprStart - 159)))) != 0) {
				{
				recog.base.set_state(2640);
				recog.err_handler.sync(&mut recog.base)?;
				match recog.base.input.la(1) {
				 LineStrRef | LineStrText | LineStrEscapedChar 
					=> {
						{
						/*InvokeRule lineStringContent*/
						recog.base.set_state(2638);
						recog.lineStringContent()?;

						}
					}

				 LineStrExprStart 
					=> {
						{
						/*InvokeRule lineStringExpression*/
						recog.base.set_state(2639);
						recog.lineStringExpression()?;

						}
					}

					_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				}
				recog.base.set_state(2644);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2645);
			recog.base.match_token(QUOTE_CLOSE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- multiLineStringLiteral ----------------
pub type MultiLineStringLiteralContextAll<'input> = MultiLineStringLiteralContext<'input>;


pub type MultiLineStringLiteralContext<'input> = BaseParserRuleContext<'input,MultiLineStringLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct MultiLineStringLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for MultiLineStringLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for MultiLineStringLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_multiLineStringLiteral(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_multiLineStringLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for MultiLineStringLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_multiLineStringLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for MultiLineStringLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_multiLineStringLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_multiLineStringLiteral }
}
antlr_rust::tid!{MultiLineStringLiteralContextExt<'a>}

impl<'input> MultiLineStringLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MultiLineStringLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MultiLineStringLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MultiLineStringLiteralContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<MultiLineStringLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token TRIPLE_QUOTE_OPEN
/// Returns `None` if there is no child corresponding to token TRIPLE_QUOTE_OPEN
fn TRIPLE_QUOTE_OPEN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(TRIPLE_QUOTE_OPEN, 0)
}
/// Retrieves first TerminalNode corresponding to token TRIPLE_QUOTE_CLOSE
/// Returns `None` if there is no child corresponding to token TRIPLE_QUOTE_CLOSE
fn TRIPLE_QUOTE_CLOSE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(TRIPLE_QUOTE_CLOSE, 0)
}
fn multiLineStringContent_all(&self) ->  Vec<Rc<MultiLineStringContentContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn multiLineStringContent(&self, i: usize) -> Option<Rc<MultiLineStringContentContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn multiLineStringExpression_all(&self) ->  Vec<Rc<MultiLineStringExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn multiLineStringExpression(&self, i: usize) -> Option<Rc<MultiLineStringExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token MultiLineStringQuote in current rule
fn MultiLineStringQuote_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token MultiLineStringQuote, starting from 0.
/// Returns `None` if number of children corresponding to token MultiLineStringQuote is less or equal than `i`.
fn MultiLineStringQuote(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MultiLineStringQuote, i)
}

}

impl<'input> MultiLineStringLiteralContextAttrs<'input> for MultiLineStringLiteralContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn multiLineStringLiteral(&mut self,)
	-> Result<Rc<MultiLineStringLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MultiLineStringLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 222, RULE_multiLineStringLiteral);
        let mut _localctx: Rc<MultiLineStringLiteralContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2647);
			recog.base.match_token(TRIPLE_QUOTE_OPEN,&mut recog.err_handler)?;

			recog.base.set_state(2653);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while ((((_la - 164)) & !0x3f) == 0 && ((1usize << (_la - 164)) & ((1usize << (MultiLineStringQuote - 164)) | (1usize << (MultiLineStrRef - 164)) | (1usize << (MultiLineStrText - 164)) | (1usize << (MultiLineStrExprStart - 164)))) != 0) {
				{
				recog.base.set_state(2651);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(399,&mut recog.base)? {
					1 =>{
						{
						/*InvokeRule multiLineStringContent*/
						recog.base.set_state(2648);
						recog.multiLineStringContent()?;

						}
					}
				,
					2 =>{
						{
						/*InvokeRule multiLineStringExpression*/
						recog.base.set_state(2649);
						recog.multiLineStringExpression()?;

						}
					}
				,
					3 =>{
						{
						recog.base.set_state(2650);
						recog.base.match_token(MultiLineStringQuote,&mut recog.err_handler)?;

						}
					}

					_ => {}
				}
				}
				recog.base.set_state(2655);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2656);
			recog.base.match_token(TRIPLE_QUOTE_CLOSE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lineStringContent ----------------
pub type LineStringContentContextAll<'input> = LineStringContentContext<'input>;


pub type LineStringContentContext<'input> = BaseParserRuleContext<'input,LineStringContentContextExt<'input>>;

#[derive(Clone)]
pub struct LineStringContentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for LineStringContentContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for LineStringContentContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lineStringContent(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_lineStringContent(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for LineStringContentContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_lineStringContent(self);
	}
}

impl<'input> CustomRuleContext<'input> for LineStringContentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lineStringContent }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lineStringContent }
}
antlr_rust::tid!{LineStringContentContextExt<'a>}

impl<'input> LineStringContentContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LineStringContentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LineStringContentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LineStringContentContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<LineStringContentContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LineStrText
/// Returns `None` if there is no child corresponding to token LineStrText
fn LineStrText(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LineStrText, 0)
}
/// Retrieves first TerminalNode corresponding to token LineStrEscapedChar
/// Returns `None` if there is no child corresponding to token LineStrEscapedChar
fn LineStrEscapedChar(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LineStrEscapedChar, 0)
}
/// Retrieves first TerminalNode corresponding to token LineStrRef
/// Returns `None` if there is no child corresponding to token LineStrRef
fn LineStrRef(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LineStrRef, 0)
}

}

impl<'input> LineStringContentContextAttrs<'input> for LineStringContentContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lineStringContent(&mut self,)
	-> Result<Rc<LineStringContentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LineStringContentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 224, RULE_lineStringContent);
        let mut _localctx: Rc<LineStringContentContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2658);
			_la = recog.base.input.la(1);
			if { !(((((_la - 159)) & !0x3f) == 0 && ((1usize << (_la - 159)) & ((1usize << (LineStrRef - 159)) | (1usize << (LineStrText - 159)) | (1usize << (LineStrEscapedChar - 159)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lineStringExpression ----------------
pub type LineStringExpressionContextAll<'input> = LineStringExpressionContext<'input>;


pub type LineStringExpressionContext<'input> = BaseParserRuleContext<'input,LineStringExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct LineStringExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for LineStringExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for LineStringExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lineStringExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_lineStringExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for LineStringExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_lineStringExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for LineStringExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lineStringExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lineStringExpression }
}
antlr_rust::tid!{LineStringExpressionContextExt<'a>}

impl<'input> LineStringExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LineStringExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LineStringExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LineStringExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<LineStringExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LineStrExprStart
/// Returns `None` if there is no child corresponding to token LineStrExprStart
fn LineStrExprStart(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LineStrExprStart, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RCURL
/// Returns `None` if there is no child corresponding to token RCURL
fn RCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RCURL, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> LineStringExpressionContextAttrs<'input> for LineStringExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lineStringExpression(&mut self,)
	-> Result<Rc<LineStringExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LineStringExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 226, RULE_lineStringExpression);
        let mut _localctx: Rc<LineStringExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2660);
			recog.base.match_token(LineStrExprStart,&mut recog.err_handler)?;

			recog.base.set_state(2664);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2661);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2666);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule expression*/
			recog.base.set_state(2667);
			recog.expression()?;

			recog.base.set_state(2671);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2668);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2673);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2674);
			recog.base.match_token(RCURL,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- multiLineStringContent ----------------
pub type MultiLineStringContentContextAll<'input> = MultiLineStringContentContext<'input>;


pub type MultiLineStringContentContext<'input> = BaseParserRuleContext<'input,MultiLineStringContentContextExt<'input>>;

#[derive(Clone)]
pub struct MultiLineStringContentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for MultiLineStringContentContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for MultiLineStringContentContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_multiLineStringContent(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_multiLineStringContent(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for MultiLineStringContentContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_multiLineStringContent(self);
	}
}

impl<'input> CustomRuleContext<'input> for MultiLineStringContentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_multiLineStringContent }
	//fn type_rule_index() -> usize where Self: Sized { RULE_multiLineStringContent }
}
antlr_rust::tid!{MultiLineStringContentContextExt<'a>}

impl<'input> MultiLineStringContentContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MultiLineStringContentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MultiLineStringContentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MultiLineStringContentContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<MultiLineStringContentContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token MultiLineStrText
/// Returns `None` if there is no child corresponding to token MultiLineStrText
fn MultiLineStrText(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MultiLineStrText, 0)
}
/// Retrieves first TerminalNode corresponding to token MultiLineStringQuote
/// Returns `None` if there is no child corresponding to token MultiLineStringQuote
fn MultiLineStringQuote(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MultiLineStringQuote, 0)
}
/// Retrieves first TerminalNode corresponding to token MultiLineStrRef
/// Returns `None` if there is no child corresponding to token MultiLineStrRef
fn MultiLineStrRef(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MultiLineStrRef, 0)
}

}

impl<'input> MultiLineStringContentContextAttrs<'input> for MultiLineStringContentContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn multiLineStringContent(&mut self,)
	-> Result<Rc<MultiLineStringContentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MultiLineStringContentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 228, RULE_multiLineStringContent);
        let mut _localctx: Rc<MultiLineStringContentContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2676);
			_la = recog.base.input.la(1);
			if { !(((((_la - 164)) & !0x3f) == 0 && ((1usize << (_la - 164)) & ((1usize << (MultiLineStringQuote - 164)) | (1usize << (MultiLineStrRef - 164)) | (1usize << (MultiLineStrText - 164)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- multiLineStringExpression ----------------
pub type MultiLineStringExpressionContextAll<'input> = MultiLineStringExpressionContext<'input>;


pub type MultiLineStringExpressionContext<'input> = BaseParserRuleContext<'input,MultiLineStringExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct MultiLineStringExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for MultiLineStringExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for MultiLineStringExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_multiLineStringExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_multiLineStringExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for MultiLineStringExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_multiLineStringExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for MultiLineStringExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_multiLineStringExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_multiLineStringExpression }
}
antlr_rust::tid!{MultiLineStringExpressionContextExt<'a>}

impl<'input> MultiLineStringExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MultiLineStringExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MultiLineStringExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MultiLineStringExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<MultiLineStringExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token MultiLineStrExprStart
/// Returns `None` if there is no child corresponding to token MultiLineStrExprStart
fn MultiLineStrExprStart(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MultiLineStrExprStart, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RCURL
/// Returns `None` if there is no child corresponding to token RCURL
fn RCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RCURL, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> MultiLineStringExpressionContextAttrs<'input> for MultiLineStringExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn multiLineStringExpression(&mut self,)
	-> Result<Rc<MultiLineStringExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MultiLineStringExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 230, RULE_multiLineStringExpression);
        let mut _localctx: Rc<MultiLineStringExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2678);
			recog.base.match_token(MultiLineStrExprStart,&mut recog.err_handler)?;

			recog.base.set_state(2682);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2679);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2684);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule expression*/
			recog.base.set_state(2685);
			recog.expression()?;

			recog.base.set_state(2689);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2686);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2691);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2692);
			recog.base.match_token(RCURL,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lambdaLiteral ----------------
pub type LambdaLiteralContextAll<'input> = LambdaLiteralContext<'input>;


pub type LambdaLiteralContext<'input> = BaseParserRuleContext<'input,LambdaLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct LambdaLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for LambdaLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for LambdaLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lambdaLiteral(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_lambdaLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for LambdaLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_lambdaLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for LambdaLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lambdaLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lambdaLiteral }
}
antlr_rust::tid!{LambdaLiteralContextExt<'a>}

impl<'input> LambdaLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LambdaLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LambdaLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LambdaLiteralContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<LambdaLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LCURL
/// Returns `None` if there is no child corresponding to token LCURL
fn LCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LCURL, 0)
}
fn statements(&self) -> Option<Rc<StatementsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RCURL
/// Returns `None` if there is no child corresponding to token RCURL
fn RCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RCURL, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token ARROW
/// Returns `None` if there is no child corresponding to token ARROW
fn ARROW(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ARROW, 0)
}
fn lambdaParameters(&self) -> Option<Rc<LambdaParametersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LambdaLiteralContextAttrs<'input> for LambdaLiteralContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lambdaLiteral(&mut self,)
	-> Result<Rc<LambdaLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LambdaLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 232, RULE_lambdaLiteral);
        let mut _localctx: Rc<LambdaLiteralContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2694);
			recog.base.match_token(LCURL,&mut recog.err_handler)?;

			recog.base.set_state(2698);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(405,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2695);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2700);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(405,&mut recog.base)?;
			}
			recog.base.set_state(2717);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(409,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2702);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(406,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule lambdaParameters*/
							recog.base.set_state(2701);
							recog.lambdaParameters()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(2707);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2704);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2709);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2710);
					recog.base.match_token(ARROW,&mut recog.err_handler)?;

					recog.base.set_state(2714);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(408,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2711);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2716);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(408,&mut recog.base)?;
					}
					}
				}

				_ => {}
			}
			/*InvokeRule statements*/
			recog.base.set_state(2719);
			recog.statements()?;

			recog.base.set_state(2723);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2720);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2725);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2726);
			recog.base.match_token(RCURL,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lambdaParameters ----------------
pub type LambdaParametersContextAll<'input> = LambdaParametersContext<'input>;


pub type LambdaParametersContext<'input> = BaseParserRuleContext<'input,LambdaParametersContextExt<'input>>;

#[derive(Clone)]
pub struct LambdaParametersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for LambdaParametersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for LambdaParametersContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lambdaParameters(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_lambdaParameters(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for LambdaParametersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_lambdaParameters(self);
	}
}

impl<'input> CustomRuleContext<'input> for LambdaParametersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lambdaParameters }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lambdaParameters }
}
antlr_rust::tid!{LambdaParametersContextExt<'a>}

impl<'input> LambdaParametersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LambdaParametersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LambdaParametersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LambdaParametersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<LambdaParametersContextExt<'input>>{

fn lambdaParameter_all(&self) ->  Vec<Rc<LambdaParameterContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn lambdaParameter(&self, i: usize) -> Option<Rc<LambdaParameterContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> LambdaParametersContextAttrs<'input> for LambdaParametersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lambdaParameters(&mut self,)
	-> Result<Rc<LambdaParametersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LambdaParametersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 234, RULE_lambdaParameters);
        let mut _localctx: Rc<LambdaParametersContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule lambdaParameter*/
			recog.base.set_state(2728);
			recog.lambdaParameter()?;

			recog.base.set_state(2745);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(413,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2732);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2729);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2734);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2735);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(2739);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(412,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2736);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2741);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(412,&mut recog.base)?;
					}
					/*InvokeRule lambdaParameter*/
					recog.base.set_state(2742);
					recog.lambdaParameter()?;

					}
					} 
				}
				recog.base.set_state(2747);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(413,&mut recog.base)?;
			}
			recog.base.set_state(2755);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(415,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2751);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2748);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2753);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2754);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lambdaParameter ----------------
pub type LambdaParameterContextAll<'input> = LambdaParameterContext<'input>;


pub type LambdaParameterContext<'input> = BaseParserRuleContext<'input,LambdaParameterContextExt<'input>>;

#[derive(Clone)]
pub struct LambdaParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for LambdaParameterContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for LambdaParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lambdaParameter(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_lambdaParameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for LambdaParameterContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_lambdaParameter(self);
	}
}

impl<'input> CustomRuleContext<'input> for LambdaParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lambdaParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lambdaParameter }
}
antlr_rust::tid!{LambdaParameterContextExt<'a>}

impl<'input> LambdaParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LambdaParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LambdaParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LambdaParameterContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<LambdaParameterContextExt<'input>>{

fn variableDeclaration(&self) -> Option<Rc<VariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn multiVariableDeclaration(&self) -> Option<Rc<MultiVariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn rustType(&self) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> LambdaParameterContextAttrs<'input> for LambdaParameterContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lambdaParameter(&mut self,)
	-> Result<Rc<LambdaParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LambdaParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 236, RULE_lambdaParameter);
        let mut _localctx: Rc<LambdaParameterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2775);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 NL | AT_NO_WS | AT_PRE_WS | FILE | FIELD | PROPERTY | GET | SET | RECEIVER |
			 PARAM | SETPARAM | DELEGATE | IMPORT | CONSTRUCTOR | BY | COMPANION |
			 INIT | WHERE | CATCH | FINALLY | OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED |
			 INTERNAL | ENUM | SEALED | ANNOTATION | DATA | INNER | VALUE | TAILREC |
			 OPERATOR | INLINE | INFIX | EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT |
			 FINAL | OPEN | CONST | LATEINIT | VARARG | NOINLINE | CROSSINLINE | REIFIED |
			 EXPECT | ACTUAL | Identifier 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule variableDeclaration*/
					recog.base.set_state(2757);
					recog.variableDeclaration()?;

					}
				}

			 LPAREN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule multiVariableDeclaration*/
					recog.base.set_state(2758);
					recog.multiVariableDeclaration()?;

					recog.base.set_state(2773);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(418,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(2762);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(2759);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(2764);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(2765);
							recog.base.match_token(COLON,&mut recog.err_handler)?;

							recog.base.set_state(2769);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(2766);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(2771);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							/*InvokeRule rustType*/
							recog.base.set_state(2772);
							recog.rustType()?;

							}
						}

						_ => {}
					}
					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- anonymousFunction ----------------
pub type AnonymousFunctionContextAll<'input> = AnonymousFunctionContext<'input>;


pub type AnonymousFunctionContext<'input> = BaseParserRuleContext<'input,AnonymousFunctionContextExt<'input>>;

#[derive(Clone)]
pub struct AnonymousFunctionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AnonymousFunctionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AnonymousFunctionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_anonymousFunction(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_anonymousFunction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AnonymousFunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_anonymousFunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for AnonymousFunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_anonymousFunction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_anonymousFunction }
}
antlr_rust::tid!{AnonymousFunctionContextExt<'a>}

impl<'input> AnonymousFunctionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnonymousFunctionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnonymousFunctionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnonymousFunctionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AnonymousFunctionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FUN
/// Returns `None` if there is no child corresponding to token FUN
fn FUN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FUN, 0)
}
fn parametersWithOptionalType(&self) -> Option<Rc<ParametersWithOptionalTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rustType_all(&self) ->  Vec<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn rustType(&self, i: usize) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn typeConstraints(&self) -> Option<Rc<TypeConstraintsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionBody(&self) -> Option<Rc<FunctionBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AnonymousFunctionContextAttrs<'input> for AnonymousFunctionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn anonymousFunction(&mut self,)
	-> Result<Rc<AnonymousFunctionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnonymousFunctionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 238, RULE_anonymousFunction);
        let mut _localctx: Rc<AnonymousFunctionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2777);
			recog.base.match_token(FUN,&mut recog.err_handler)?;

			recog.base.set_state(2793);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(422,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2781);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2778);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2783);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule rustType*/
					recog.base.set_state(2784);
					recog.rustType()?;

					recog.base.set_state(2788);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2785);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2790);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2791);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2798);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2795);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2800);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule parametersWithOptionalType*/
			recog.base.set_state(2801);
			recog.parametersWithOptionalType()?;

			recog.base.set_state(2816);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(426,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2805);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2802);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2807);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2808);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(2812);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2809);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2814);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule rustType*/
					recog.base.set_state(2815);
					recog.rustType()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2825);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(428,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2821);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2818);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2823);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule typeConstraints*/
					recog.base.set_state(2824);
					recog.typeConstraints()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2834);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(430,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2830);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2827);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2832);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule functionBody*/
					recog.base.set_state(2833);
					recog.functionBody()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionLiteral ----------------
pub type FunctionLiteralContextAll<'input> = FunctionLiteralContext<'input>;


pub type FunctionLiteralContext<'input> = BaseParserRuleContext<'input,FunctionLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FunctionLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FunctionLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_functionLiteral(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_functionLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FunctionLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_functionLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionLiteral }
}
antlr_rust::tid!{FunctionLiteralContextExt<'a>}

impl<'input> FunctionLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionLiteralContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FunctionLiteralContextExt<'input>>{

fn lambdaLiteral(&self) -> Option<Rc<LambdaLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn anonymousFunction(&self) -> Option<Rc<AnonymousFunctionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FunctionLiteralContextAttrs<'input> for FunctionLiteralContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionLiteral(&mut self,)
	-> Result<Rc<FunctionLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 240, RULE_functionLiteral);
        let mut _localctx: Rc<FunctionLiteralContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2838);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LCURL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule lambdaLiteral*/
					recog.base.set_state(2836);
					recog.lambdaLiteral()?;

					}
				}

			 FUN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule anonymousFunction*/
					recog.base.set_state(2837);
					recog.anonymousFunction()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- objectLiteral ----------------
pub type ObjectLiteralContextAll<'input> = ObjectLiteralContext<'input>;


pub type ObjectLiteralContext<'input> = BaseParserRuleContext<'input,ObjectLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct ObjectLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ObjectLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ObjectLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_objectLiteral(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_objectLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ObjectLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_objectLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for ObjectLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_objectLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_objectLiteral }
}
antlr_rust::tid!{ObjectLiteralContextExt<'a>}

impl<'input> ObjectLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ObjectLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ObjectLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ObjectLiteralContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ObjectLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OBJECT
/// Returns `None` if there is no child corresponding to token OBJECT
fn OBJECT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OBJECT, 0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn delegationSpecifiers(&self) -> Option<Rc<DelegationSpecifiersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classBody(&self) -> Option<Rc<ClassBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ObjectLiteralContextAttrs<'input> for ObjectLiteralContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn objectLiteral(&mut self,)
	-> Result<Rc<ObjectLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ObjectLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 242, RULE_objectLiteral);
        let mut _localctx: Rc<ObjectLiteralContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2840);
			recog.base.match_token(OBJECT,&mut recog.err_handler)?;

			recog.base.set_state(2861);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(435,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2844);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2841);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2846);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2847);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					recog.base.set_state(2851);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(433,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2848);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2853);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(433,&mut recog.base)?;
					}
					/*InvokeRule delegationSpecifiers*/
					recog.base.set_state(2854);
					recog.delegationSpecifiers()?;

					recog.base.set_state(2858);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(434,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2855);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2860);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(434,&mut recog.base)?;
					}
					}
				}

				_ => {}
			}
			recog.base.set_state(2870);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(437,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2866);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2863);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2868);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule classBody*/
					recog.base.set_state(2869);
					recog.classBody()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- thisExpression ----------------
pub type ThisExpressionContextAll<'input> = ThisExpressionContext<'input>;


pub type ThisExpressionContext<'input> = BaseParserRuleContext<'input,ThisExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ThisExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ThisExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ThisExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_thisExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_thisExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ThisExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_thisExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ThisExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_thisExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_thisExpression }
}
antlr_rust::tid!{ThisExpressionContextExt<'a>}

impl<'input> ThisExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ThisExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ThisExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ThisExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ThisExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token THIS
/// Returns `None` if there is no child corresponding to token THIS
fn THIS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(THIS, 0)
}
/// Retrieves first TerminalNode corresponding to token THIS_AT
/// Returns `None` if there is no child corresponding to token THIS_AT
fn THIS_AT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(THIS_AT, 0)
}

}

impl<'input> ThisExpressionContextAttrs<'input> for ThisExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn thisExpression(&mut self,)
	-> Result<Rc<ThisExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ThisExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 244, RULE_thisExpression);
        let mut _localctx: Rc<ThisExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2872);
			_la = recog.base.input.la(1);
			if { !(_la==THIS_AT || _la==THIS) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- superExpression ----------------
pub type SuperExpressionContextAll<'input> = SuperExpressionContext<'input>;


pub type SuperExpressionContext<'input> = BaseParserRuleContext<'input,SuperExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct SuperExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for SuperExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for SuperExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_superExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_superExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for SuperExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_superExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for SuperExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_superExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_superExpression }
}
antlr_rust::tid!{SuperExpressionContextExt<'a>}

impl<'input> SuperExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SuperExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SuperExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SuperExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<SuperExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SUPER
/// Returns `None` if there is no child corresponding to token SUPER
fn SUPER(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUPER, 0)
}
/// Retrieves first TerminalNode corresponding to token LANGLE
/// Returns `None` if there is no child corresponding to token LANGLE
fn LANGLE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LANGLE, 0)
}
fn rustType(&self) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RANGLE
/// Returns `None` if there is no child corresponding to token RANGLE
fn RANGLE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RANGLE, 0)
}
/// Retrieves first TerminalNode corresponding to token AT_NO_WS
/// Returns `None` if there is no child corresponding to token AT_NO_WS
fn AT_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_NO_WS, 0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token SUPER_AT
/// Returns `None` if there is no child corresponding to token SUPER_AT
fn SUPER_AT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUPER_AT, 0)
}

}

impl<'input> SuperExpressionContextAttrs<'input> for SuperExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn superExpression(&mut self,)
	-> Result<Rc<SuperExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SuperExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 246, RULE_superExpression);
        let mut _localctx: Rc<SuperExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2898);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 SUPER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2874);
					recog.base.match_token(SUPER,&mut recog.err_handler)?;

					recog.base.set_state(2891);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(440,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(2875);
							recog.base.match_token(LANGLE,&mut recog.err_handler)?;

							recog.base.set_state(2879);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(2876);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(2881);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							/*InvokeRule rustType*/
							recog.base.set_state(2882);
							recog.rustType()?;

							recog.base.set_state(2886);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(2883);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(2888);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(2889);
							recog.base.match_token(RANGLE,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(2895);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(441,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(2893);
							recog.base.match_token(AT_NO_WS,&mut recog.err_handler)?;

							/*InvokeRule simpleIdentifier*/
							recog.base.set_state(2894);
							recog.simpleIdentifier()?;

							}
						}

						_ => {}
					}
					}
				}

			 SUPER_AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2897);
					recog.base.match_token(SUPER_AT,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifExpression ----------------
pub type IfExpressionContextAll<'input> = IfExpressionContext<'input>;


pub type IfExpressionContext<'input> = BaseParserRuleContext<'input,IfExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct IfExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for IfExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for IfExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_ifExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for IfExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_ifExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for IfExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifExpression }
}
antlr_rust::tid!{IfExpressionContextExt<'a>}

impl<'input> IfExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<IfExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IF
/// Returns `None` if there is no child corresponding to token IF
fn IF(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(IF, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn controlStructureBody_all(&self) ->  Vec<Rc<ControlStructureBodyContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn controlStructureBody(&self, i: usize) -> Option<Rc<ControlStructureBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token ELSE
/// Returns `None` if there is no child corresponding to token ELSE
fn ELSE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ELSE, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token SEMICOLON in current rule
fn SEMICOLON_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token SEMICOLON, starting from 0.
/// Returns `None` if number of children corresponding to token SEMICOLON is less or equal than `i`.
fn SEMICOLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SEMICOLON, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> IfExpressionContextAttrs<'input> for IfExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifExpression(&mut self,)
	-> Result<Rc<IfExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 248, RULE_ifExpression);
        let mut _localctx: Rc<IfExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2900);
			recog.base.match_token(IF,&mut recog.err_handler)?;

			recog.base.set_state(2904);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2901);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2906);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2907);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2911);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2908);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2913);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule expression*/
			recog.base.set_state(2914);
			recog.expression()?;

			recog.base.set_state(2918);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(2915);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(2920);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2921);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2925);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(446,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2922);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(2927);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(446,&mut recog.base)?;
			}
			recog.base.set_state(2959);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(453,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule controlStructureBody*/
					recog.base.set_state(2928);
					recog.controlStructureBody()?;

					}
				}
			,
				2 =>{
					{
					recog.base.set_state(2930);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << LPAREN) | (1usize << LSQUARE) | (1usize << LCURL) | (1usize << ADD) | (1usize << SUB) | (1usize << INCR) | (1usize << DECR) | (1usize << EXCL_WS) | (1usize << EXCL_NO_WS) | (1usize << COLONCOLON) | (1usize << AT_NO_WS) | (1usize << AT_PRE_WS) | (1usize << RETURN_AT) | (1usize << CONTINUE_AT) | (1usize << BREAK_AT) | (1usize << THIS_AT) | (1usize << SUPER_AT) | (1usize << FILE) | (1usize << FIELD) | (1usize << PROPERTY))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (GET - 64)) | (1usize << (SET - 64)) | (1usize << (RECEIVER - 64)) | (1usize << (PARAM - 64)) | (1usize << (SETPARAM - 64)) | (1usize << (DELEGATE - 64)) | (1usize << (IMPORT - 64)) | (1usize << (CLASS - 64)) | (1usize << (INTERFACE - 64)) | (1usize << (FUN - 64)) | (1usize << (OBJECT - 64)) | (1usize << (VAL - 64)) | (1usize << (VAR - 64)) | (1usize << (TYPE_ALIAS - 64)) | (1usize << (CONSTRUCTOR - 64)) | (1usize << (BY - 64)) | (1usize << (COMPANION - 64)) | (1usize << (INIT - 64)) | (1usize << (THIS - 64)) | (1usize << (SUPER - 64)) | (1usize << (WHERE - 64)) | (1usize << (IF - 64)) | (1usize << (WHEN - 64)) | (1usize << (TRY - 64)) | (1usize << (CATCH - 64)) | (1usize << (FINALLY - 64)) | (1usize << (FOR - 64)) | (1usize << (DO - 64)) | (1usize << (WHILE - 64)) | (1usize << (THROW - 64)) | (1usize << (RETURN - 64)) | (1usize << (CONTINUE - 64)) | (1usize << (BREAK - 64)) | (1usize << (OUT - 64)) | (1usize << (DYNAMIC - 64)) | (1usize << (PUBLIC - 64)) | (1usize << (PRIVATE - 64)) | (1usize << (PROTECTED - 64)) | (1usize << (INTERNAL - 64)) | (1usize << (ENUM - 64)) | (1usize << (SEALED - 64)) | (1usize << (ANNOTATION - 64)) | (1usize << (DATA - 64)) | (1usize << (INNER - 64)) | (1usize << (VALUE - 64)) | (1usize << (TAILREC - 64)) | (1usize << (OPERATOR - 64)) | (1usize << (INLINE - 64)) | (1usize << (INFIX - 64)) | (1usize << (EXTERNAL - 64)) | (1usize << (SUSPEND - 64)) | (1usize << (OVERRIDE - 64)) | (1usize << (ABSTRACT - 64)) | (1usize << (FINAL - 64)) | (1usize << (OPEN - 64)) | (1usize << (CONST - 64)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (LATEINIT - 128)) | (1usize << (VARARG - 128)) | (1usize << (NOINLINE - 128)) | (1usize << (CROSSINLINE - 128)) | (1usize << (REIFIED - 128)) | (1usize << (EXPECT - 128)) | (1usize << (ACTUAL - 128)) | (1usize << (RealLiteral - 128)) | (1usize << (IntegerLiteral - 128)) | (1usize << (HexLiteral - 128)) | (1usize << (BinLiteral - 128)) | (1usize << (UnsignedLiteral - 128)) | (1usize << (LongLiteral - 128)) | (1usize << (BooleanLiteral - 128)) | (1usize << (NullLiteral - 128)) | (1usize << (CharacterLiteral - 128)) | (1usize << (Identifier - 128)) | (1usize << (QUOTE_OPEN - 128)) | (1usize << (TRIPLE_QUOTE_OPEN - 128)))) != 0) {
						{
						/*InvokeRule controlStructureBody*/
						recog.base.set_state(2929);
						recog.controlStructureBody()?;

						}
					}

					recog.base.set_state(2935);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(448,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2932);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2937);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(448,&mut recog.base)?;
					}
					recog.base.set_state(2939);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==SEMICOLON {
						{
						recog.base.set_state(2938);
						recog.base.match_token(SEMICOLON,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(2944);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2941);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2946);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2947);
					recog.base.match_token(ELSE,&mut recog.err_handler)?;

					recog.base.set_state(2951);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2948);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2953);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2956);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 LPAREN | LSQUARE | LCURL | ADD | SUB | INCR | DECR | EXCL_WS | EXCL_NO_WS |
					 COLONCOLON | AT_NO_WS | AT_PRE_WS | RETURN_AT | CONTINUE_AT | BREAK_AT |
					 THIS_AT | SUPER_AT | FILE | FIELD | PROPERTY | GET | SET | RECEIVER |
					 PARAM | SETPARAM | DELEGATE | IMPORT | CLASS | INTERFACE | FUN | OBJECT |
					 VAL | VAR | TYPE_ALIAS | CONSTRUCTOR | BY | COMPANION | INIT | THIS |
					 SUPER | WHERE | IF | WHEN | TRY | CATCH | FINALLY | FOR | DO | WHILE |
					 THROW | RETURN | CONTINUE | BREAK | OUT | DYNAMIC | PUBLIC | PRIVATE |
					 PROTECTED | INTERNAL | ENUM | SEALED | ANNOTATION | DATA | INNER |
					 VALUE | TAILREC | OPERATOR | INLINE | INFIX | EXTERNAL | SUSPEND |
					 OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT | VARARG | NOINLINE |
					 CROSSINLINE | REIFIED | EXPECT | ACTUAL | RealLiteral | IntegerLiteral |
					 HexLiteral | BinLiteral | UnsignedLiteral | LongLiteral | BooleanLiteral |
					 NullLiteral | CharacterLiteral | Identifier | QUOTE_OPEN | TRIPLE_QUOTE_OPEN 
						=> {
							{
							/*InvokeRule controlStructureBody*/
							recog.base.set_state(2954);
							recog.controlStructureBody()?;

							}
						}

					 SEMICOLON 
						=> {
							{
							recog.base.set_state(2955);
							recog.base.match_token(SEMICOLON,&mut recog.err_handler)?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					}
				}
			,
				3 =>{
					{
					recog.base.set_state(2958);
					recog.base.match_token(SEMICOLON,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- whenSubject ----------------
pub type WhenSubjectContextAll<'input> = WhenSubjectContext<'input>;


pub type WhenSubjectContext<'input> = BaseParserRuleContext<'input,WhenSubjectContextExt<'input>>;

#[derive(Clone)]
pub struct WhenSubjectContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for WhenSubjectContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for WhenSubjectContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_whenSubject(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_whenSubject(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for WhenSubjectContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_whenSubject(self);
	}
}

impl<'input> CustomRuleContext<'input> for WhenSubjectContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_whenSubject }
	//fn type_rule_index() -> usize where Self: Sized { RULE_whenSubject }
}
antlr_rust::tid!{WhenSubjectContextExt<'a>}

impl<'input> WhenSubjectContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WhenSubjectContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WhenSubjectContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WhenSubjectContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<WhenSubjectContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token VAL
/// Returns `None` if there is no child corresponding to token VAL
fn VAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(VAL, 0)
}
fn variableDeclaration(&self) -> Option<Rc<VariableDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ASSIGNMENT
fn ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ASSIGNMENT, 0)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> WhenSubjectContextAttrs<'input> for WhenSubjectContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn whenSubject(&mut self,)
	-> Result<Rc<WhenSubjectContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WhenSubjectContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 250, RULE_whenSubject);
        let mut _localctx: Rc<WhenSubjectContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2961);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2995);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(459,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2965);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==AT_NO_WS || _la==AT_PRE_WS {
						{
						{
						/*InvokeRule annotation*/
						recog.base.set_state(2962);
						recog.annotation()?;

						}
						}
						recog.base.set_state(2967);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2971);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2968);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2973);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2974);
					recog.base.match_token(VAL,&mut recog.err_handler)?;

					recog.base.set_state(2978);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(456,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2975);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(2980);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(456,&mut recog.base)?;
					}
					/*InvokeRule variableDeclaration*/
					recog.base.set_state(2981);
					recog.variableDeclaration()?;

					recog.base.set_state(2985);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2982);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2987);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2988);
					recog.base.match_token(ASSIGNMENT,&mut recog.err_handler)?;

					recog.base.set_state(2992);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(2989);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(2994);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

				_ => {}
			}
			/*InvokeRule expression*/
			recog.base.set_state(2997);
			recog.expression()?;

			recog.base.set_state(2998);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- whenExpression ----------------
pub type WhenExpressionContextAll<'input> = WhenExpressionContext<'input>;


pub type WhenExpressionContext<'input> = BaseParserRuleContext<'input,WhenExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct WhenExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for WhenExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for WhenExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_whenExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_whenExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for WhenExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_whenExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for WhenExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_whenExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_whenExpression }
}
antlr_rust::tid!{WhenExpressionContextExt<'a>}

impl<'input> WhenExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WhenExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WhenExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WhenExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<WhenExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token WHEN
/// Returns `None` if there is no child corresponding to token WHEN
fn WHEN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(WHEN, 0)
}
/// Retrieves first TerminalNode corresponding to token LCURL
/// Returns `None` if there is no child corresponding to token LCURL
fn LCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LCURL, 0)
}
/// Retrieves first TerminalNode corresponding to token RCURL
/// Returns `None` if there is no child corresponding to token RCURL
fn RCURL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RCURL, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn whenSubject(&self) -> Option<Rc<WhenSubjectContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn whenEntry_all(&self) ->  Vec<Rc<WhenEntryContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn whenEntry(&self, i: usize) -> Option<Rc<WhenEntryContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> WhenExpressionContextAttrs<'input> for WhenExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn whenExpression(&mut self,)
	-> Result<Rc<WhenExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WhenExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 252, RULE_whenExpression);
        let mut _localctx: Rc<WhenExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3000);
			recog.base.match_token(WHEN,&mut recog.err_handler)?;

			recog.base.set_state(3004);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(460,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(3001);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(3006);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(460,&mut recog.base)?;
			}
			recog.base.set_state(3008);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LPAREN {
				{
				/*InvokeRule whenSubject*/
				recog.base.set_state(3007);
				recog.whenSubject()?;

				}
			}

			recog.base.set_state(3013);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(3010);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(3015);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(3016);
			recog.base.match_token(LCURL,&mut recog.err_handler)?;

			recog.base.set_state(3020);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(463,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(3017);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(3022);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(463,&mut recog.base)?;
			}
			recog.base.set_state(3032);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << LPAREN) | (1usize << LSQUARE) | (1usize << LCURL) | (1usize << ADD) | (1usize << SUB) | (1usize << INCR) | (1usize << DECR) | (1usize << EXCL_WS) | (1usize << EXCL_NO_WS) | (1usize << COLONCOLON) | (1usize << AT_NO_WS) | (1usize << AT_PRE_WS) | (1usize << RETURN_AT) | (1usize << CONTINUE_AT) | (1usize << BREAK_AT) | (1usize << THIS_AT) | (1usize << SUPER_AT) | (1usize << FILE) | (1usize << FIELD) | (1usize << PROPERTY))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (GET - 64)) | (1usize << (SET - 64)) | (1usize << (RECEIVER - 64)) | (1usize << (PARAM - 64)) | (1usize << (SETPARAM - 64)) | (1usize << (DELEGATE - 64)) | (1usize << (IMPORT - 64)) | (1usize << (FUN - 64)) | (1usize << (OBJECT - 64)) | (1usize << (CONSTRUCTOR - 64)) | (1usize << (BY - 64)) | (1usize << (COMPANION - 64)) | (1usize << (INIT - 64)) | (1usize << (THIS - 64)) | (1usize << (SUPER - 64)) | (1usize << (WHERE - 64)) | (1usize << (IF - 64)) | (1usize << (ELSE - 64)) | (1usize << (WHEN - 64)) | (1usize << (TRY - 64)) | (1usize << (CATCH - 64)) | (1usize << (FINALLY - 64)) | (1usize << (THROW - 64)) | (1usize << (RETURN - 64)) | (1usize << (CONTINUE - 64)) | (1usize << (BREAK - 64)) | (1usize << (IS - 64)) | (1usize << (IN - 64)) | (1usize << (NOT_IS - 64)) | (1usize << (NOT_IN - 64)) | (1usize << (OUT - 64)) | (1usize << (DYNAMIC - 64)) | (1usize << (PUBLIC - 64)) | (1usize << (PRIVATE - 64)) | (1usize << (PROTECTED - 64)) | (1usize << (INTERNAL - 64)) | (1usize << (ENUM - 64)) | (1usize << (SEALED - 64)) | (1usize << (ANNOTATION - 64)) | (1usize << (DATA - 64)) | (1usize << (INNER - 64)) | (1usize << (VALUE - 64)) | (1usize << (TAILREC - 64)) | (1usize << (OPERATOR - 64)) | (1usize << (INLINE - 64)) | (1usize << (INFIX - 64)) | (1usize << (EXTERNAL - 64)) | (1usize << (SUSPEND - 64)) | (1usize << (OVERRIDE - 64)) | (1usize << (ABSTRACT - 64)) | (1usize << (FINAL - 64)) | (1usize << (OPEN - 64)) | (1usize << (CONST - 64)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (LATEINIT - 128)) | (1usize << (VARARG - 128)) | (1usize << (NOINLINE - 128)) | (1usize << (CROSSINLINE - 128)) | (1usize << (REIFIED - 128)) | (1usize << (EXPECT - 128)) | (1usize << (ACTUAL - 128)) | (1usize << (RealLiteral - 128)) | (1usize << (IntegerLiteral - 128)) | (1usize << (HexLiteral - 128)) | (1usize << (BinLiteral - 128)) | (1usize << (UnsignedLiteral - 128)) | (1usize << (LongLiteral - 128)) | (1usize << (BooleanLiteral - 128)) | (1usize << (NullLiteral - 128)) | (1usize << (CharacterLiteral - 128)) | (1usize << (Identifier - 128)) | (1usize << (QUOTE_OPEN - 128)) | (1usize << (TRIPLE_QUOTE_OPEN - 128)))) != 0) {
				{
				{
				/*InvokeRule whenEntry*/
				recog.base.set_state(3023);
				recog.whenEntry()?;

				recog.base.set_state(3027);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(464,&mut recog.base)?;
				while { _alt!=2 && _alt!=INVALID_ALT } {
					if _alt==1 {
						{
						{
						recog.base.set_state(3024);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						} 
					}
					recog.base.set_state(3029);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(464,&mut recog.base)?;
				}
				}
				}
				recog.base.set_state(3034);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(3038);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(3035);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(3040);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(3041);
			recog.base.match_token(RCURL,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- whenEntry ----------------
pub type WhenEntryContextAll<'input> = WhenEntryContext<'input>;


pub type WhenEntryContext<'input> = BaseParserRuleContext<'input,WhenEntryContextExt<'input>>;

#[derive(Clone)]
pub struct WhenEntryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for WhenEntryContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for WhenEntryContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_whenEntry(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_whenEntry(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for WhenEntryContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_whenEntry(self);
	}
}

impl<'input> CustomRuleContext<'input> for WhenEntryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_whenEntry }
	//fn type_rule_index() -> usize where Self: Sized { RULE_whenEntry }
}
antlr_rust::tid!{WhenEntryContextExt<'a>}

impl<'input> WhenEntryContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WhenEntryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WhenEntryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WhenEntryContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<WhenEntryContextExt<'input>>{

fn whenCondition_all(&self) ->  Vec<Rc<WhenConditionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn whenCondition(&self, i: usize) -> Option<Rc<WhenConditionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token ARROW
/// Returns `None` if there is no child corresponding to token ARROW
fn ARROW(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ARROW, 0)
}
fn controlStructureBody(&self) -> Option<Rc<ControlStructureBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn semi(&self) -> Option<Rc<SemiContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ELSE
/// Returns `None` if there is no child corresponding to token ELSE
fn ELSE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ELSE, 0)
}

}

impl<'input> WhenEntryContextAttrs<'input> for WhenEntryContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn whenEntry(&mut self,)
	-> Result<Rc<WhenEntryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WhenEntryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 254, RULE_whenEntry);
        let mut _localctx: Rc<WhenEntryContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(3107);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LPAREN | LSQUARE | LCURL | ADD | SUB | INCR | DECR | EXCL_WS | EXCL_NO_WS |
			 COLONCOLON | AT_NO_WS | AT_PRE_WS | RETURN_AT | CONTINUE_AT | BREAK_AT |
			 THIS_AT | SUPER_AT | FILE | FIELD | PROPERTY | GET | SET | RECEIVER |
			 PARAM | SETPARAM | DELEGATE | IMPORT | FUN | OBJECT | CONSTRUCTOR | BY |
			 COMPANION | INIT | THIS | SUPER | WHERE | IF | WHEN | TRY | CATCH | FINALLY |
			 THROW | RETURN | CONTINUE | BREAK | IS | IN | NOT_IS | NOT_IN | OUT |
			 DYNAMIC | PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED | ANNOTATION |
			 DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX | EXTERNAL |
			 SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT | VARARG |
			 NOINLINE | CROSSINLINE | REIFIED | EXPECT | ACTUAL | RealLiteral | IntegerLiteral |
			 HexLiteral | BinLiteral | UnsignedLiteral | LongLiteral | BooleanLiteral |
			 NullLiteral | CharacterLiteral | Identifier | QUOTE_OPEN | TRIPLE_QUOTE_OPEN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule whenCondition*/
					recog.base.set_state(3043);
					recog.whenCondition()?;

					recog.base.set_state(3060);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(469,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3047);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(3044);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(3049);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(3050);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							recog.base.set_state(3054);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(3051);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(3056);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							/*InvokeRule whenCondition*/
							recog.base.set_state(3057);
							recog.whenCondition()?;

							}
							} 
						}
						recog.base.set_state(3062);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(469,&mut recog.base)?;
					}
					recog.base.set_state(3070);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(471,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(3066);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(3063);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(3068);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(3069);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(3075);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3072);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3077);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(3078);
					recog.base.match_token(ARROW,&mut recog.err_handler)?;

					recog.base.set_state(3082);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3079);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3084);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule controlStructureBody*/
					recog.base.set_state(3085);
					recog.controlStructureBody()?;

					recog.base.set_state(3087);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(474,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule semi*/
							recog.base.set_state(3086);
							recog.semi()?;

							}
						}

						_ => {}
					}
					}
				}

			 ELSE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3089);
					recog.base.match_token(ELSE,&mut recog.err_handler)?;

					recog.base.set_state(3093);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3090);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3095);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(3096);
					recog.base.match_token(ARROW,&mut recog.err_handler)?;

					recog.base.set_state(3100);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3097);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3102);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule controlStructureBody*/
					recog.base.set_state(3103);
					recog.controlStructureBody()?;

					recog.base.set_state(3105);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(477,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule semi*/
							recog.base.set_state(3104);
							recog.semi()?;

							}
						}

						_ => {}
					}
					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- whenCondition ----------------
pub type WhenConditionContextAll<'input> = WhenConditionContext<'input>;


pub type WhenConditionContext<'input> = BaseParserRuleContext<'input,WhenConditionContextExt<'input>>;

#[derive(Clone)]
pub struct WhenConditionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for WhenConditionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for WhenConditionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_whenCondition(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_whenCondition(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for WhenConditionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_whenCondition(self);
	}
}

impl<'input> CustomRuleContext<'input> for WhenConditionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_whenCondition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_whenCondition }
}
antlr_rust::tid!{WhenConditionContextExt<'a>}

impl<'input> WhenConditionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WhenConditionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WhenConditionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WhenConditionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<WhenConditionContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rangeTest(&self) -> Option<Rc<RangeTestContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn typeTest(&self) -> Option<Rc<TypeTestContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> WhenConditionContextAttrs<'input> for WhenConditionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn whenCondition(&mut self,)
	-> Result<Rc<WhenConditionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WhenConditionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 256, RULE_whenCondition);
        let mut _localctx: Rc<WhenConditionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3112);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LPAREN | LSQUARE | LCURL | ADD | SUB | INCR | DECR | EXCL_WS | EXCL_NO_WS |
			 COLONCOLON | AT_NO_WS | AT_PRE_WS | RETURN_AT | CONTINUE_AT | BREAK_AT |
			 THIS_AT | SUPER_AT | FILE | FIELD | PROPERTY | GET | SET | RECEIVER |
			 PARAM | SETPARAM | DELEGATE | IMPORT | FUN | OBJECT | CONSTRUCTOR | BY |
			 COMPANION | INIT | THIS | SUPER | WHERE | IF | WHEN | TRY | CATCH | FINALLY |
			 THROW | RETURN | CONTINUE | BREAK | OUT | DYNAMIC | PUBLIC | PRIVATE |
			 PROTECTED | INTERNAL | ENUM | SEALED | ANNOTATION | DATA | INNER | VALUE |
			 TAILREC | OPERATOR | INLINE | INFIX | EXTERNAL | SUSPEND | OVERRIDE |
			 ABSTRACT | FINAL | OPEN | CONST | LATEINIT | VARARG | NOINLINE | CROSSINLINE |
			 REIFIED | EXPECT | ACTUAL | RealLiteral | IntegerLiteral | HexLiteral |
			 BinLiteral | UnsignedLiteral | LongLiteral | BooleanLiteral | NullLiteral |
			 CharacterLiteral | Identifier | QUOTE_OPEN | TRIPLE_QUOTE_OPEN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule expression*/
					recog.base.set_state(3109);
					recog.expression()?;

					}
				}

			 IN | NOT_IN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule rangeTest*/
					recog.base.set_state(3110);
					recog.rangeTest()?;

					}
				}

			 IS | NOT_IS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule typeTest*/
					recog.base.set_state(3111);
					recog.typeTest()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- rangeTest ----------------
pub type RangeTestContextAll<'input> = RangeTestContext<'input>;


pub type RangeTestContext<'input> = BaseParserRuleContext<'input,RangeTestContextExt<'input>>;

#[derive(Clone)]
pub struct RangeTestContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for RangeTestContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for RangeTestContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_rangeTest(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_rangeTest(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for RangeTestContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_rangeTest(self);
	}
}

impl<'input> CustomRuleContext<'input> for RangeTestContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_rangeTest }
	//fn type_rule_index() -> usize where Self: Sized { RULE_rangeTest }
}
antlr_rust::tid!{RangeTestContextExt<'a>}

impl<'input> RangeTestContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RangeTestContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RangeTestContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RangeTestContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<RangeTestContextExt<'input>>{

fn inOperator(&self) -> Option<Rc<InOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> RangeTestContextAttrs<'input> for RangeTestContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn rangeTest(&mut self,)
	-> Result<Rc<RangeTestContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RangeTestContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 258, RULE_rangeTest);
        let mut _localctx: Rc<RangeTestContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule inOperator*/
			recog.base.set_state(3114);
			recog.inOperator()?;

			recog.base.set_state(3118);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(3115);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(3120);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule expression*/
			recog.base.set_state(3121);
			recog.expression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeTest ----------------
pub type TypeTestContextAll<'input> = TypeTestContext<'input>;


pub type TypeTestContext<'input> = BaseParserRuleContext<'input,TypeTestContextExt<'input>>;

#[derive(Clone)]
pub struct TypeTestContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeTestContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeTestContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeTest(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_typeTest(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeTestContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeTest(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeTestContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeTest }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeTest }
}
antlr_rust::tid!{TypeTestContextExt<'a>}

impl<'input> TypeTestContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeTestContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeTestContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeTestContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeTestContextExt<'input>>{

fn isOperator(&self) -> Option<Rc<IsOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rustType(&self) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> TypeTestContextAttrs<'input> for TypeTestContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeTest(&mut self,)
	-> Result<Rc<TypeTestContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeTestContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 260, RULE_typeTest);
        let mut _localctx: Rc<TypeTestContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule isOperator*/
			recog.base.set_state(3123);
			recog.isOperator()?;

			recog.base.set_state(3127);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(3124);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(3129);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule rustType*/
			recog.base.set_state(3130);
			recog.rustType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tryExpression ----------------
pub type TryExpressionContextAll<'input> = TryExpressionContext<'input>;


pub type TryExpressionContext<'input> = BaseParserRuleContext<'input,TryExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct TryExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TryExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TryExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_tryExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_tryExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TryExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_tryExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for TryExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tryExpression }
}
antlr_rust::tid!{TryExpressionContextExt<'a>}

impl<'input> TryExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TryExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TryExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TryExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TryExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token TRY
/// Returns `None` if there is no child corresponding to token TRY
fn TRY(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(TRY, 0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn finallyBlock(&self) -> Option<Rc<FinallyBlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn catchBlock_all(&self) ->  Vec<Rc<CatchBlockContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn catchBlock(&self, i: usize) -> Option<Rc<CatchBlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TryExpressionContextAttrs<'input> for TryExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tryExpression(&mut self,)
	-> Result<Rc<TryExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TryExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 262, RULE_tryExpression);
        let mut _localctx: Rc<TryExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3132);
			recog.base.match_token(TRY,&mut recog.err_handler)?;

			recog.base.set_state(3136);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(3133);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(3138);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule block*/
			recog.base.set_state(3139);
			recog.block()?;

			recog.base.set_state(3167);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(488,&mut recog.base)? {
				1 =>{
					{
					recog.base.set_state(3147); 
					recog.err_handler.sync(&mut recog.base)?;
					_alt = 1;
					loop {
						match _alt {
						    x if x == 1=>
							{
							{
							recog.base.set_state(3143);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(3140);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(3145);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							/*InvokeRule catchBlock*/
							recog.base.set_state(3146);
							recog.catchBlock()?;

							}
							}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
						}
						recog.base.set_state(3149); 
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(484,&mut recog.base)?;
						if _alt==2 || _alt==INVALID_ALT { break }
					}
					recog.base.set_state(3158);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(486,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(3154);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==NL {
								{
								{
								recog.base.set_state(3151);
								recog.base.match_token(NL,&mut recog.err_handler)?;

								}
								}
								recog.base.set_state(3156);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							/*InvokeRule finallyBlock*/
							recog.base.set_state(3157);
							recog.finallyBlock()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				2 =>{
					{
					recog.base.set_state(3163);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3160);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3165);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule finallyBlock*/
					recog.base.set_state(3166);
					recog.finallyBlock()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- catchBlock ----------------
pub type CatchBlockContextAll<'input> = CatchBlockContext<'input>;


pub type CatchBlockContext<'input> = BaseParserRuleContext<'input,CatchBlockContextExt<'input>>;

#[derive(Clone)]
pub struct CatchBlockContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for CatchBlockContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for CatchBlockContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_catchBlock(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_catchBlock(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for CatchBlockContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_catchBlock(self);
	}
}

impl<'input> CustomRuleContext<'input> for CatchBlockContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_catchBlock }
	//fn type_rule_index() -> usize where Self: Sized { RULE_catchBlock }
}
antlr_rust::tid!{CatchBlockContextExt<'a>}

impl<'input> CatchBlockContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CatchBlockContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CatchBlockContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CatchBlockContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<CatchBlockContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CATCH
/// Returns `None` if there is no child corresponding to token CATCH
fn CATCH(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CATCH, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn rustType(&self) -> Option<Rc<RustTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}

}

impl<'input> CatchBlockContextAttrs<'input> for CatchBlockContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn catchBlock(&mut self,)
	-> Result<Rc<CatchBlockContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CatchBlockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 264, RULE_catchBlock);
        let mut _localctx: Rc<CatchBlockContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3169);
			recog.base.match_token(CATCH,&mut recog.err_handler)?;

			recog.base.set_state(3173);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(3170);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(3175);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(3176);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(3180);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AT_NO_WS || _la==AT_PRE_WS {
				{
				{
				/*InvokeRule annotation*/
				recog.base.set_state(3177);
				recog.annotation()?;

				}
				}
				recog.base.set_state(3182);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(3183);
			recog.simpleIdentifier()?;

			recog.base.set_state(3184);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			/*InvokeRule rustType*/
			recog.base.set_state(3185);
			recog.rustType()?;

			recog.base.set_state(3193);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==NL || _la==COMMA {
				{
				recog.base.set_state(3189);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				while _la==NL {
					{
					{
					recog.base.set_state(3186);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					}
					recog.base.set_state(3191);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
				}
				recog.base.set_state(3192);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(3195);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			recog.base.set_state(3199);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(3196);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(3201);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule block*/
			recog.base.set_state(3202);
			recog.block()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- finallyBlock ----------------
pub type FinallyBlockContextAll<'input> = FinallyBlockContext<'input>;


pub type FinallyBlockContext<'input> = BaseParserRuleContext<'input,FinallyBlockContextExt<'input>>;

#[derive(Clone)]
pub struct FinallyBlockContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FinallyBlockContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FinallyBlockContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_finallyBlock(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_finallyBlock(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FinallyBlockContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_finallyBlock(self);
	}
}

impl<'input> CustomRuleContext<'input> for FinallyBlockContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_finallyBlock }
	//fn type_rule_index() -> usize where Self: Sized { RULE_finallyBlock }
}
antlr_rust::tid!{FinallyBlockContextExt<'a>}

impl<'input> FinallyBlockContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FinallyBlockContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FinallyBlockContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FinallyBlockContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FinallyBlockContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FINALLY
/// Returns `None` if there is no child corresponding to token FINALLY
fn FINALLY(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FINALLY, 0)
}
fn block(&self) -> Option<Rc<BlockContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> FinallyBlockContextAttrs<'input> for FinallyBlockContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn finallyBlock(&mut self,)
	-> Result<Rc<FinallyBlockContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FinallyBlockContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 266, RULE_finallyBlock);
        let mut _localctx: Rc<FinallyBlockContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3204);
			recog.base.match_token(FINALLY,&mut recog.err_handler)?;

			recog.base.set_state(3208);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(3205);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(3210);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule block*/
			recog.base.set_state(3211);
			recog.block()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- jumpExpression ----------------
pub type JumpExpressionContextAll<'input> = JumpExpressionContext<'input>;


pub type JumpExpressionContext<'input> = BaseParserRuleContext<'input,JumpExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct JumpExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for JumpExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for JumpExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_jumpExpression(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_jumpExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for JumpExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_jumpExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for JumpExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_jumpExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_jumpExpression }
}
antlr_rust::tid!{JumpExpressionContextExt<'a>}

impl<'input> JumpExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<JumpExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,JumpExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait JumpExpressionContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<JumpExpressionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token THROW
/// Returns `None` if there is no child corresponding to token THROW
fn THROW(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(THROW, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
/// Retrieves first TerminalNode corresponding to token RETURN
/// Returns `None` if there is no child corresponding to token RETURN
fn RETURN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RETURN, 0)
}
/// Retrieves first TerminalNode corresponding to token RETURN_AT
/// Returns `None` if there is no child corresponding to token RETURN_AT
fn RETURN_AT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RETURN_AT, 0)
}
/// Retrieves first TerminalNode corresponding to token CONTINUE
/// Returns `None` if there is no child corresponding to token CONTINUE
fn CONTINUE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CONTINUE, 0)
}
/// Retrieves first TerminalNode corresponding to token CONTINUE_AT
/// Returns `None` if there is no child corresponding to token CONTINUE_AT
fn CONTINUE_AT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CONTINUE_AT, 0)
}
/// Retrieves first TerminalNode corresponding to token BREAK
/// Returns `None` if there is no child corresponding to token BREAK
fn BREAK(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(BREAK, 0)
}
/// Retrieves first TerminalNode corresponding to token BREAK_AT
/// Returns `None` if there is no child corresponding to token BREAK_AT
fn BREAK_AT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(BREAK_AT, 0)
}

}

impl<'input> JumpExpressionContextAttrs<'input> for JumpExpressionContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn jumpExpression(&mut self,)
	-> Result<Rc<JumpExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = JumpExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 268, RULE_jumpExpression);
        let mut _localctx: Rc<JumpExpressionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3229);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 THROW 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(3213);
					recog.base.match_token(THROW,&mut recog.err_handler)?;

					recog.base.set_state(3217);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3214);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3219);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule expression*/
					recog.base.set_state(3220);
					recog.expression()?;

					}
				}

			 RETURN_AT | RETURN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3221);
					_la = recog.base.input.la(1);
					if { !(_la==RETURN_AT || _la==RETURN) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(3223);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(496,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule expression*/
							recog.base.set_state(3222);
							recog.expression()?;

							}
						}

						_ => {}
					}
					}
				}

			 CONTINUE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(3225);
					recog.base.match_token(CONTINUE,&mut recog.err_handler)?;

					}
				}

			 CONTINUE_AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(3226);
					recog.base.match_token(CONTINUE_AT,&mut recog.err_handler)?;

					}
				}

			 BREAK 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(3227);
					recog.base.match_token(BREAK,&mut recog.err_handler)?;

					}
				}

			 BREAK_AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(3228);
					recog.base.match_token(BREAK_AT,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- callableReference ----------------
pub type CallableReferenceContextAll<'input> = CallableReferenceContext<'input>;


pub type CallableReferenceContext<'input> = BaseParserRuleContext<'input,CallableReferenceContextExt<'input>>;

#[derive(Clone)]
pub struct CallableReferenceContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for CallableReferenceContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for CallableReferenceContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_callableReference(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_callableReference(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for CallableReferenceContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_callableReference(self);
	}
}

impl<'input> CustomRuleContext<'input> for CallableReferenceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_callableReference }
	//fn type_rule_index() -> usize where Self: Sized { RULE_callableReference }
}
antlr_rust::tid!{CallableReferenceContextExt<'a>}

impl<'input> CallableReferenceContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CallableReferenceContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CallableReferenceContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CallableReferenceContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<CallableReferenceContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token COLONCOLON
/// Returns `None` if there is no child corresponding to token COLONCOLON
fn COLONCOLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLONCOLON, 0)
}
fn simpleIdentifier(&self) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token CLASS
/// Returns `None` if there is no child corresponding to token CLASS
fn CLASS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CLASS, 0)
}
fn receiverType(&self) -> Option<Rc<ReceiverTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> CallableReferenceContextAttrs<'input> for CallableReferenceContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn callableReference(&mut self,)
	-> Result<Rc<CallableReferenceContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CallableReferenceContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 270, RULE_callableReference);
        let mut _localctx: Rc<CallableReferenceContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3232);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << LPAREN) | (1usize << AT_NO_WS) | (1usize << AT_PRE_WS) | (1usize << FILE) | (1usize << FIELD) | (1usize << PROPERTY))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (GET - 64)) | (1usize << (SET - 64)) | (1usize << (RECEIVER - 64)) | (1usize << (PARAM - 64)) | (1usize << (SETPARAM - 64)) | (1usize << (DELEGATE - 64)) | (1usize << (IMPORT - 64)) | (1usize << (CONSTRUCTOR - 64)) | (1usize << (BY - 64)) | (1usize << (COMPANION - 64)) | (1usize << (INIT - 64)) | (1usize << (WHERE - 64)) | (1usize << (CATCH - 64)) | (1usize << (FINALLY - 64)) | (1usize << (OUT - 64)) | (1usize << (DYNAMIC - 64)) | (1usize << (PUBLIC - 64)) | (1usize << (PRIVATE - 64)) | (1usize << (PROTECTED - 64)) | (1usize << (INTERNAL - 64)) | (1usize << (ENUM - 64)) | (1usize << (SEALED - 64)) | (1usize << (ANNOTATION - 64)) | (1usize << (DATA - 64)) | (1usize << (INNER - 64)) | (1usize << (VALUE - 64)) | (1usize << (TAILREC - 64)) | (1usize << (OPERATOR - 64)) | (1usize << (INLINE - 64)) | (1usize << (INFIX - 64)) | (1usize << (EXTERNAL - 64)) | (1usize << (SUSPEND - 64)) | (1usize << (OVERRIDE - 64)) | (1usize << (ABSTRACT - 64)) | (1usize << (FINAL - 64)) | (1usize << (OPEN - 64)) | (1usize << (CONST - 64)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (LATEINIT - 128)) | (1usize << (VARARG - 128)) | (1usize << (NOINLINE - 128)) | (1usize << (CROSSINLINE - 128)) | (1usize << (REIFIED - 128)) | (1usize << (EXPECT - 128)) | (1usize << (ACTUAL - 128)) | (1usize << (Identifier - 128)))) != 0) {
				{
				/*InvokeRule receiverType*/
				recog.base.set_state(3231);
				recog.receiverType()?;

				}
			}

			recog.base.set_state(3234);
			recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

			recog.base.set_state(3238);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(3235);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(3240);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(3243);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 FILE | FIELD | PROPERTY | GET | SET | RECEIVER | PARAM | SETPARAM | DELEGATE |
			 IMPORT | CONSTRUCTOR | BY | COMPANION | INIT | WHERE | CATCH | FINALLY |
			 OUT | DYNAMIC | PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED |
			 ANNOTATION | DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX |
			 EXTERNAL | SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT |
			 VARARG | NOINLINE | CROSSINLINE | REIFIED | EXPECT | ACTUAL | Identifier 
				=> {
					{
					/*InvokeRule simpleIdentifier*/
					recog.base.set_state(3241);
					recog.simpleIdentifier()?;

					}
				}

			 CLASS 
				=> {
					{
					recog.base.set_state(3242);
					recog.base.match_token(CLASS,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignmentAndOperator ----------------
pub type AssignmentAndOperatorContextAll<'input> = AssignmentAndOperatorContext<'input>;


pub type AssignmentAndOperatorContext<'input> = BaseParserRuleContext<'input,AssignmentAndOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct AssignmentAndOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AssignmentAndOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AssignmentAndOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_assignmentAndOperator(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_assignmentAndOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AssignmentAndOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_assignmentAndOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for AssignmentAndOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignmentAndOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignmentAndOperator }
}
antlr_rust::tid!{AssignmentAndOperatorContextExt<'a>}

impl<'input> AssignmentAndOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignmentAndOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignmentAndOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignmentAndOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AssignmentAndOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ADD_ASSIGNMENT
/// Returns `None` if there is no child corresponding to token ADD_ASSIGNMENT
fn ADD_ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ADD_ASSIGNMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token SUB_ASSIGNMENT
/// Returns `None` if there is no child corresponding to token SUB_ASSIGNMENT
fn SUB_ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUB_ASSIGNMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token MULT_ASSIGNMENT
/// Returns `None` if there is no child corresponding to token MULT_ASSIGNMENT
fn MULT_ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MULT_ASSIGNMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token DIV_ASSIGNMENT
/// Returns `None` if there is no child corresponding to token DIV_ASSIGNMENT
fn DIV_ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DIV_ASSIGNMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token MOD_ASSIGNMENT
/// Returns `None` if there is no child corresponding to token MOD_ASSIGNMENT
fn MOD_ASSIGNMENT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MOD_ASSIGNMENT, 0)
}

}

impl<'input> AssignmentAndOperatorContextAttrs<'input> for AssignmentAndOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignmentAndOperator(&mut self,)
	-> Result<Rc<AssignmentAndOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignmentAndOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 272, RULE_assignmentAndOperator);
        let mut _localctx: Rc<AssignmentAndOperatorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3245);
			_la = recog.base.input.la(1);
			if { !((((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ADD_ASSIGNMENT) | (1usize << SUB_ASSIGNMENT) | (1usize << MULT_ASSIGNMENT) | (1usize << DIV_ASSIGNMENT) | (1usize << MOD_ASSIGNMENT))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- equalityOperator ----------------
pub type EqualityOperatorContextAll<'input> = EqualityOperatorContext<'input>;


pub type EqualityOperatorContext<'input> = BaseParserRuleContext<'input,EqualityOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct EqualityOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for EqualityOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for EqualityOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_equalityOperator(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_equalityOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for EqualityOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_equalityOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for EqualityOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_equalityOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_equalityOperator }
}
antlr_rust::tid!{EqualityOperatorContextExt<'a>}

impl<'input> EqualityOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EqualityOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EqualityOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EqualityOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<EqualityOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EXCL_EQ
/// Returns `None` if there is no child corresponding to token EXCL_EQ
fn EXCL_EQ(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EXCL_EQ, 0)
}
/// Retrieves first TerminalNode corresponding to token EXCL_EQEQ
/// Returns `None` if there is no child corresponding to token EXCL_EQEQ
fn EXCL_EQEQ(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EXCL_EQEQ, 0)
}
/// Retrieves first TerminalNode corresponding to token EQEQ
/// Returns `None` if there is no child corresponding to token EQEQ
fn EQEQ(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EQEQ, 0)
}
/// Retrieves first TerminalNode corresponding to token EQEQEQ
/// Returns `None` if there is no child corresponding to token EQEQEQ
fn EQEQEQ(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EQEQEQ, 0)
}

}

impl<'input> EqualityOperatorContextAttrs<'input> for EqualityOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn equalityOperator(&mut self,)
	-> Result<Rc<EqualityOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EqualityOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 274, RULE_equalityOperator);
        let mut _localctx: Rc<EqualityOperatorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3247);
			_la = recog.base.input.la(1);
			if { !((((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << EXCL_EQ) | (1usize << EXCL_EQEQ) | (1usize << EQEQ) | (1usize << EQEQEQ))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- comparisonOperator ----------------
pub type ComparisonOperatorContextAll<'input> = ComparisonOperatorContext<'input>;


pub type ComparisonOperatorContext<'input> = BaseParserRuleContext<'input,ComparisonOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct ComparisonOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ComparisonOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ComparisonOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_comparisonOperator(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_comparisonOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ComparisonOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_comparisonOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for ComparisonOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_comparisonOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_comparisonOperator }
}
antlr_rust::tid!{ComparisonOperatorContextExt<'a>}

impl<'input> ComparisonOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ComparisonOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ComparisonOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ComparisonOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ComparisonOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LANGLE
/// Returns `None` if there is no child corresponding to token LANGLE
fn LANGLE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LANGLE, 0)
}
/// Retrieves first TerminalNode corresponding to token RANGLE
/// Returns `None` if there is no child corresponding to token RANGLE
fn RANGLE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RANGLE, 0)
}
/// Retrieves first TerminalNode corresponding to token LE
/// Returns `None` if there is no child corresponding to token LE
fn LE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LE, 0)
}
/// Retrieves first TerminalNode corresponding to token GE
/// Returns `None` if there is no child corresponding to token GE
fn GE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(GE, 0)
}

}

impl<'input> ComparisonOperatorContextAttrs<'input> for ComparisonOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn comparisonOperator(&mut self,)
	-> Result<Rc<ComparisonOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ComparisonOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 276, RULE_comparisonOperator);
        let mut _localctx: Rc<ComparisonOperatorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3249);
			_la = recog.base.input.la(1);
			if { !((((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << LANGLE) | (1usize << RANGLE) | (1usize << LE) | (1usize << GE))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- inOperator ----------------
pub type InOperatorContextAll<'input> = InOperatorContext<'input>;


pub type InOperatorContext<'input> = BaseParserRuleContext<'input,InOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct InOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for InOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for InOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_inOperator(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_inOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for InOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_inOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for InOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_inOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_inOperator }
}
antlr_rust::tid!{InOperatorContextExt<'a>}

impl<'input> InOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<InOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IN
/// Returns `None` if there is no child corresponding to token IN
fn IN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(IN, 0)
}
/// Retrieves first TerminalNode corresponding to token NOT_IN
/// Returns `None` if there is no child corresponding to token NOT_IN
fn NOT_IN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NOT_IN, 0)
}

}

impl<'input> InOperatorContextAttrs<'input> for InOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn inOperator(&mut self,)
	-> Result<Rc<InOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 278, RULE_inOperator);
        let mut _localctx: Rc<InOperatorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3251);
			_la = recog.base.input.la(1);
			if { !(_la==IN || _la==NOT_IN) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- isOperator ----------------
pub type IsOperatorContextAll<'input> = IsOperatorContext<'input>;


pub type IsOperatorContext<'input> = BaseParserRuleContext<'input,IsOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct IsOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for IsOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for IsOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_isOperator(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_isOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for IsOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_isOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for IsOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_isOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_isOperator }
}
antlr_rust::tid!{IsOperatorContextExt<'a>}

impl<'input> IsOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IsOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IsOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IsOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<IsOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IS
/// Returns `None` if there is no child corresponding to token IS
fn IS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(IS, 0)
}
/// Retrieves first TerminalNode corresponding to token NOT_IS
/// Returns `None` if there is no child corresponding to token NOT_IS
fn NOT_IS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NOT_IS, 0)
}

}

impl<'input> IsOperatorContextAttrs<'input> for IsOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn isOperator(&mut self,)
	-> Result<Rc<IsOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IsOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 280, RULE_isOperator);
        let mut _localctx: Rc<IsOperatorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3253);
			_la = recog.base.input.la(1);
			if { !(_la==IS || _la==NOT_IS) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- additiveOperator ----------------
pub type AdditiveOperatorContextAll<'input> = AdditiveOperatorContext<'input>;


pub type AdditiveOperatorContext<'input> = BaseParserRuleContext<'input,AdditiveOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct AdditiveOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AdditiveOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AdditiveOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_additiveOperator(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_additiveOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AdditiveOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_additiveOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for AdditiveOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_additiveOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_additiveOperator }
}
antlr_rust::tid!{AdditiveOperatorContextExt<'a>}

impl<'input> AdditiveOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AdditiveOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AdditiveOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AdditiveOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AdditiveOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ADD
/// Returns `None` if there is no child corresponding to token ADD
fn ADD(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ADD, 0)
}
/// Retrieves first TerminalNode corresponding to token SUB
/// Returns `None` if there is no child corresponding to token SUB
fn SUB(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUB, 0)
}

}

impl<'input> AdditiveOperatorContextAttrs<'input> for AdditiveOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn additiveOperator(&mut self,)
	-> Result<Rc<AdditiveOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AdditiveOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 282, RULE_additiveOperator);
        let mut _localctx: Rc<AdditiveOperatorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3255);
			_la = recog.base.input.la(1);
			if { !(_la==ADD || _la==SUB) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- multiplicativeOperator ----------------
pub type MultiplicativeOperatorContextAll<'input> = MultiplicativeOperatorContext<'input>;


pub type MultiplicativeOperatorContext<'input> = BaseParserRuleContext<'input,MultiplicativeOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct MultiplicativeOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for MultiplicativeOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for MultiplicativeOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_multiplicativeOperator(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_multiplicativeOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for MultiplicativeOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_multiplicativeOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for MultiplicativeOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_multiplicativeOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_multiplicativeOperator }
}
antlr_rust::tid!{MultiplicativeOperatorContextExt<'a>}

impl<'input> MultiplicativeOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MultiplicativeOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MultiplicativeOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MultiplicativeOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<MultiplicativeOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token MULT
/// Returns `None` if there is no child corresponding to token MULT
fn MULT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MULT, 0)
}
/// Retrieves first TerminalNode corresponding to token DIV
/// Returns `None` if there is no child corresponding to token DIV
fn DIV(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DIV, 0)
}
/// Retrieves first TerminalNode corresponding to token MOD
/// Returns `None` if there is no child corresponding to token MOD
fn MOD(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(MOD, 0)
}

}

impl<'input> MultiplicativeOperatorContextAttrs<'input> for MultiplicativeOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn multiplicativeOperator(&mut self,)
	-> Result<Rc<MultiplicativeOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MultiplicativeOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 284, RULE_multiplicativeOperator);
        let mut _localctx: Rc<MultiplicativeOperatorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3257);
			_la = recog.base.input.la(1);
			if { !((((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << MULT) | (1usize << MOD) | (1usize << DIV))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- asOperator ----------------
pub type AsOperatorContextAll<'input> = AsOperatorContext<'input>;


pub type AsOperatorContext<'input> = BaseParserRuleContext<'input,AsOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct AsOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AsOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AsOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_asOperator(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_asOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AsOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_asOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for AsOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_asOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_asOperator }
}
antlr_rust::tid!{AsOperatorContextExt<'a>}

impl<'input> AsOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AsOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AsOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AsOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AsOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token AS
/// Returns `None` if there is no child corresponding to token AS
fn AS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AS, 0)
}
/// Retrieves first TerminalNode corresponding to token AS_SAFE
/// Returns `None` if there is no child corresponding to token AS_SAFE
fn AS_SAFE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AS_SAFE, 0)
}

}

impl<'input> AsOperatorContextAttrs<'input> for AsOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn asOperator(&mut self,)
	-> Result<Rc<AsOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AsOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 286, RULE_asOperator);
        let mut _localctx: Rc<AsOperatorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3259);
			_la = recog.base.input.la(1);
			if { !(_la==AS_SAFE || _la==AS) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- prefixUnaryOperator ----------------
pub type PrefixUnaryOperatorContextAll<'input> = PrefixUnaryOperatorContext<'input>;


pub type PrefixUnaryOperatorContext<'input> = BaseParserRuleContext<'input,PrefixUnaryOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct PrefixUnaryOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PrefixUnaryOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PrefixUnaryOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_prefixUnaryOperator(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_prefixUnaryOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PrefixUnaryOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_prefixUnaryOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for PrefixUnaryOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_prefixUnaryOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_prefixUnaryOperator }
}
antlr_rust::tid!{PrefixUnaryOperatorContextExt<'a>}

impl<'input> PrefixUnaryOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrefixUnaryOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrefixUnaryOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrefixUnaryOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PrefixUnaryOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INCR
/// Returns `None` if there is no child corresponding to token INCR
fn INCR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INCR, 0)
}
/// Retrieves first TerminalNode corresponding to token DECR
/// Returns `None` if there is no child corresponding to token DECR
fn DECR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DECR, 0)
}
/// Retrieves first TerminalNode corresponding to token SUB
/// Returns `None` if there is no child corresponding to token SUB
fn SUB(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUB, 0)
}
/// Retrieves first TerminalNode corresponding to token ADD
/// Returns `None` if there is no child corresponding to token ADD
fn ADD(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ADD, 0)
}
fn excl(&self) -> Option<Rc<ExclContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PrefixUnaryOperatorContextAttrs<'input> for PrefixUnaryOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn prefixUnaryOperator(&mut self,)
	-> Result<Rc<PrefixUnaryOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrefixUnaryOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 288, RULE_prefixUnaryOperator);
        let mut _localctx: Rc<PrefixUnaryOperatorContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3266);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 INCR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(3261);
					recog.base.match_token(INCR,&mut recog.err_handler)?;

					}
				}

			 DECR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3262);
					recog.base.match_token(DECR,&mut recog.err_handler)?;

					}
				}

			 SUB 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(3263);
					recog.base.match_token(SUB,&mut recog.err_handler)?;

					}
				}

			 ADD 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(3264);
					recog.base.match_token(ADD,&mut recog.err_handler)?;

					}
				}

			 EXCL_WS | EXCL_NO_WS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule excl*/
					recog.base.set_state(3265);
					recog.excl()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- postfixUnaryOperator ----------------
pub type PostfixUnaryOperatorContextAll<'input> = PostfixUnaryOperatorContext<'input>;


pub type PostfixUnaryOperatorContext<'input> = BaseParserRuleContext<'input,PostfixUnaryOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct PostfixUnaryOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PostfixUnaryOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PostfixUnaryOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_postfixUnaryOperator(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_postfixUnaryOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PostfixUnaryOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_postfixUnaryOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for PostfixUnaryOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_postfixUnaryOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_postfixUnaryOperator }
}
antlr_rust::tid!{PostfixUnaryOperatorContextExt<'a>}

impl<'input> PostfixUnaryOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PostfixUnaryOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PostfixUnaryOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PostfixUnaryOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PostfixUnaryOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INCR
/// Returns `None` if there is no child corresponding to token INCR
fn INCR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INCR, 0)
}
/// Retrieves first TerminalNode corresponding to token DECR
/// Returns `None` if there is no child corresponding to token DECR
fn DECR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DECR, 0)
}
/// Retrieves first TerminalNode corresponding to token EXCL_NO_WS
/// Returns `None` if there is no child corresponding to token EXCL_NO_WS
fn EXCL_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EXCL_NO_WS, 0)
}
fn excl(&self) -> Option<Rc<ExclContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PostfixUnaryOperatorContextAttrs<'input> for PostfixUnaryOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn postfixUnaryOperator(&mut self,)
	-> Result<Rc<PostfixUnaryOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PostfixUnaryOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 290, RULE_postfixUnaryOperator);
        let mut _localctx: Rc<PostfixUnaryOperatorContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3272);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 INCR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(3268);
					recog.base.match_token(INCR,&mut recog.err_handler)?;

					}
				}

			 DECR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3269);
					recog.base.match_token(DECR,&mut recog.err_handler)?;

					}
				}

			 EXCL_NO_WS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(3270);
					recog.base.match_token(EXCL_NO_WS,&mut recog.err_handler)?;

					/*InvokeRule excl*/
					recog.base.set_state(3271);
					recog.excl()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- excl ----------------
pub type ExclContextAll<'input> = ExclContext<'input>;


pub type ExclContext<'input> = BaseParserRuleContext<'input,ExclContextExt<'input>>;

#[derive(Clone)]
pub struct ExclContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ExclContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ExclContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_excl(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_excl(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ExclContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_excl(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExclContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_excl }
	//fn type_rule_index() -> usize where Self: Sized { RULE_excl }
}
antlr_rust::tid!{ExclContextExt<'a>}

impl<'input> ExclContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExclContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExclContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExclContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ExclContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EXCL_NO_WS
/// Returns `None` if there is no child corresponding to token EXCL_NO_WS
fn EXCL_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EXCL_NO_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token EXCL_WS
/// Returns `None` if there is no child corresponding to token EXCL_WS
fn EXCL_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EXCL_WS, 0)
}

}

impl<'input> ExclContextAttrs<'input> for ExclContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn excl(&mut self,)
	-> Result<Rc<ExclContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExclContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 292, RULE_excl);
        let mut _localctx: Rc<ExclContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3274);
			_la = recog.base.input.la(1);
			if { !(_la==EXCL_WS || _la==EXCL_NO_WS) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- memberAccessOperator ----------------
pub type MemberAccessOperatorContextAll<'input> = MemberAccessOperatorContext<'input>;


pub type MemberAccessOperatorContext<'input> = BaseParserRuleContext<'input,MemberAccessOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct MemberAccessOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for MemberAccessOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for MemberAccessOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_memberAccessOperator(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_memberAccessOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for MemberAccessOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_memberAccessOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for MemberAccessOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_memberAccessOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_memberAccessOperator }
}
antlr_rust::tid!{MemberAccessOperatorContextExt<'a>}

impl<'input> MemberAccessOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MemberAccessOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MemberAccessOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MemberAccessOperatorContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<MemberAccessOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn safeNav(&self) -> Option<Rc<SafeNavContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLONCOLON
/// Returns `None` if there is no child corresponding to token COLONCOLON
fn COLONCOLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLONCOLON, 0)
}

}

impl<'input> MemberAccessOperatorContextAttrs<'input> for MemberAccessOperatorContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn memberAccessOperator(&mut self,)
	-> Result<Rc<MemberAccessOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MemberAccessOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 294, RULE_memberAccessOperator);
        let mut _localctx: Rc<MemberAccessOperatorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3291);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(505,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(3279);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3276);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3281);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(3282);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3286);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3283);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3288);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					/*InvokeRule safeNav*/
					recog.base.set_state(3289);
					recog.safeNav()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(3290);
					recog.base.match_token(COLONCOLON,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- safeNav ----------------
pub type SafeNavContextAll<'input> = SafeNavContext<'input>;


pub type SafeNavContext<'input> = BaseParserRuleContext<'input,SafeNavContextExt<'input>>;

#[derive(Clone)]
pub struct SafeNavContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for SafeNavContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for SafeNavContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_safeNav(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_safeNav(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for SafeNavContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_safeNav(self);
	}
}

impl<'input> CustomRuleContext<'input> for SafeNavContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_safeNav }
	//fn type_rule_index() -> usize where Self: Sized { RULE_safeNav }
}
antlr_rust::tid!{SafeNavContextExt<'a>}

impl<'input> SafeNavContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SafeNavContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SafeNavContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SafeNavContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<SafeNavContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token QUEST_NO_WS
/// Returns `None` if there is no child corresponding to token QUEST_NO_WS
fn QUEST_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(QUEST_NO_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}

}

impl<'input> SafeNavContextAttrs<'input> for SafeNavContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn safeNav(&mut self,)
	-> Result<Rc<SafeNavContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SafeNavContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 296, RULE_safeNav);
        let mut _localctx: Rc<SafeNavContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3293);
			recog.base.match_token(QUEST_NO_WS,&mut recog.err_handler)?;

			recog.base.set_state(3294);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- modifiers ----------------
pub type ModifiersContextAll<'input> = ModifiersContext<'input>;


pub type ModifiersContext<'input> = BaseParserRuleContext<'input,ModifiersContextExt<'input>>;

#[derive(Clone)]
pub struct ModifiersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ModifiersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ModifiersContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_modifiers(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_modifiers(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ModifiersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_modifiers(self);
	}
}

impl<'input> CustomRuleContext<'input> for ModifiersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_modifiers }
	//fn type_rule_index() -> usize where Self: Sized { RULE_modifiers }
}
antlr_rust::tid!{ModifiersContextExt<'a>}

impl<'input> ModifiersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ModifiersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ModifiersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ModifiersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ModifiersContextExt<'input>>{

fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn modifier_all(&self) ->  Vec<Rc<ModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn modifier(&self, i: usize) -> Option<Rc<ModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ModifiersContextAttrs<'input> for ModifiersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn modifiers(&mut self,)
	-> Result<Rc<ModifiersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ModifiersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 298, RULE_modifiers);
        let mut _localctx: Rc<ModifiersContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3298); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					recog.base.set_state(3298);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 AT_NO_WS | AT_PRE_WS 
						=> {
							{
							/*InvokeRule annotation*/
							recog.base.set_state(3296);
							recog.annotation()?;

							}
						}

					 PUBLIC | PRIVATE | PROTECTED | INTERNAL | ENUM | SEALED | ANNOTATION |
					 DATA | INNER | VALUE | TAILREC | OPERATOR | INLINE | INFIX | EXTERNAL |
					 SUSPEND | OVERRIDE | ABSTRACT | FINAL | OPEN | CONST | LATEINIT | VARARG |
					 NOINLINE | CROSSINLINE | EXPECT | ACTUAL 
						=> {
							{
							/*InvokeRule modifier*/
							recog.base.set_state(3297);
							recog.modifier()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(3300); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(507,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parameterModifiers ----------------
pub type ParameterModifiersContextAll<'input> = ParameterModifiersContext<'input>;


pub type ParameterModifiersContext<'input> = BaseParserRuleContext<'input,ParameterModifiersContextExt<'input>>;

#[derive(Clone)]
pub struct ParameterModifiersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParameterModifiersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParameterModifiersContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_parameterModifiers(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_parameterModifiers(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParameterModifiersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parameterModifiers(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParameterModifiersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parameterModifiers }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parameterModifiers }
}
antlr_rust::tid!{ParameterModifiersContextExt<'a>}

impl<'input> ParameterModifiersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParameterModifiersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParameterModifiersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParameterModifiersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParameterModifiersContextExt<'input>>{

fn annotation_all(&self) ->  Vec<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotation(&self, i: usize) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn parameterModifier_all(&self) ->  Vec<Rc<ParameterModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn parameterModifier(&self, i: usize) -> Option<Rc<ParameterModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ParameterModifiersContextAttrs<'input> for ParameterModifiersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parameterModifiers(&mut self,)
	-> Result<Rc<ParameterModifiersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParameterModifiersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 300, RULE_parameterModifiers);
        let mut _localctx: Rc<ParameterModifiersContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3304); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					recog.base.set_state(3304);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 AT_NO_WS | AT_PRE_WS 
						=> {
							{
							/*InvokeRule annotation*/
							recog.base.set_state(3302);
							recog.annotation()?;

							}
						}

					 VARARG | NOINLINE | CROSSINLINE 
						=> {
							{
							/*InvokeRule parameterModifier*/
							recog.base.set_state(3303);
							recog.parameterModifier()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(3306); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(509,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- modifier ----------------
pub type ModifierContextAll<'input> = ModifierContext<'input>;


pub type ModifierContext<'input> = BaseParserRuleContext<'input,ModifierContextExt<'input>>;

#[derive(Clone)]
pub struct ModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_modifier(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_modifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_modifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for ModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_modifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_modifier }
}
antlr_rust::tid!{ModifierContextExt<'a>}

impl<'input> ModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ModifierContextExt<'input>>{

fn classModifier(&self) -> Option<Rc<ClassModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn memberModifier(&self) -> Option<Rc<MemberModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn visibilityModifier(&self) -> Option<Rc<VisibilityModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn functionModifier(&self) -> Option<Rc<FunctionModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn propertyModifier(&self) -> Option<Rc<PropertyModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn inheritanceModifier(&self) -> Option<Rc<InheritanceModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn parameterModifier(&self) -> Option<Rc<ParameterModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn platformModifier(&self) -> Option<Rc<PlatformModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> ModifierContextAttrs<'input> for ModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn modifier(&mut self,)
	-> Result<Rc<ModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 302, RULE_modifier);
        let mut _localctx: Rc<ModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3316);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 ENUM | SEALED | ANNOTATION | DATA | INNER | VALUE 
				=> {
					{
					/*InvokeRule classModifier*/
					recog.base.set_state(3308);
					recog.classModifier()?;

					}
				}

			 OVERRIDE | LATEINIT 
				=> {
					{
					/*InvokeRule memberModifier*/
					recog.base.set_state(3309);
					recog.memberModifier()?;

					}
				}

			 PUBLIC | PRIVATE | PROTECTED | INTERNAL 
				=> {
					{
					/*InvokeRule visibilityModifier*/
					recog.base.set_state(3310);
					recog.visibilityModifier()?;

					}
				}

			 TAILREC | OPERATOR | INLINE | INFIX | EXTERNAL | SUSPEND 
				=> {
					{
					/*InvokeRule functionModifier*/
					recog.base.set_state(3311);
					recog.functionModifier()?;

					}
				}

			 CONST 
				=> {
					{
					/*InvokeRule propertyModifier*/
					recog.base.set_state(3312);
					recog.propertyModifier()?;

					}
				}

			 ABSTRACT | FINAL | OPEN 
				=> {
					{
					/*InvokeRule inheritanceModifier*/
					recog.base.set_state(3313);
					recog.inheritanceModifier()?;

					}
				}

			 VARARG | NOINLINE | CROSSINLINE 
				=> {
					{
					/*InvokeRule parameterModifier*/
					recog.base.set_state(3314);
					recog.parameterModifier()?;

					}
				}

			 EXPECT | ACTUAL 
				=> {
					{
					/*InvokeRule platformModifier*/
					recog.base.set_state(3315);
					recog.platformModifier()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			recog.base.set_state(3321);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(511,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(3318);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(3323);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(511,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeModifiers ----------------
pub type TypeModifiersContextAll<'input> = TypeModifiersContext<'input>;


pub type TypeModifiersContext<'input> = BaseParserRuleContext<'input,TypeModifiersContextExt<'input>>;

#[derive(Clone)]
pub struct TypeModifiersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeModifiersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeModifiersContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeModifiers(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_typeModifiers(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeModifiersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeModifiers(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeModifiersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeModifiers }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeModifiers }
}
antlr_rust::tid!{TypeModifiersContextExt<'a>}

impl<'input> TypeModifiersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeModifiersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeModifiersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeModifiersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeModifiersContextExt<'input>>{

fn typeModifier_all(&self) ->  Vec<Rc<TypeModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeModifier(&self, i: usize) -> Option<Rc<TypeModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TypeModifiersContextAttrs<'input> for TypeModifiersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeModifiers(&mut self,)
	-> Result<Rc<TypeModifiersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeModifiersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 304, RULE_typeModifiers);
        let mut _localctx: Rc<TypeModifiersContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3325); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					{
					/*InvokeRule typeModifier*/
					recog.base.set_state(3324);
					recog.typeModifier()?;

					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(3327); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(512,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeModifier ----------------
pub type TypeModifierContextAll<'input> = TypeModifierContext<'input>;


pub type TypeModifierContext<'input> = BaseParserRuleContext<'input,TypeModifierContextExt<'input>>;

#[derive(Clone)]
pub struct TypeModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeModifier(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_typeModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeModifier }
}
antlr_rust::tid!{TypeModifierContextExt<'a>}

impl<'input> TypeModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeModifierContextExt<'input>>{

fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SUSPEND
/// Returns `None` if there is no child corresponding to token SUSPEND
fn SUSPEND(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUSPEND, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> TypeModifierContextAttrs<'input> for TypeModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeModifier(&mut self,)
	-> Result<Rc<TypeModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 306, RULE_typeModifier);
        let mut _localctx: Rc<TypeModifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3337);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT_NO_WS | AT_PRE_WS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(3329);
					recog.annotation()?;

					}
				}

			 SUSPEND 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3330);
					recog.base.match_token(SUSPEND,&mut recog.err_handler)?;

					recog.base.set_state(3334);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3331);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3336);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classModifier ----------------
pub type ClassModifierContextAll<'input> = ClassModifierContext<'input>;


pub type ClassModifierContext<'input> = BaseParserRuleContext<'input,ClassModifierContextExt<'input>>;

#[derive(Clone)]
pub struct ClassModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ClassModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ClassModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classModifier(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_classModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ClassModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_classModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for ClassModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classModifier }
}
antlr_rust::tid!{ClassModifierContextExt<'a>}

impl<'input> ClassModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ClassModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ENUM
/// Returns `None` if there is no child corresponding to token ENUM
fn ENUM(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ENUM, 0)
}
/// Retrieves first TerminalNode corresponding to token SEALED
/// Returns `None` if there is no child corresponding to token SEALED
fn SEALED(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SEALED, 0)
}
/// Retrieves first TerminalNode corresponding to token ANNOTATION
/// Returns `None` if there is no child corresponding to token ANNOTATION
fn ANNOTATION(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ANNOTATION, 0)
}
/// Retrieves first TerminalNode corresponding to token DATA
/// Returns `None` if there is no child corresponding to token DATA
fn DATA(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DATA, 0)
}
/// Retrieves first TerminalNode corresponding to token INNER
/// Returns `None` if there is no child corresponding to token INNER
fn INNER(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INNER, 0)
}
/// Retrieves first TerminalNode corresponding to token VALUE
/// Returns `None` if there is no child corresponding to token VALUE
fn VALUE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(VALUE, 0)
}

}

impl<'input> ClassModifierContextAttrs<'input> for ClassModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classModifier(&mut self,)
	-> Result<Rc<ClassModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 308, RULE_classModifier);
        let mut _localctx: Rc<ClassModifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3339);
			_la = recog.base.input.la(1);
			if { !(((((_la - 111)) & !0x3f) == 0 && ((1usize << (_la - 111)) & ((1usize << (ENUM - 111)) | (1usize << (SEALED - 111)) | (1usize << (ANNOTATION - 111)) | (1usize << (DATA - 111)) | (1usize << (INNER - 111)) | (1usize << (VALUE - 111)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- memberModifier ----------------
pub type MemberModifierContextAll<'input> = MemberModifierContext<'input>;


pub type MemberModifierContext<'input> = BaseParserRuleContext<'input,MemberModifierContextExt<'input>>;

#[derive(Clone)]
pub struct MemberModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for MemberModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for MemberModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_memberModifier(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_memberModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for MemberModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_memberModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for MemberModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_memberModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_memberModifier }
}
antlr_rust::tid!{MemberModifierContextExt<'a>}

impl<'input> MemberModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MemberModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MemberModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MemberModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<MemberModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OVERRIDE
/// Returns `None` if there is no child corresponding to token OVERRIDE
fn OVERRIDE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OVERRIDE, 0)
}
/// Retrieves first TerminalNode corresponding to token LATEINIT
/// Returns `None` if there is no child corresponding to token LATEINIT
fn LATEINIT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LATEINIT, 0)
}

}

impl<'input> MemberModifierContextAttrs<'input> for MemberModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn memberModifier(&mut self,)
	-> Result<Rc<MemberModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MemberModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 310, RULE_memberModifier);
        let mut _localctx: Rc<MemberModifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3341);
			_la = recog.base.input.la(1);
			if { !(_la==OVERRIDE || _la==LATEINIT) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- visibilityModifier ----------------
pub type VisibilityModifierContextAll<'input> = VisibilityModifierContext<'input>;


pub type VisibilityModifierContext<'input> = BaseParserRuleContext<'input,VisibilityModifierContextExt<'input>>;

#[derive(Clone)]
pub struct VisibilityModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for VisibilityModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for VisibilityModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_visibilityModifier(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_visibilityModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for VisibilityModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_visibilityModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for VisibilityModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_visibilityModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_visibilityModifier }
}
antlr_rust::tid!{VisibilityModifierContextExt<'a>}

impl<'input> VisibilityModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VisibilityModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VisibilityModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VisibilityModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<VisibilityModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVATE
/// Returns `None` if there is no child corresponding to token PRIVATE
fn PRIVATE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PRIVATE, 0)
}
/// Retrieves first TerminalNode corresponding to token INTERNAL
/// Returns `None` if there is no child corresponding to token INTERNAL
fn INTERNAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INTERNAL, 0)
}
/// Retrieves first TerminalNode corresponding to token PROTECTED
/// Returns `None` if there is no child corresponding to token PROTECTED
fn PROTECTED(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PROTECTED, 0)
}

}

impl<'input> VisibilityModifierContextAttrs<'input> for VisibilityModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn visibilityModifier(&mut self,)
	-> Result<Rc<VisibilityModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VisibilityModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 312, RULE_visibilityModifier);
        let mut _localctx: Rc<VisibilityModifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3343);
			_la = recog.base.input.la(1);
			if { !(((((_la - 107)) & !0x3f) == 0 && ((1usize << (_la - 107)) & ((1usize << (PUBLIC - 107)) | (1usize << (PRIVATE - 107)) | (1usize << (PROTECTED - 107)) | (1usize << (INTERNAL - 107)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- varianceModifier ----------------
pub type VarianceModifierContextAll<'input> = VarianceModifierContext<'input>;


pub type VarianceModifierContext<'input> = BaseParserRuleContext<'input,VarianceModifierContextExt<'input>>;

#[derive(Clone)]
pub struct VarianceModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for VarianceModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for VarianceModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_varianceModifier(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_varianceModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for VarianceModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_varianceModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for VarianceModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_varianceModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_varianceModifier }
}
antlr_rust::tid!{VarianceModifierContextExt<'a>}

impl<'input> VarianceModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VarianceModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VarianceModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VarianceModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<VarianceModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IN
/// Returns `None` if there is no child corresponding to token IN
fn IN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(IN, 0)
}
/// Retrieves first TerminalNode corresponding to token OUT
/// Returns `None` if there is no child corresponding to token OUT
fn OUT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OUT, 0)
}

}

impl<'input> VarianceModifierContextAttrs<'input> for VarianceModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn varianceModifier(&mut self,)
	-> Result<Rc<VarianceModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VarianceModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 314, RULE_varianceModifier);
        let mut _localctx: Rc<VarianceModifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3345);
			_la = recog.base.input.la(1);
			if { !(_la==IN || _la==OUT) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeParameterModifiers ----------------
pub type TypeParameterModifiersContextAll<'input> = TypeParameterModifiersContext<'input>;


pub type TypeParameterModifiersContext<'input> = BaseParserRuleContext<'input,TypeParameterModifiersContextExt<'input>>;

#[derive(Clone)]
pub struct TypeParameterModifiersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeParameterModifiersContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeParameterModifiersContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeParameterModifiers(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_typeParameterModifiers(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeParameterModifiersContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeParameterModifiers(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeParameterModifiersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeParameterModifiers }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeParameterModifiers }
}
antlr_rust::tid!{TypeParameterModifiersContextExt<'a>}

impl<'input> TypeParameterModifiersContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeParameterModifiersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeParameterModifiersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeParameterModifiersContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeParameterModifiersContextExt<'input>>{

fn typeParameterModifier_all(&self) ->  Vec<Rc<TypeParameterModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn typeParameterModifier(&self, i: usize) -> Option<Rc<TypeParameterModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> TypeParameterModifiersContextAttrs<'input> for TypeParameterModifiersContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeParameterModifiers(&mut self,)
	-> Result<Rc<TypeParameterModifiersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeParameterModifiersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 316, RULE_typeParameterModifiers);
        let mut _localctx: Rc<TypeParameterModifiersContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3348); 
			recog.err_handler.sync(&mut recog.base)?;
			_alt = 1;
			loop {
				match _alt {
				    x if x == 1=>
					{
					{
					/*InvokeRule typeParameterModifier*/
					recog.base.set_state(3347);
					recog.typeParameterModifier()?;

					}
					}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				recog.base.set_state(3350); 
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(515,&mut recog.base)?;
				if _alt==2 || _alt==INVALID_ALT { break }
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeParameterModifier ----------------
pub type TypeParameterModifierContextAll<'input> = TypeParameterModifierContext<'input>;


pub type TypeParameterModifierContext<'input> = BaseParserRuleContext<'input,TypeParameterModifierContextExt<'input>>;

#[derive(Clone)]
pub struct TypeParameterModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for TypeParameterModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for TypeParameterModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeParameterModifier(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_typeParameterModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for TypeParameterModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_typeParameterModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeParameterModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeParameterModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeParameterModifier }
}
antlr_rust::tid!{TypeParameterModifierContextExt<'a>}

impl<'input> TypeParameterModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeParameterModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeParameterModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeParameterModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<TypeParameterModifierContextExt<'input>>{

fn reificationModifier(&self) -> Option<Rc<ReificationModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}
fn varianceModifier(&self) -> Option<Rc<VarianceModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotation(&self) -> Option<Rc<AnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeParameterModifierContextAttrs<'input> for TypeParameterModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeParameterModifier(&mut self,)
	-> Result<Rc<TypeParameterModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeParameterModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 318, RULE_typeParameterModifier);
        let mut _localctx: Rc<TypeParameterModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(3367);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 REIFIED 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule reificationModifier*/
					recog.base.set_state(3352);
					recog.reificationModifier()?;

					recog.base.set_state(3356);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(516,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3353);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(3358);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(516,&mut recog.base)?;
					}
					}
				}

			 IN | OUT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule varianceModifier*/
					recog.base.set_state(3359);
					recog.varianceModifier()?;

					recog.base.set_state(3363);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(517,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3360);
							recog.base.match_token(NL,&mut recog.err_handler)?;

							}
							} 
						}
						recog.base.set_state(3365);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(517,&mut recog.base)?;
					}
					}
				}

			 AT_NO_WS | AT_PRE_WS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule annotation*/
					recog.base.set_state(3366);
					recog.annotation()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionModifier ----------------
pub type FunctionModifierContextAll<'input> = FunctionModifierContext<'input>;


pub type FunctionModifierContext<'input> = BaseParserRuleContext<'input,FunctionModifierContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for FunctionModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for FunctionModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_functionModifier(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_functionModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for FunctionModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_functionModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionModifier }
}
antlr_rust::tid!{FunctionModifierContextExt<'a>}

impl<'input> FunctionModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<FunctionModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token TAILREC
/// Returns `None` if there is no child corresponding to token TAILREC
fn TAILREC(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(TAILREC, 0)
}
/// Retrieves first TerminalNode corresponding to token OPERATOR
/// Returns `None` if there is no child corresponding to token OPERATOR
fn OPERATOR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR, 0)
}
/// Retrieves first TerminalNode corresponding to token INFIX
/// Returns `None` if there is no child corresponding to token INFIX
fn INFIX(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INFIX, 0)
}
/// Retrieves first TerminalNode corresponding to token INLINE
/// Returns `None` if there is no child corresponding to token INLINE
fn INLINE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INLINE, 0)
}
/// Retrieves first TerminalNode corresponding to token EXTERNAL
/// Returns `None` if there is no child corresponding to token EXTERNAL
fn EXTERNAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EXTERNAL, 0)
}
/// Retrieves first TerminalNode corresponding to token SUSPEND
/// Returns `None` if there is no child corresponding to token SUSPEND
fn SUSPEND(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUSPEND, 0)
}

}

impl<'input> FunctionModifierContextAttrs<'input> for FunctionModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionModifier(&mut self,)
	-> Result<Rc<FunctionModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 320, RULE_functionModifier);
        let mut _localctx: Rc<FunctionModifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3369);
			_la = recog.base.input.la(1);
			if { !(((((_la - 117)) & !0x3f) == 0 && ((1usize << (_la - 117)) & ((1usize << (TAILREC - 117)) | (1usize << (OPERATOR - 117)) | (1usize << (INLINE - 117)) | (1usize << (INFIX - 117)) | (1usize << (EXTERNAL - 117)) | (1usize << (SUSPEND - 117)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- propertyModifier ----------------
pub type PropertyModifierContextAll<'input> = PropertyModifierContext<'input>;


pub type PropertyModifierContext<'input> = BaseParserRuleContext<'input,PropertyModifierContextExt<'input>>;

#[derive(Clone)]
pub struct PropertyModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PropertyModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PropertyModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_propertyModifier(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_propertyModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PropertyModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_propertyModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for PropertyModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_propertyModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_propertyModifier }
}
antlr_rust::tid!{PropertyModifierContextExt<'a>}

impl<'input> PropertyModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PropertyModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PropertyModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PropertyModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PropertyModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CONST
/// Returns `None` if there is no child corresponding to token CONST
fn CONST(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CONST, 0)
}

}

impl<'input> PropertyModifierContextAttrs<'input> for PropertyModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn propertyModifier(&mut self,)
	-> Result<Rc<PropertyModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PropertyModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 322, RULE_propertyModifier);
        let mut _localctx: Rc<PropertyModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3371);
			recog.base.match_token(CONST,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- inheritanceModifier ----------------
pub type InheritanceModifierContextAll<'input> = InheritanceModifierContext<'input>;


pub type InheritanceModifierContext<'input> = BaseParserRuleContext<'input,InheritanceModifierContextExt<'input>>;

#[derive(Clone)]
pub struct InheritanceModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for InheritanceModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for InheritanceModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_inheritanceModifier(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_inheritanceModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for InheritanceModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_inheritanceModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for InheritanceModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_inheritanceModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_inheritanceModifier }
}
antlr_rust::tid!{InheritanceModifierContextExt<'a>}

impl<'input> InheritanceModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InheritanceModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InheritanceModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InheritanceModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<InheritanceModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ABSTRACT
/// Returns `None` if there is no child corresponding to token ABSTRACT
fn ABSTRACT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ABSTRACT, 0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}
/// Retrieves first TerminalNode corresponding to token OPEN
/// Returns `None` if there is no child corresponding to token OPEN
fn OPEN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OPEN, 0)
}

}

impl<'input> InheritanceModifierContextAttrs<'input> for InheritanceModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn inheritanceModifier(&mut self,)
	-> Result<Rc<InheritanceModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InheritanceModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 324, RULE_inheritanceModifier);
        let mut _localctx: Rc<InheritanceModifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3373);
			_la = recog.base.input.la(1);
			if { !(((((_la - 124)) & !0x3f) == 0 && ((1usize << (_la - 124)) & ((1usize << (ABSTRACT - 124)) | (1usize << (FINAL - 124)) | (1usize << (OPEN - 124)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parameterModifier ----------------
pub type ParameterModifierContextAll<'input> = ParameterModifierContext<'input>;


pub type ParameterModifierContext<'input> = BaseParserRuleContext<'input,ParameterModifierContextExt<'input>>;

#[derive(Clone)]
pub struct ParameterModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ParameterModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ParameterModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_parameterModifier(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_parameterModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ParameterModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_parameterModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParameterModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parameterModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parameterModifier }
}
antlr_rust::tid!{ParameterModifierContextExt<'a>}

impl<'input> ParameterModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParameterModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParameterModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParameterModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ParameterModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token VARARG
/// Returns `None` if there is no child corresponding to token VARARG
fn VARARG(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(VARARG, 0)
}
/// Retrieves first TerminalNode corresponding to token NOINLINE
/// Returns `None` if there is no child corresponding to token NOINLINE
fn NOINLINE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NOINLINE, 0)
}
/// Retrieves first TerminalNode corresponding to token CROSSINLINE
/// Returns `None` if there is no child corresponding to token CROSSINLINE
fn CROSSINLINE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CROSSINLINE, 0)
}

}

impl<'input> ParameterModifierContextAttrs<'input> for ParameterModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parameterModifier(&mut self,)
	-> Result<Rc<ParameterModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParameterModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 326, RULE_parameterModifier);
        let mut _localctx: Rc<ParameterModifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3375);
			_la = recog.base.input.la(1);
			if { !(((((_la - 129)) & !0x3f) == 0 && ((1usize << (_la - 129)) & ((1usize << (VARARG - 129)) | (1usize << (NOINLINE - 129)) | (1usize << (CROSSINLINE - 129)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- reificationModifier ----------------
pub type ReificationModifierContextAll<'input> = ReificationModifierContext<'input>;


pub type ReificationModifierContext<'input> = BaseParserRuleContext<'input,ReificationModifierContextExt<'input>>;

#[derive(Clone)]
pub struct ReificationModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for ReificationModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for ReificationModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_reificationModifier(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_reificationModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for ReificationModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_reificationModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for ReificationModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_reificationModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_reificationModifier }
}
antlr_rust::tid!{ReificationModifierContextExt<'a>}

impl<'input> ReificationModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReificationModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReificationModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReificationModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<ReificationModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token REIFIED
/// Returns `None` if there is no child corresponding to token REIFIED
fn REIFIED(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(REIFIED, 0)
}

}

impl<'input> ReificationModifierContextAttrs<'input> for ReificationModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn reificationModifier(&mut self,)
	-> Result<Rc<ReificationModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReificationModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 328, RULE_reificationModifier);
        let mut _localctx: Rc<ReificationModifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3377);
			recog.base.match_token(REIFIED,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- platformModifier ----------------
pub type PlatformModifierContextAll<'input> = PlatformModifierContext<'input>;


pub type PlatformModifierContext<'input> = BaseParserRuleContext<'input,PlatformModifierContextExt<'input>>;

#[derive(Clone)]
pub struct PlatformModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for PlatformModifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for PlatformModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_platformModifier(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_platformModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for PlatformModifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_platformModifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for PlatformModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_platformModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_platformModifier }
}
antlr_rust::tid!{PlatformModifierContextExt<'a>}

impl<'input> PlatformModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PlatformModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PlatformModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PlatformModifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<PlatformModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EXPECT
/// Returns `None` if there is no child corresponding to token EXPECT
fn EXPECT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EXPECT, 0)
}
/// Retrieves first TerminalNode corresponding to token ACTUAL
/// Returns `None` if there is no child corresponding to token ACTUAL
fn ACTUAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ACTUAL, 0)
}

}

impl<'input> PlatformModifierContextAttrs<'input> for PlatformModifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn platformModifier(&mut self,)
	-> Result<Rc<PlatformModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PlatformModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 330, RULE_platformModifier);
        let mut _localctx: Rc<PlatformModifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3379);
			_la = recog.base.input.la(1);
			if { !(_la==EXPECT || _la==ACTUAL) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotation ----------------
pub type AnnotationContextAll<'input> = AnnotationContext<'input>;


pub type AnnotationContext<'input> = BaseParserRuleContext<'input,AnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AnnotationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AnnotationContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotation(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_annotation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AnnotationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_annotation(self);
	}
}

impl<'input> CustomRuleContext<'input> for AnnotationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotation }
}
antlr_rust::tid!{AnnotationContextExt<'a>}

impl<'input> AnnotationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AnnotationContextExt<'input>>{

fn singleAnnotation(&self) -> Option<Rc<SingleAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn multiAnnotation(&self) -> Option<Rc<MultiAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> AnnotationContextAttrs<'input> for AnnotationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotation(&mut self,)
	-> Result<Rc<AnnotationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 332, RULE_annotation);
        let mut _localctx: Rc<AnnotationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3383);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(519,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule singleAnnotation*/
					recog.base.set_state(3381);
					recog.singleAnnotation()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule multiAnnotation*/
					recog.base.set_state(3382);
					recog.multiAnnotation()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(3388);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(520,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(3385);
					recog.base.match_token(NL,&mut recog.err_handler)?;

					}
					} 
				}
				recog.base.set_state(3390);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(520,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- singleAnnotation ----------------
pub type SingleAnnotationContextAll<'input> = SingleAnnotationContext<'input>;


pub type SingleAnnotationContext<'input> = BaseParserRuleContext<'input,SingleAnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct SingleAnnotationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for SingleAnnotationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for SingleAnnotationContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_singleAnnotation(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_singleAnnotation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for SingleAnnotationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_singleAnnotation(self);
	}
}

impl<'input> CustomRuleContext<'input> for SingleAnnotationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_singleAnnotation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_singleAnnotation }
}
antlr_rust::tid!{SingleAnnotationContextExt<'a>}

impl<'input> SingleAnnotationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SingleAnnotationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SingleAnnotationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SingleAnnotationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<SingleAnnotationContextExt<'input>>{

fn unescapedAnnotation(&self) -> Option<Rc<UnescapedAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotationUseSiteTarget(&self) -> Option<Rc<AnnotationUseSiteTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token AT_NO_WS
/// Returns `None` if there is no child corresponding to token AT_NO_WS
fn AT_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_NO_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token AT_PRE_WS
/// Returns `None` if there is no child corresponding to token AT_PRE_WS
fn AT_PRE_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_PRE_WS, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> SingleAnnotationContextAttrs<'input> for SingleAnnotationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn singleAnnotation(&mut self,)
	-> Result<Rc<SingleAnnotationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SingleAnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 334, RULE_singleAnnotation);
        let mut _localctx: Rc<SingleAnnotationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3400);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(522,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule annotationUseSiteTarget*/
					recog.base.set_state(3391);
					recog.annotationUseSiteTarget()?;

					recog.base.set_state(3395);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3392);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3397);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				2 =>{
					{
					recog.base.set_state(3398);
					recog.base.match_token(AT_NO_WS,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					{
					recog.base.set_state(3399);
					recog.base.match_token(AT_PRE_WS,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule unescapedAnnotation*/
			recog.base.set_state(3402);
			recog.unescapedAnnotation()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- multiAnnotation ----------------
pub type MultiAnnotationContextAll<'input> = MultiAnnotationContext<'input>;


pub type MultiAnnotationContext<'input> = BaseParserRuleContext<'input,MultiAnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct MultiAnnotationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for MultiAnnotationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for MultiAnnotationContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_multiAnnotation(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_multiAnnotation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for MultiAnnotationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_multiAnnotation(self);
	}
}

impl<'input> CustomRuleContext<'input> for MultiAnnotationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_multiAnnotation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_multiAnnotation }
}
antlr_rust::tid!{MultiAnnotationContextExt<'a>}

impl<'input> MultiAnnotationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MultiAnnotationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MultiAnnotationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MultiAnnotationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<MultiAnnotationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LSQUARE
/// Returns `None` if there is no child corresponding to token LSQUARE
fn LSQUARE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LSQUARE, 0)
}
/// Retrieves first TerminalNode corresponding to token RSQUARE
/// Returns `None` if there is no child corresponding to token RSQUARE
fn RSQUARE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RSQUARE, 0)
}
fn annotationUseSiteTarget(&self) -> Option<Rc<AnnotationUseSiteTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token AT_NO_WS
/// Returns `None` if there is no child corresponding to token AT_NO_WS
fn AT_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_NO_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token AT_PRE_WS
/// Returns `None` if there is no child corresponding to token AT_PRE_WS
fn AT_PRE_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_PRE_WS, 0)
}
fn unescapedAnnotation_all(&self) ->  Vec<Rc<UnescapedAnnotationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn unescapedAnnotation(&self, i: usize) -> Option<Rc<UnescapedAnnotationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> MultiAnnotationContextAttrs<'input> for MultiAnnotationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn multiAnnotation(&mut self,)
	-> Result<Rc<MultiAnnotationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MultiAnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 336, RULE_multiAnnotation);
        let mut _localctx: Rc<MultiAnnotationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3413);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(524,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule annotationUseSiteTarget*/
					recog.base.set_state(3404);
					recog.annotationUseSiteTarget()?;

					recog.base.set_state(3408);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3405);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3410);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				2 =>{
					{
					recog.base.set_state(3411);
					recog.base.match_token(AT_NO_WS,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					{
					recog.base.set_state(3412);
					recog.base.match_token(AT_PRE_WS,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(3415);
			recog.base.match_token(LSQUARE,&mut recog.err_handler)?;

			recog.base.set_state(3417); 
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			loop {
				{
				{
				/*InvokeRule unescapedAnnotation*/
				recog.base.set_state(3416);
				recog.unescapedAnnotation()?;

				}
				}
				recog.base.set_state(3419); 
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if !(((((_la - 61)) & !0x3f) == 0 && ((1usize << (_la - 61)) & ((1usize << (FILE - 61)) | (1usize << (FIELD - 61)) | (1usize << (PROPERTY - 61)) | (1usize << (GET - 61)) | (1usize << (SET - 61)) | (1usize << (RECEIVER - 61)) | (1usize << (PARAM - 61)) | (1usize << (SETPARAM - 61)) | (1usize << (DELEGATE - 61)) | (1usize << (IMPORT - 61)) | (1usize << (CONSTRUCTOR - 61)) | (1usize << (BY - 61)) | (1usize << (COMPANION - 61)) | (1usize << (INIT - 61)) | (1usize << (WHERE - 61)) | (1usize << (CATCH - 61)) | (1usize << (FINALLY - 61)) | (1usize << (OUT - 61)) | (1usize << (DYNAMIC - 61)) | (1usize << (PUBLIC - 61)) | (1usize << (PRIVATE - 61)) | (1usize << (PROTECTED - 61)) | (1usize << (INTERNAL - 61)) | (1usize << (ENUM - 61)) | (1usize << (SEALED - 61)) | (1usize << (ANNOTATION - 61)) | (1usize << (DATA - 61)) | (1usize << (INNER - 61)) | (1usize << (VALUE - 61)) | (1usize << (TAILREC - 61)) | (1usize << (OPERATOR - 61)) | (1usize << (INLINE - 61)) | (1usize << (INFIX - 61)) | (1usize << (EXTERNAL - 61)) | (1usize << (SUSPEND - 61)) | (1usize << (OVERRIDE - 61)) | (1usize << (ABSTRACT - 61)))) != 0) || ((((_la - 125)) & !0x3f) == 0 && ((1usize << (_la - 125)) & ((1usize << (FINAL - 125)) | (1usize << (OPEN - 125)) | (1usize << (CONST - 125)) | (1usize << (LATEINIT - 125)) | (1usize << (VARARG - 125)) | (1usize << (NOINLINE - 125)) | (1usize << (CROSSINLINE - 125)) | (1usize << (REIFIED - 125)) | (1usize << (EXPECT - 125)) | (1usize << (ACTUAL - 125)) | (1usize << (Identifier - 125)))) != 0)) {break}
			}
			recog.base.set_state(3421);
			recog.base.match_token(RSQUARE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotationUseSiteTarget ----------------
pub type AnnotationUseSiteTargetContextAll<'input> = AnnotationUseSiteTargetContext<'input>;


pub type AnnotationUseSiteTargetContext<'input> = BaseParserRuleContext<'input,AnnotationUseSiteTargetContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationUseSiteTargetContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for AnnotationUseSiteTargetContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for AnnotationUseSiteTargetContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotationUseSiteTarget(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_annotationUseSiteTarget(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for AnnotationUseSiteTargetContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_annotationUseSiteTarget(self);
	}
}

impl<'input> CustomRuleContext<'input> for AnnotationUseSiteTargetContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotationUseSiteTarget }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotationUseSiteTarget }
}
antlr_rust::tid!{AnnotationUseSiteTargetContextExt<'a>}

impl<'input> AnnotationUseSiteTargetContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationUseSiteTargetContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationUseSiteTargetContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationUseSiteTargetContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<AnnotationUseSiteTargetContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
/// Retrieves first TerminalNode corresponding to token AT_NO_WS
/// Returns `None` if there is no child corresponding to token AT_NO_WS
fn AT_NO_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_NO_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token AT_PRE_WS
/// Returns `None` if there is no child corresponding to token AT_PRE_WS
fn AT_PRE_WS(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(AT_PRE_WS, 0)
}
/// Retrieves first TerminalNode corresponding to token FIELD
/// Returns `None` if there is no child corresponding to token FIELD
fn FIELD(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FIELD, 0)
}
/// Retrieves first TerminalNode corresponding to token PROPERTY
/// Returns `None` if there is no child corresponding to token PROPERTY
fn PROPERTY(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PROPERTY, 0)
}
/// Retrieves first TerminalNode corresponding to token GET
/// Returns `None` if there is no child corresponding to token GET
fn GET(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(GET, 0)
}
/// Retrieves first TerminalNode corresponding to token SET
/// Returns `None` if there is no child corresponding to token SET
fn SET(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SET, 0)
}
/// Retrieves first TerminalNode corresponding to token RECEIVER
/// Returns `None` if there is no child corresponding to token RECEIVER
fn RECEIVER(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RECEIVER, 0)
}
/// Retrieves first TerminalNode corresponding to token PARAM
/// Returns `None` if there is no child corresponding to token PARAM
fn PARAM(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PARAM, 0)
}
/// Retrieves first TerminalNode corresponding to token SETPARAM
/// Returns `None` if there is no child corresponding to token SETPARAM
fn SETPARAM(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SETPARAM, 0)
}
/// Retrieves first TerminalNode corresponding to token DELEGATE
/// Returns `None` if there is no child corresponding to token DELEGATE
fn DELEGATE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DELEGATE, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> AnnotationUseSiteTargetContextAttrs<'input> for AnnotationUseSiteTargetContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotationUseSiteTarget(&mut self,)
	-> Result<Rc<AnnotationUseSiteTargetContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationUseSiteTargetContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 338, RULE_annotationUseSiteTarget);
        let mut _localctx: Rc<AnnotationUseSiteTargetContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3423);
			_la = recog.base.input.la(1);
			if { !(_la==AT_NO_WS || _la==AT_PRE_WS) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			recog.base.set_state(3424);
			_la = recog.base.input.la(1);
			if { !(((((_la - 62)) & !0x3f) == 0 && ((1usize << (_la - 62)) & ((1usize << (FIELD - 62)) | (1usize << (PROPERTY - 62)) | (1usize << (GET - 62)) | (1usize << (SET - 62)) | (1usize << (RECEIVER - 62)) | (1usize << (PARAM - 62)) | (1usize << (SETPARAM - 62)) | (1usize << (DELEGATE - 62)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			recog.base.set_state(3428);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==NL {
				{
				{
				recog.base.set_state(3425);
				recog.base.match_token(NL,&mut recog.err_handler)?;

				}
				}
				recog.base.set_state(3430);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(3431);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unescapedAnnotation ----------------
pub type UnescapedAnnotationContextAll<'input> = UnescapedAnnotationContext<'input>;


pub type UnescapedAnnotationContext<'input> = BaseParserRuleContext<'input,UnescapedAnnotationContextExt<'input>>;

#[derive(Clone)]
pub struct UnescapedAnnotationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for UnescapedAnnotationContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for UnescapedAnnotationContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unescapedAnnotation(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_unescapedAnnotation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for UnescapedAnnotationContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_unescapedAnnotation(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnescapedAnnotationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unescapedAnnotation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unescapedAnnotation }
}
antlr_rust::tid!{UnescapedAnnotationContextExt<'a>}

impl<'input> UnescapedAnnotationContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnescapedAnnotationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnescapedAnnotationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnescapedAnnotationContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<UnescapedAnnotationContextExt<'input>>{

fn constructorInvocation(&self) -> Option<Rc<ConstructorInvocationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn userType(&self) -> Option<Rc<UserTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UnescapedAnnotationContextAttrs<'input> for UnescapedAnnotationContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unescapedAnnotation(&mut self,)
	-> Result<Rc<UnescapedAnnotationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnescapedAnnotationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 340, RULE_unescapedAnnotation);
        let mut _localctx: Rc<UnescapedAnnotationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3435);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(527,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule constructorInvocation*/
					recog.base.set_state(3433);
					recog.constructorInvocation()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule userType*/
					recog.base.set_state(3434);
					recog.userType()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- simpleIdentifier ----------------
pub type SimpleIdentifierContextAll<'input> = SimpleIdentifierContext<'input>;


pub type SimpleIdentifierContext<'input> = BaseParserRuleContext<'input,SimpleIdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct SimpleIdentifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for SimpleIdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for SimpleIdentifierContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_simpleIdentifier(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_simpleIdentifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for SimpleIdentifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_simpleIdentifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for SimpleIdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_simpleIdentifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_simpleIdentifier }
}
antlr_rust::tid!{SimpleIdentifierContextExt<'a>}

impl<'input> SimpleIdentifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SimpleIdentifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SimpleIdentifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SimpleIdentifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<SimpleIdentifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token Identifier
/// Returns `None` if there is no child corresponding to token Identifier
fn Identifier(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(Identifier, 0)
}
/// Retrieves first TerminalNode corresponding to token ABSTRACT
/// Returns `None` if there is no child corresponding to token ABSTRACT
fn ABSTRACT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ABSTRACT, 0)
}
/// Retrieves first TerminalNode corresponding to token ANNOTATION
/// Returns `None` if there is no child corresponding to token ANNOTATION
fn ANNOTATION(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ANNOTATION, 0)
}
/// Retrieves first TerminalNode corresponding to token BY
/// Returns `None` if there is no child corresponding to token BY
fn BY(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(BY, 0)
}
/// Retrieves first TerminalNode corresponding to token CATCH
/// Returns `None` if there is no child corresponding to token CATCH
fn CATCH(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CATCH, 0)
}
/// Retrieves first TerminalNode corresponding to token COMPANION
/// Returns `None` if there is no child corresponding to token COMPANION
fn COMPANION(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(COMPANION, 0)
}
/// Retrieves first TerminalNode corresponding to token CONSTRUCTOR
/// Returns `None` if there is no child corresponding to token CONSTRUCTOR
fn CONSTRUCTOR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CONSTRUCTOR, 0)
}
/// Retrieves first TerminalNode corresponding to token CROSSINLINE
/// Returns `None` if there is no child corresponding to token CROSSINLINE
fn CROSSINLINE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CROSSINLINE, 0)
}
/// Retrieves first TerminalNode corresponding to token DATA
/// Returns `None` if there is no child corresponding to token DATA
fn DATA(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DATA, 0)
}
/// Retrieves first TerminalNode corresponding to token DYNAMIC
/// Returns `None` if there is no child corresponding to token DYNAMIC
fn DYNAMIC(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DYNAMIC, 0)
}
/// Retrieves first TerminalNode corresponding to token ENUM
/// Returns `None` if there is no child corresponding to token ENUM
fn ENUM(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ENUM, 0)
}
/// Retrieves first TerminalNode corresponding to token EXTERNAL
/// Returns `None` if there is no child corresponding to token EXTERNAL
fn EXTERNAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EXTERNAL, 0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}
/// Retrieves first TerminalNode corresponding to token FINALLY
/// Returns `None` if there is no child corresponding to token FINALLY
fn FINALLY(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FINALLY, 0)
}
/// Retrieves first TerminalNode corresponding to token GET
/// Returns `None` if there is no child corresponding to token GET
fn GET(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(GET, 0)
}
/// Retrieves first TerminalNode corresponding to token IMPORT
/// Returns `None` if there is no child corresponding to token IMPORT
fn IMPORT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(IMPORT, 0)
}
/// Retrieves first TerminalNode corresponding to token INFIX
/// Returns `None` if there is no child corresponding to token INFIX
fn INFIX(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INFIX, 0)
}
/// Retrieves first TerminalNode corresponding to token INIT
/// Returns `None` if there is no child corresponding to token INIT
fn INIT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INIT, 0)
}
/// Retrieves first TerminalNode corresponding to token INLINE
/// Returns `None` if there is no child corresponding to token INLINE
fn INLINE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INLINE, 0)
}
/// Retrieves first TerminalNode corresponding to token INNER
/// Returns `None` if there is no child corresponding to token INNER
fn INNER(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INNER, 0)
}
/// Retrieves first TerminalNode corresponding to token INTERNAL
/// Returns `None` if there is no child corresponding to token INTERNAL
fn INTERNAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(INTERNAL, 0)
}
/// Retrieves first TerminalNode corresponding to token LATEINIT
/// Returns `None` if there is no child corresponding to token LATEINIT
fn LATEINIT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(LATEINIT, 0)
}
/// Retrieves first TerminalNode corresponding to token NOINLINE
/// Returns `None` if there is no child corresponding to token NOINLINE
fn NOINLINE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NOINLINE, 0)
}
/// Retrieves first TerminalNode corresponding to token OPEN
/// Returns `None` if there is no child corresponding to token OPEN
fn OPEN(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OPEN, 0)
}
/// Retrieves first TerminalNode corresponding to token OPERATOR
/// Returns `None` if there is no child corresponding to token OPERATOR
fn OPERATOR(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OPERATOR, 0)
}
/// Retrieves first TerminalNode corresponding to token OUT
/// Returns `None` if there is no child corresponding to token OUT
fn OUT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OUT, 0)
}
/// Retrieves first TerminalNode corresponding to token OVERRIDE
/// Returns `None` if there is no child corresponding to token OVERRIDE
fn OVERRIDE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(OVERRIDE, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVATE
/// Returns `None` if there is no child corresponding to token PRIVATE
fn PRIVATE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PRIVATE, 0)
}
/// Retrieves first TerminalNode corresponding to token PROTECTED
/// Returns `None` if there is no child corresponding to token PROTECTED
fn PROTECTED(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PROTECTED, 0)
}
/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token REIFIED
/// Returns `None` if there is no child corresponding to token REIFIED
fn REIFIED(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(REIFIED, 0)
}
/// Retrieves first TerminalNode corresponding to token SEALED
/// Returns `None` if there is no child corresponding to token SEALED
fn SEALED(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SEALED, 0)
}
/// Retrieves first TerminalNode corresponding to token TAILREC
/// Returns `None` if there is no child corresponding to token TAILREC
fn TAILREC(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(TAILREC, 0)
}
/// Retrieves first TerminalNode corresponding to token SET
/// Returns `None` if there is no child corresponding to token SET
fn SET(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SET, 0)
}
/// Retrieves first TerminalNode corresponding to token VARARG
/// Returns `None` if there is no child corresponding to token VARARG
fn VARARG(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(VARARG, 0)
}
/// Retrieves first TerminalNode corresponding to token WHERE
/// Returns `None` if there is no child corresponding to token WHERE
fn WHERE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(WHERE, 0)
}
/// Retrieves first TerminalNode corresponding to token FIELD
/// Returns `None` if there is no child corresponding to token FIELD
fn FIELD(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FIELD, 0)
}
/// Retrieves first TerminalNode corresponding to token PROPERTY
/// Returns `None` if there is no child corresponding to token PROPERTY
fn PROPERTY(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PROPERTY, 0)
}
/// Retrieves first TerminalNode corresponding to token RECEIVER
/// Returns `None` if there is no child corresponding to token RECEIVER
fn RECEIVER(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(RECEIVER, 0)
}
/// Retrieves first TerminalNode corresponding to token PARAM
/// Returns `None` if there is no child corresponding to token PARAM
fn PARAM(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(PARAM, 0)
}
/// Retrieves first TerminalNode corresponding to token SETPARAM
/// Returns `None` if there is no child corresponding to token SETPARAM
fn SETPARAM(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SETPARAM, 0)
}
/// Retrieves first TerminalNode corresponding to token DELEGATE
/// Returns `None` if there is no child corresponding to token DELEGATE
fn DELEGATE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DELEGATE, 0)
}
/// Retrieves first TerminalNode corresponding to token FILE
/// Returns `None` if there is no child corresponding to token FILE
fn FILE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(FILE, 0)
}
/// Retrieves first TerminalNode corresponding to token EXPECT
/// Returns `None` if there is no child corresponding to token EXPECT
fn EXPECT(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(EXPECT, 0)
}
/// Retrieves first TerminalNode corresponding to token ACTUAL
/// Returns `None` if there is no child corresponding to token ACTUAL
fn ACTUAL(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(ACTUAL, 0)
}
/// Retrieves first TerminalNode corresponding to token CONST
/// Returns `None` if there is no child corresponding to token CONST
fn CONST(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(CONST, 0)
}
/// Retrieves first TerminalNode corresponding to token SUSPEND
/// Returns `None` if there is no child corresponding to token SUSPEND
fn SUSPEND(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(SUSPEND, 0)
}
/// Retrieves first TerminalNode corresponding to token VALUE
/// Returns `None` if there is no child corresponding to token VALUE
fn VALUE(&self) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(VALUE, 0)
}

}

impl<'input> SimpleIdentifierContextAttrs<'input> for SimpleIdentifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn simpleIdentifier(&mut self,)
	-> Result<Rc<SimpleIdentifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SimpleIdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 342, RULE_simpleIdentifier);
        let mut _localctx: Rc<SimpleIdentifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3437);
			_la = recog.base.input.la(1);
			if { !(((((_la - 61)) & !0x3f) == 0 && ((1usize << (_la - 61)) & ((1usize << (FILE - 61)) | (1usize << (FIELD - 61)) | (1usize << (PROPERTY - 61)) | (1usize << (GET - 61)) | (1usize << (SET - 61)) | (1usize << (RECEIVER - 61)) | (1usize << (PARAM - 61)) | (1usize << (SETPARAM - 61)) | (1usize << (DELEGATE - 61)) | (1usize << (IMPORT - 61)) | (1usize << (CONSTRUCTOR - 61)) | (1usize << (BY - 61)) | (1usize << (COMPANION - 61)) | (1usize << (INIT - 61)) | (1usize << (WHERE - 61)) | (1usize << (CATCH - 61)) | (1usize << (FINALLY - 61)) | (1usize << (OUT - 61)) | (1usize << (DYNAMIC - 61)) | (1usize << (PUBLIC - 61)) | (1usize << (PRIVATE - 61)) | (1usize << (PROTECTED - 61)) | (1usize << (INTERNAL - 61)) | (1usize << (ENUM - 61)) | (1usize << (SEALED - 61)) | (1usize << (ANNOTATION - 61)) | (1usize << (DATA - 61)) | (1usize << (INNER - 61)) | (1usize << (VALUE - 61)) | (1usize << (TAILREC - 61)) | (1usize << (OPERATOR - 61)) | (1usize << (INLINE - 61)) | (1usize << (INFIX - 61)) | (1usize << (EXTERNAL - 61)) | (1usize << (SUSPEND - 61)) | (1usize << (OVERRIDE - 61)) | (1usize << (ABSTRACT - 61)))) != 0) || ((((_la - 125)) & !0x3f) == 0 && ((1usize << (_la - 125)) & ((1usize << (FINAL - 125)) | (1usize << (OPEN - 125)) | (1usize << (CONST - 125)) | (1usize << (LATEINIT - 125)) | (1usize << (VARARG - 125)) | (1usize << (NOINLINE - 125)) | (1usize << (CROSSINLINE - 125)) | (1usize << (REIFIED - 125)) | (1usize << (EXPECT - 125)) | (1usize << (ACTUAL - 125)) | (1usize << (Identifier - 125)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- identifier ----------------
pub type IdentifierContextAll<'input> = IdentifierContext<'input>;


pub type IdentifierContext<'input> = BaseParserRuleContext<'input,IdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct IdentifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> KotlinParserContext<'input> for IdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn KotlinParserListener<'input> + 'a> for IdentifierContext<'input>{
		fn enter(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_identifier(self);
		}
		fn exit(&self,listener: &mut (dyn KotlinParserListener<'input> + 'a)) {
			listener.exit_identifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn KotlinParserVisitor<'input> + 'a> for IdentifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn KotlinParserVisitor<'input> + 'a)) {
		visitor.visit_identifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for IdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = KotlinParserContextType;
	fn get_rule_index(&self) -> usize { RULE_identifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_identifier }
}
antlr_rust::tid!{IdentifierContextExt<'a>}

impl<'input> IdentifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn KotlinParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IdentifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IdentifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IdentifierContextAttrs<'input>: KotlinParserContext<'input> + BorrowMut<IdentifierContextExt<'input>>{

fn simpleIdentifier_all(&self) ->  Vec<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn simpleIdentifier(&self, i: usize) -> Option<Rc<SimpleIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NL in current rule
fn NL_all(&self) -> Vec<Rc<TerminalNode<'input,KotlinParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NL, starting from 0.
/// Returns `None` if number of children corresponding to token NL is less or equal than `i`.
fn NL(&self, i: usize) -> Option<Rc<TerminalNode<'input,KotlinParserContextType>>> where Self:Sized{
	self.get_token(NL, i)
}

}

impl<'input> IdentifierContextAttrs<'input> for IdentifierContext<'input>{}

impl<'input, I, H> KotlinParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn identifier(&mut self,)
	-> Result<Rc<IdentifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 344, RULE_identifier);
        let mut _localctx: Rc<IdentifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule simpleIdentifier*/
			recog.base.set_state(3439);
			recog.simpleIdentifier()?;

			recog.base.set_state(3450);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(529,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(3443);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==NL {
						{
						{
						recog.base.set_state(3440);
						recog.base.match_token(NL,&mut recog.err_handler)?;

						}
						}
						recog.base.set_state(3445);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(3446);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule simpleIdentifier*/
					recog.base.set_state(3447);
					recog.simpleIdentifier()?;

					}
					} 
				}
				recog.base.set_state(3452);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(529,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}

lazy_static! {
    static ref _ATN: Arc<ATN> =
        Arc::new(ATNDeserializer::new(None).deserialize(_serializedATN.chars()));
    static ref _decision_to_DFA: Arc<Vec<antlr_rust::RwLock<DFA>>> = {
        let mut dfa = Vec::new();
        let size = _ATN.decision_to_state.len();
        for i in 0..size {
            dfa.push(DFA::new(
                _ATN.clone(),
                _ATN.get_decision_state(i),
                i as isize,
            ).into())
        }
        Arc::new(dfa)
    };
}



const _serializedATN:&'static str =
	"\x03\u{608b}\u{a72a}\u{8133}\u{b9ed}\u{417c}\u{3be7}\u{7786}\u{5964}\x03\
	\u{ad}\u{d80}\x04\x02\x09\x02\x04\x03\x09\x03\x04\x04\x09\x04\x04\x05\x09\
	\x05\x04\x06\x09\x06\x04\x07\x09\x07\x04\x08\x09\x08\x04\x09\x09\x09\x04\
	\x0a\x09\x0a\x04\x0b\x09\x0b\x04\x0c\x09\x0c\x04\x0d\x09\x0d\x04\x0e\x09\
	\x0e\x04\x0f\x09\x0f\x04\x10\x09\x10\x04\x11\x09\x11\x04\x12\x09\x12\x04\
	\x13\x09\x13\x04\x14\x09\x14\x04\x15\x09\x15\x04\x16\x09\x16\x04\x17\x09\
	\x17\x04\x18\x09\x18\x04\x19\x09\x19\x04\x1a\x09\x1a\x04\x1b\x09\x1b\x04\
	\x1c\x09\x1c\x04\x1d\x09\x1d\x04\x1e\x09\x1e\x04\x1f\x09\x1f\x04\x20\x09\
	\x20\x04\x21\x09\x21\x04\x22\x09\x22\x04\x23\x09\x23\x04\x24\x09\x24\x04\
	\x25\x09\x25\x04\x26\x09\x26\x04\x27\x09\x27\x04\x28\x09\x28\x04\x29\x09\
	\x29\x04\x2a\x09\x2a\x04\x2b\x09\x2b\x04\x2c\x09\x2c\x04\x2d\x09\x2d\x04\
	\x2e\x09\x2e\x04\x2f\x09\x2f\x04\x30\x09\x30\x04\x31\x09\x31\x04\x32\x09\
	\x32\x04\x33\x09\x33\x04\x34\x09\x34\x04\x35\x09\x35\x04\x36\x09\x36\x04\
	\x37\x09\x37\x04\x38\x09\x38\x04\x39\x09\x39\x04\x3a\x09\x3a\x04\x3b\x09\
	\x3b\x04\x3c\x09\x3c\x04\x3d\x09\x3d\x04\x3e\x09\x3e\x04\x3f\x09\x3f\x04\
	\x40\x09\x40\x04\x41\x09\x41\x04\x42\x09\x42\x04\x43\x09\x43\x04\x44\x09\
	\x44\x04\x45\x09\x45\x04\x46\x09\x46\x04\x47\x09\x47\x04\x48\x09\x48\x04\
	\x49\x09\x49\x04\x4a\x09\x4a\x04\x4b\x09\x4b\x04\x4c\x09\x4c\x04\x4d\x09\
	\x4d\x04\x4e\x09\x4e\x04\x4f\x09\x4f\x04\x50\x09\x50\x04\x51\x09\x51\x04\
	\x52\x09\x52\x04\x53\x09\x53\x04\x54\x09\x54\x04\x55\x09\x55\x04\x56\x09\
	\x56\x04\x57\x09\x57\x04\x58\x09\x58\x04\x59\x09\x59\x04\x5a\x09\x5a\x04\
	\x5b\x09\x5b\x04\x5c\x09\x5c\x04\x5d\x09\x5d\x04\x5e\x09\x5e\x04\x5f\x09\
	\x5f\x04\x60\x09\x60\x04\x61\x09\x61\x04\x62\x09\x62\x04\x63\x09\x63\x04\
	\x64\x09\x64\x04\x65\x09\x65\x04\x66\x09\x66\x04\x67\x09\x67\x04\x68\x09\
	\x68\x04\x69\x09\x69\x04\x6a\x09\x6a\x04\x6b\x09\x6b\x04\x6c\x09\x6c\x04\
	\x6d\x09\x6d\x04\x6e\x09\x6e\x04\x6f\x09\x6f\x04\x70\x09\x70\x04\x71\x09\
	\x71\x04\x72\x09\x72\x04\x73\x09\x73\x04\x74\x09\x74\x04\x75\x09\x75\x04\
	\x76\x09\x76\x04\x77\x09\x77\x04\x78\x09\x78\x04\x79\x09\x79\x04\x7a\x09\
	\x7a\x04\x7b\x09\x7b\x04\x7c\x09\x7c\x04\x7d\x09\x7d\x04\x7e\x09\x7e\x04\
	\x7f\x09\x7f\x04\u{80}\x09\u{80}\x04\u{81}\x09\u{81}\x04\u{82}\x09\u{82}\
	\x04\u{83}\x09\u{83}\x04\u{84}\x09\u{84}\x04\u{85}\x09\u{85}\x04\u{86}\x09\
	\u{86}\x04\u{87}\x09\u{87}\x04\u{88}\x09\u{88}\x04\u{89}\x09\u{89}\x04\u{8a}\
	\x09\u{8a}\x04\u{8b}\x09\u{8b}\x04\u{8c}\x09\u{8c}\x04\u{8d}\x09\u{8d}\x04\
	\u{8e}\x09\u{8e}\x04\u{8f}\x09\u{8f}\x04\u{90}\x09\u{90}\x04\u{91}\x09\u{91}\
	\x04\u{92}\x09\u{92}\x04\u{93}\x09\u{93}\x04\u{94}\x09\u{94}\x04\u{95}\x09\
	\u{95}\x04\u{96}\x09\u{96}\x04\u{97}\x09\u{97}\x04\u{98}\x09\u{98}\x04\u{99}\
	\x09\u{99}\x04\u{9a}\x09\u{9a}\x04\u{9b}\x09\u{9b}\x04\u{9c}\x09\u{9c}\x04\
	\u{9d}\x09\u{9d}\x04\u{9e}\x09\u{9e}\x04\u{9f}\x09\u{9f}\x04\u{a0}\x09\u{a0}\
	\x04\u{a1}\x09\u{a1}\x04\u{a2}\x09\u{a2}\x04\u{a3}\x09\u{a3}\x04\u{a4}\x09\
	\u{a4}\x04\u{a5}\x09\u{a5}\x04\u{a6}\x09\u{a6}\x04\u{a7}\x09\u{a7}\x04\u{a8}\
	\x09\u{a8}\x04\u{a9}\x09\u{a9}\x04\u{aa}\x09\u{aa}\x04\u{ab}\x09\u{ab}\x04\
	\u{ac}\x09\u{ac}\x04\u{ad}\x09\u{ad}\x04\u{ae}\x09\u{ae}\x03\x02\x05\x02\
	\u{15e}\x0a\x02\x03\x02\x07\x02\u{161}\x0a\x02\x0c\x02\x0e\x02\u{164}\x0b\
	\x02\x03\x02\x07\x02\u{167}\x0a\x02\x0c\x02\x0e\x02\u{16a}\x0b\x02\x03\x02\
	\x03\x02\x03\x02\x07\x02\u{16f}\x0a\x02\x0c\x02\x0e\x02\u{172}\x0b\x02\x03\
	\x02\x03\x02\x03\x03\x05\x03\u{177}\x0a\x03\x03\x03\x07\x03\u{17a}\x0a\x03\
	\x0c\x03\x0e\x03\u{17d}\x0b\x03\x03\x03\x07\x03\u{180}\x0a\x03\x0c\x03\x0e\
	\x03\u{183}\x0b\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x03\x07\x03\u{18a}\
	\x0a\x03\x0c\x03\x0e\x03\u{18d}\x0b\x03\x03\x03\x03\x03\x03\x04\x03\x04\
	\x06\x04\u{193}\x0a\x04\x0d\x04\x0e\x04\u{194}\x03\x05\x03\x05\x03\x05\x07\
	\x05\u{19a}\x0a\x05\x0c\x05\x0e\x05\u{19d}\x0b\x05\x03\x05\x03\x05\x07\x05\
	\u{1a1}\x0a\x05\x0c\x05\x0e\x05\u{1a4}\x0b\x05\x03\x05\x03\x05\x06\x05\u{1a8}\
	\x0a\x05\x0d\x05\x0e\x05\u{1a9}\x03\x05\x03\x05\x03\x05\x05\x05\u{1af}\x0a\
	\x05\x03\x05\x07\x05\u{1b2}\x0a\x05\x0c\x05\x0e\x05\u{1b5}\x0b\x05\x03\x06\
	\x03\x06\x03\x06\x05\x06\u{1ba}\x0a\x06\x05\x06\u{1bc}\x0a\x06\x03\x07\x07\
	\x07\u{1bf}\x0a\x07\x0c\x07\x0e\x07\u{1c2}\x0b\x07\x03\x08\x03\x08\x03\x08\
	\x03\x08\x03\x08\x05\x08\u{1c9}\x0a\x08\x03\x08\x05\x08\u{1cc}\x0a\x08\x03\
	\x09\x03\x09\x03\x09\x03\x0a\x03\x0a\x05\x0a\u{1d3}\x0a\x0a\x03\x0b\x05\
	\x0b\u{1d6}\x0a\x0b\x03\x0b\x03\x0b\x07\x0b\u{1da}\x0a\x0b\x0c\x0b\x0e\x0b\
	\u{1dd}\x0b\x0b\x03\x0b\x03\x0b\x07\x0b\u{1e1}\x0a\x0b\x0c\x0b\x0e\x0b\u{1e4}\
	\x0b\x0b\x03\x0b\x05\x0b\u{1e7}\x0a\x0b\x03\x0b\x07\x0b\u{1ea}\x0a\x0b\x0c\
	\x0b\x0e\x0b\u{1ed}\x0b\x0b\x03\x0b\x03\x0b\x07\x0b\u{1f1}\x0a\x0b\x0c\x0b\
	\x0e\x0b\u{1f4}\x0b\x0b\x03\x0b\x03\x0b\x03\x0c\x03\x0c\x03\x0c\x03\x0c\
	\x03\x0c\x05\x0c\u{1fd}\x0a\x0c\x03\x0d\x05\x0d\u{200}\x0a\x0d\x03\x0d\x03\
	\x0d\x03\x0d\x07\x0d\u{205}\x0a\x0d\x0c\x0d\x0e\x0d\u{208}\x0b\x0d\x05\x0d\
	\u{20a}\x0a\x0d\x03\x0d\x05\x0d\u{20d}\x0a\x0d\x03\x0d\x07\x0d\u{210}\x0a\
	\x0d\x0c\x0d\x0e\x0d\u{213}\x0b\x0d\x03\x0d\x03\x0d\x07\x0d\u{217}\x0a\x0d\
	\x0c\x0d\x0e\x0d\u{21a}\x0b\x0d\x03\x0d\x05\x0d\u{21d}\x0a\x0d\x03\x0d\x07\
	\x0d\u{220}\x0a\x0d\x0c\x0d\x0e\x0d\u{223}\x0b\x0d\x03\x0d\x05\x0d\u{226}\
	\x0a\x0d\x03\x0d\x07\x0d\u{229}\x0a\x0d\x0c\x0d\x0e\x0d\u{22c}\x0b\x0d\x03\
	\x0d\x03\x0d\x07\x0d\u{230}\x0a\x0d\x0c\x0d\x0e\x0d\u{233}\x0b\x0d\x03\x0d\
	\x05\x0d\u{236}\x0a\x0d\x03\x0d\x07\x0d\u{239}\x0a\x0d\x0c\x0d\x0e\x0d\u{23c}\
	\x0b\x0d\x03\x0d\x05\x0d\u{23f}\x0a\x0d\x03\x0d\x07\x0d\u{242}\x0a\x0d\x0c\
	\x0d\x0e\x0d\u{245}\x0b\x0d\x03\x0d\x03\x0d\x07\x0d\u{249}\x0a\x0d\x0c\x0d\
	\x0e\x0d\u{24c}\x0b\x0d\x03\x0d\x05\x0d\u{24f}\x0a\x0d\x03\x0e\x05\x0e\u{252}\
	\x0a\x0e\x03\x0e\x03\x0e\x07\x0e\u{256}\x0a\x0e\x0c\x0e\x0e\x0e\u{259}\x0b\
	\x0e\x05\x0e\u{25b}\x0a\x0e\x03\x0e\x03\x0e\x03\x0f\x03\x0f\x07\x0f\u{261}\
	\x0a\x0f\x0c\x0f\x0e\x0f\u{264}\x0b\x0f\x03\x0f\x03\x0f\x07\x0f\u{268}\x0a\
	\x0f\x0c\x0f\x0e\x0f\u{26b}\x0b\x0f\x03\x0f\x03\x0f\x03\x10\x03\x10\x07\
	\x10\u{271}\x0a\x10\x0c\x10\x0e\x10\u{274}\x0b\x10\x03\x10\x03\x10\x07\x10\
	\u{278}\x0a\x10\x0c\x10\x0e\x10\u{27b}\x0b\x10\x03\x10\x03\x10\x07\x10\u{27f}\
	\x0a\x10\x0c\x10\x0e\x10\u{282}\x0b\x10\x03\x10\x07\x10\u{285}\x0a\x10\x0c\
	\x10\x0e\x10\u{288}\x0b\x10\x03\x10\x07\x10\u{28b}\x0a\x10\x0c\x10\x0e\x10\
	\u{28e}\x0b\x10\x03\x10\x05\x10\u{291}\x0a\x10\x05\x10\u{293}\x0a\x10\x03\
	\x10\x07\x10\u{296}\x0a\x10\x0c\x10\x0e\x10\u{299}\x0b\x10\x03\x10\x03\x10\
	\x03\x11\x05\x11\u{29e}\x0a\x11\x03\x11\x05\x11\u{2a1}\x0a\x11\x03\x11\x07\
	\x11\u{2a4}\x0a\x11\x0c\x11\x0e\x11\u{2a7}\x0b\x11\x03\x11\x03\x11\x03\x11\
	\x07\x11\u{2ac}\x0a\x11\x0c\x11\x0e\x11\u{2af}\x0b\x11\x03\x11\x03\x11\x07\
	\x11\u{2b3}\x0a\x11\x0c\x11\x0e\x11\u{2b6}\x0b\x11\x03\x11\x03\x11\x07\x11\
	\u{2ba}\x0a\x11\x0c\x11\x0e\x11\u{2bd}\x0b\x11\x03\x11\x05\x11\u{2c0}\x0a\
	\x11\x03\x12\x03\x12\x07\x12\u{2c4}\x0a\x12\x0c\x12\x0e\x12\u{2c7}\x0b\x12\
	\x03\x12\x03\x12\x07\x12\u{2cb}\x0a\x12\x0c\x12\x0e\x12\u{2ce}\x0b\x12\x03\
	\x12\x07\x12\u{2d1}\x0a\x12\x0c\x12\x0e\x12\u{2d4}\x0b\x12\x03\x13\x03\x13\
	\x03\x13\x03\x13\x05\x13\u{2da}\x0a\x13\x03\x14\x03\x14\x03\x14\x03\x15\
	\x07\x15\u{2e0}\x0a\x15\x0c\x15\x0e\x15\u{2e3}\x0b\x15\x03\x15\x07\x15\u{2e6}\
	\x0a\x15\x0c\x15\x0e\x15\u{2e9}\x0b\x15\x03\x15\x03\x15\x03\x16\x03\x16\
	\x05\x16\u{2ef}\x0a\x16\x03\x16\x07\x16\u{2f2}\x0a\x16\x0c\x16\x0e\x16\u{2f5}\
	\x0b\x16\x03\x16\x03\x16\x07\x16\u{2f9}\x0a\x16\x0c\x16\x0e\x16\u{2fc}\x0b\
	\x16\x03\x16\x03\x16\x03\x17\x03\x17\x07\x17\u{302}\x0a\x17\x0c\x17\x0e\
	\x17\u{305}\x0b\x17\x03\x17\x03\x17\x07\x17\u{309}\x0a\x17\x0c\x17\x0e\x17\
	\u{30c}\x0b\x17\x03\x17\x03\x17\x07\x17\u{310}\x0a\x17\x0c\x17\x0e\x17\u{313}\
	\x0b\x17\x03\x17\x07\x17\u{316}\x0a\x17\x0c\x17\x0e\x17\u{319}\x0b\x17\x03\
	\x17\x07\x17\u{31c}\x0a\x17\x0c\x17\x0e\x17\u{31f}\x0b\x17\x03\x17\x05\x17\
	\u{322}\x0a\x17\x03\x17\x07\x17\u{325}\x0a\x17\x0c\x17\x0e\x17\u{328}\x0b\
	\x17\x03\x17\x03\x17\x03\x18\x05\x18\u{32d}\x0a\x18\x03\x18\x07\x18\u{330}\
	\x0a\x18\x0c\x18\x0e\x18\u{333}\x0b\x18\x03\x18\x03\x18\x07\x18\u{337}\x0a\
	\x18\x0c\x18\x0e\x18\u{33a}\x0b\x18\x03\x18\x03\x18\x07\x18\u{33e}\x0a\x18\
	\x0c\x18\x0e\x18\u{341}\x0b\x18\x03\x18\x05\x18\u{344}\x0a\x18\x03\x19\x03\
	\x19\x07\x19\u{348}\x0a\x19\x0c\x19\x0e\x19\u{34b}\x0b\x19\x03\x19\x03\x19\
	\x07\x19\u{34f}\x0a\x19\x0c\x19\x0e\x19\u{352}\x0b\x19\x03\x19\x03\x19\x07\
	\x19\u{356}\x0a\x19\x0c\x19\x0e\x19\u{359}\x0b\x19\x03\x19\x07\x19\u{35c}\
	\x0a\x19\x0c\x19\x0e\x19\u{35f}\x0b\x19\x03\x1a\x07\x1a\u{362}\x0a\x1a\x0c\
	\x1a\x0e\x1a\u{365}\x0b\x1a\x03\x1a\x03\x1a\x07\x1a\u{369}\x0a\x1a\x0c\x1a\
	\x0e\x1a\u{36c}\x0b\x1a\x03\x1a\x03\x1a\x07\x1a\u{370}\x0a\x1a\x0c\x1a\x0e\
	\x1a\u{373}\x0b\x1a\x03\x1a\x03\x1a\x03\x1b\x03\x1b\x05\x1b\u{379}\x0a\x1b\
	\x07\x1b\u{37b}\x0a\x1b\x0c\x1b\x0e\x1b\u{37e}\x0b\x1b\x03\x1c\x03\x1c\x03\
	\x1c\x03\x1c\x05\x1c\u{384}\x0a\x1c\x03\x1d\x03\x1d\x07\x1d\u{388}\x0a\x1d\
	\x0c\x1d\x0e\x1d\u{38b}\x0b\x1d\x03\x1d\x03\x1d\x03\x1e\x05\x1e\u{390}\x0a\
	\x1e\x03\x1e\x03\x1e\x07\x1e\u{394}\x0a\x1e\x0c\x1e\x0e\x1e\u{397}\x0b\x1e\
	\x03\x1e\x03\x1e\x07\x1e\u{39b}\x0a\x1e\x0c\x1e\x0e\x1e\u{39e}\x0b\x1e\x03\
	\x1e\x05\x1e\u{3a1}\x0a\x1e\x03\x1e\x07\x1e\u{3a4}\x0a\x1e\x0c\x1e\x0e\x1e\
	\u{3a7}\x0b\x1e\x03\x1e\x03\x1e\x07\x1e\u{3ab}\x0a\x1e\x0c\x1e\x0e\x1e\u{3ae}\
	\x0b\x1e\x03\x1e\x05\x1e\u{3b1}\x0a\x1e\x03\x1e\x07\x1e\u{3b4}\x0a\x1e\x0c\
	\x1e\x0e\x1e\u{3b7}\x0b\x1e\x03\x1e\x05\x1e\u{3ba}\x0a\x1e\x03\x1f\x03\x1f\
	\x07\x1f\u{3be}\x0a\x1f\x0c\x1f\x0e\x1f\u{3c1}\x0b\x1f\x03\x1f\x03\x1f\x07\
	\x1f\u{3c5}\x0a\x1f\x0c\x1f\x0e\x1f\u{3c8}\x0b\x1f\x03\x1f\x03\x1f\x07\x1f\
	\u{3cc}\x0a\x1f\x0c\x1f\x0e\x1f\u{3cf}\x0b\x1f\x03\x1f\x07\x1f\u{3d2}\x0a\
	\x1f\x0c\x1f\x0e\x1f\u{3d5}\x0b\x1f\x03\x1f\x07\x1f\u{3d8}\x0a\x1f\x0c\x1f\
	\x0e\x1f\u{3db}\x0b\x1f\x03\x1f\x05\x1f\u{3de}\x0a\x1f\x05\x1f\u{3e0}\x0a\
	\x1f\x03\x1f\x07\x1f\u{3e3}\x0a\x1f\x0c\x1f\x0e\x1f\u{3e6}\x0b\x1f\x03\x1f\
	\x03\x1f\x03\x20\x05\x20\u{3eb}\x0a\x20\x03\x20\x03\x20\x07\x20\u{3ef}\x0a\
	\x20\x0c\x20\x0e\x20\u{3f2}\x0b\x20\x03\x20\x03\x20\x07\x20\u{3f6}\x0a\x20\
	\x0c\x20\x0e\x20\u{3f9}\x0b\x20\x03\x20\x05\x20\u{3fc}\x0a\x20\x03\x21\x05\
	\x21\u{3ff}\x0a\x21\x03\x21\x03\x21\x07\x21\u{403}\x0a\x21\x0c\x21\x0e\x21\
	\u{406}\x0b\x21\x03\x21\x05\x21\u{409}\x0a\x21\x03\x21\x07\x21\u{40c}\x0a\
	\x21\x0c\x21\x0e\x21\u{40f}\x0b\x21\x03\x21\x03\x21\x07\x21\u{413}\x0a\x21\
	\x0c\x21\x0e\x21\u{416}\x0b\x21\x03\x21\x03\x21\x05\x21\u{41a}\x0a\x21\x03\
	\x21\x07\x21\u{41d}\x0a\x21\x0c\x21\x0e\x21\u{420}\x0b\x21\x03\x21\x03\x21\
	\x07\x21\u{424}\x0a\x21\x0c\x21\x0e\x21\u{427}\x0b\x21\x03\x21\x03\x21\x07\
	\x21\u{42b}\x0a\x21\x0c\x21\x0e\x21\u{42e}\x0b\x21\x03\x21\x03\x21\x07\x21\
	\u{432}\x0a\x21\x0c\x21\x0e\x21\u{435}\x0b\x21\x03\x21\x05\x21\u{438}\x0a\
	\x21\x03\x21\x07\x21\u{43b}\x0a\x21\x0c\x21\x0e\x21\u{43e}\x0b\x21\x03\x21\
	\x05\x21\u{441}\x0a\x21\x03\x21\x07\x21\u{444}\x0a\x21\x0c\x21\x0e\x21\u{447}\
	\x0b\x21\x03\x21\x05\x21\u{44a}\x0a\x21\x03\x22\x03\x22\x03\x22\x07\x22\
	\u{44f}\x0a\x22\x0c\x22\x0e\x22\u{452}\x0b\x22\x03\x22\x05\x22\u{455}\x0a\
	\x22\x03\x23\x07\x23\u{458}\x0a\x23\x0c\x23\x0e\x23\u{45b}\x0b\x23\x03\x23\
	\x07\x23\u{45e}\x0a\x23\x0c\x23\x0e\x23\u{461}\x0b\x23\x03\x23\x03\x23\x07\
	\x23\u{465}\x0a\x23\x0c\x23\x0e\x23\u{468}\x0b\x23\x03\x23\x03\x23\x07\x23\
	\u{46c}\x0a\x23\x0c\x23\x0e\x23\u{46f}\x0b\x23\x03\x23\x05\x23\u{472}\x0a\
	\x23\x03\x24\x03\x24\x07\x24\u{476}\x0a\x24\x0c\x24\x0e\x24\u{479}\x0b\x24\
	\x03\x24\x03\x24\x07\x24\u{47d}\x0a\x24\x0c\x24\x0e\x24\u{480}\x0b\x24\x03\
	\x24\x03\x24\x07\x24\u{484}\x0a\x24\x0c\x24\x0e\x24\u{487}\x0b\x24\x03\x24\
	\x07\x24\u{48a}\x0a\x24\x0c\x24\x0e\x24\u{48d}\x0b\x24\x03\x24\x07\x24\u{490}\
	\x0a\x24\x0c\x24\x0e\x24\u{493}\x0b\x24\x03\x24\x05\x24\u{496}\x0a\x24\x03\
	\x24\x07\x24\u{499}\x0a\x24\x0c\x24\x0e\x24\u{49c}\x0b\x24\x03\x24\x03\x24\
	\x03\x25\x05\x25\u{4a1}\x0a\x25\x03\x25\x03\x25\x07\x25\u{4a5}\x0a\x25\x0c\
	\x25\x0e\x25\u{4a8}\x0b\x25\x03\x25\x05\x25\u{4ab}\x0a\x25\x03\x25\x07\x25\
	\u{4ae}\x0a\x25\x0c\x25\x0e\x25\u{4b1}\x0b\x25\x03\x25\x03\x25\x07\x25\u{4b5}\
	\x0a\x25\x0c\x25\x0e\x25\u{4b8}\x0b\x25\x03\x25\x03\x25\x05\x25\u{4bc}\x0a\
	\x25\x03\x25\x07\x25\u{4bf}\x0a\x25\x0c\x25\x0e\x25\u{4c2}\x0b\x25\x03\x25\
	\x03\x25\x05\x25\u{4c6}\x0a\x25\x03\x25\x07\x25\u{4c9}\x0a\x25\x0c\x25\x0e\
	\x25\u{4cc}\x0b\x25\x03\x25\x05\x25\u{4cf}\x0a\x25\x03\x25\x07\x25\u{4d2}\
	\x0a\x25\x0c\x25\x0e\x25\u{4d5}\x0b\x25\x03\x25\x03\x25\x07\x25\u{4d9}\x0a\
	\x25\x0c\x25\x0e\x25\u{4dc}\x0b\x25\x03\x25\x03\x25\x05\x25\u{4e0}\x0a\x25\
	\x05\x25\u{4e2}\x0a\x25\x03\x25\x06\x25\u{4e5}\x0a\x25\x0d\x25\x0e\x25\u{4e6}\
	\x03\x25\x05\x25\u{4ea}\x0a\x25\x03\x25\x07\x25\u{4ed}\x0a\x25\x0c\x25\x0e\
	\x25\u{4f0}\x0b\x25\x03\x25\x05\x25\u{4f3}\x0a\x25\x03\x25\x07\x25\u{4f6}\
	\x0a\x25\x0c\x25\x0e\x25\u{4f9}\x0b\x25\x03\x25\x05\x25\u{4fc}\x0a\x25\x03\
	\x25\x05\x25\u{4ff}\x0a\x25\x03\x25\x05\x25\u{502}\x0a\x25\x03\x25\x07\x25\
	\u{505}\x0a\x25\x0c\x25\x0e\x25\u{508}\x0b\x25\x03\x25\x05\x25\u{50b}\x0a\
	\x25\x03\x25\x05\x25\u{50e}\x0a\x25\x05\x25\u{510}\x0a\x25\x03\x26\x03\x26\
	\x07\x26\u{514}\x0a\x26\x0c\x26\x0e\x26\u{517}\x0b\x26\x03\x26\x03\x26\x03\
	\x27\x05\x27\u{51c}\x0a\x27\x03\x27\x03\x27\x07\x27\u{520}\x0a\x27\x0c\x27\
	\x0e\x27\u{523}\x0b\x27\x03\x27\x03\x27\x07\x27\u{527}\x0a\x27\x0c\x27\x0e\
	\x27\u{52a}\x0b\x27\x03\x27\x03\x27\x07\x27\u{52e}\x0a\x27\x0c\x27\x0e\x27\
	\u{531}\x0b\x27\x03\x27\x03\x27\x07\x27\u{535}\x0a\x27\x0c\x27\x0e\x27\u{538}\
	\x0b\x27\x03\x27\x05\x27\u{53b}\x0a\x27\x03\x27\x07\x27\u{53e}\x0a\x27\x0c\
	\x27\x0e\x27\u{541}\x0b\x27\x03\x27\x05\x27\u{544}\x0a\x27\x03\x28\x05\x28\
	\u{547}\x0a\x28\x03\x28\x03\x28\x07\x28\u{54b}\x0a\x28\x0c\x28\x0e\x28\u{54e}\
	\x0b\x28\x03\x28\x03\x28\x07\x28\u{552}\x0a\x28\x0c\x28\x0e\x28\u{555}\x0b\
	\x28\x03\x28\x03\x28\x07\x28\u{559}\x0a\x28\x0c\x28\x0e\x28\u{55c}\x0b\x28\
	\x03\x28\x05\x28\u{55f}\x0a\x28\x03\x28\x07\x28\u{562}\x0a\x28\x0c\x28\x0e\
	\x28\u{565}\x0b\x28\x03\x28\x03\x28\x07\x28\u{569}\x0a\x28\x0c\x28\x0e\x28\
	\u{56c}\x0b\x28\x03\x28\x03\x28\x07\x28\u{570}\x0a\x28\x0c\x28\x0e\x28\u{573}\
	\x0b\x28\x03\x28\x05\x28\u{576}\x0a\x28\x03\x28\x07\x28\u{579}\x0a\x28\x0c\
	\x28\x0e\x28\u{57c}\x0b\x28\x03\x28\x03\x28\x05\x28\u{580}\x0a\x28\x03\x29\
	\x03\x29\x07\x29\u{584}\x0a\x29\x0c\x29\x0e\x29\u{587}\x0b\x29\x03\x29\x03\
	\x29\x07\x29\u{58b}\x0a\x29\x0c\x29\x0e\x29\u{58e}\x0b\x29\x03\x29\x03\x29\
	\x07\x29\u{592}\x0a\x29\x0c\x29\x0e\x29\u{595}\x0b\x29\x03\x29\x07\x29\u{598}\
	\x0a\x29\x0c\x29\x0e\x29\u{59b}\x0b\x29\x03\x29\x07\x29\u{59e}\x0a\x29\x0c\
	\x29\x0e\x29\u{5a1}\x0b\x29\x03\x29\x05\x29\u{5a4}\x0a\x29\x05\x29\u{5a6}\
	\x0a\x29\x03\x29\x07\x29\u{5a9}\x0a\x29\x0c\x29\x0e\x29\u{5ac}\x0b\x29\x03\
	\x29\x03\x29\x03\x2a\x05\x2a\u{5b1}\x0a\x2a\x03\x2a\x03\x2a\x07\x2a\u{5b5}\
	\x0a\x2a\x0c\x2a\x0e\x2a\u{5b8}\x0b\x2a\x03\x2a\x03\x2a\x07\x2a\u{5bc}\x0a\
	\x2a\x0c\x2a\x0e\x2a\u{5bf}\x0b\x2a\x03\x2a\x05\x2a\u{5c2}\x0a\x2a\x03\x2b\
	\x03\x2b\x07\x2b\u{5c6}\x0a\x2b\x0c\x2b\x0e\x2b\u{5c9}\x0b\x2b\x03\x2b\x03\
	\x2b\x07\x2b\u{5cd}\x0a\x2b\x0c\x2b\x0e\x2b\u{5d0}\x0b\x2b\x03\x2b\x05\x2b\
	\u{5d3}\x0a\x2b\x03\x2c\x03\x2c\x07\x2c\u{5d7}\x0a\x2c\x0c\x2c\x0e\x2c\u{5da}\
	\x0b\x2c\x03\x2c\x03\x2c\x07\x2c\u{5de}\x0a\x2c\x0c\x2c\x0e\x2c\u{5e1}\x0b\
	\x2c\x03\x2c\x03\x2c\x03\x2d\x05\x2d\u{5e6}\x0a\x2d\x03\x2d\x03\x2d\x07\
	\x2d\u{5ea}\x0a\x2d\x0c\x2d\x0e\x2d\u{5ed}\x0b\x2d\x03\x2d\x03\x2d\x07\x2d\
	\u{5f1}\x0a\x2d\x0c\x2d\x0e\x2d\u{5f4}\x0b\x2d\x03\x2d\x03\x2d\x07\x2d\u{5f8}\
	\x0a\x2d\x0c\x2d\x0e\x2d\u{5fb}\x0b\x2d\x03\x2d\x05\x2d\u{5fe}\x0a\x2d\x03\
	\x2d\x07\x2d\u{601}\x0a\x2d\x0c\x2d\x0e\x2d\u{604}\x0b\x2d\x03\x2d\x05\x2d\
	\u{607}\x0a\x2d\x03\x2e\x05\x2e\u{60a}\x0a\x2e\x03\x2e\x03\x2e\x07\x2e\u{60e}\
	\x0a\x2e\x0c\x2e\x0e\x2e\u{611}\x0b\x2e\x03\x2e\x03\x2e\x07\x2e\u{615}\x0a\
	\x2e\x0c\x2e\x0e\x2e\u{618}\x0b\x2e\x03\x2e\x03\x2e\x07\x2e\u{61c}\x0a\x2e\
	\x0c\x2e\x0e\x2e\u{61f}\x0b\x2e\x03\x2e\x05\x2e\u{622}\x0a\x2e\x03\x2e\x07\
	\x2e\u{625}\x0a\x2e\x0c\x2e\x0e\x2e\u{628}\x0b\x2e\x03\x2e\x05\x2e\u{62b}\
	\x0a\x2e\x03\x2f\x03\x2f\x07\x2f\u{62f}\x0a\x2f\x0c\x2f\x0e\x2f\u{632}\x0b\
	\x2f\x03\x2f\x03\x2f\x03\x30\x03\x30\x07\x30\u{638}\x0a\x30\x0c\x30\x0e\
	\x30\u{63b}\x0b\x30\x03\x30\x05\x30\u{63e}\x0a\x30\x03\x30\x07\x30\u{641}\
	\x0a\x30\x0c\x30\x0e\x30\u{644}\x0b\x30\x03\x30\x03\x30\x07\x30\u{648}\x0a\
	\x30\x0c\x30\x0e\x30\u{64b}\x0b\x30\x03\x30\x05\x30\u{64e}\x0a\x30\x03\x30\
	\x07\x30\u{651}\x0a\x30\x0c\x30\x0e\x30\u{654}\x0b\x30\x03\x30\x03\x30\x03\
	\x31\x03\x31\x07\x31\u{65a}\x0a\x31\x0c\x31\x0e\x31\u{65d}\x0b\x31\x03\x31\
	\x03\x31\x07\x31\u{661}\x0a\x31\x0c\x31\x0e\x31\u{664}\x0b\x31\x03\x31\x07\
	\x31\u{667}\x0a\x31\x0c\x31\x0e\x31\u{66a}\x0b\x31\x03\x31\x07\x31\u{66d}\
	\x0a\x31\x0c\x31\x0e\x31\u{670}\x0b\x31\x03\x31\x05\x31\u{673}\x0a\x31\x03\
	\x32\x03\x32\x07\x32\u{677}\x0a\x32\x0c\x32\x0e\x32\u{67a}\x0b\x32\x05\x32\
	\u{67c}\x0a\x32\x03\x32\x03\x32\x07\x32\u{680}\x0a\x32\x0c\x32\x0e\x32\u{683}\
	\x0b\x32\x03\x32\x05\x32\u{686}\x0a\x32\x03\x32\x07\x32\u{689}\x0a\x32\x0c\
	\x32\x0e\x32\u{68c}\x0b\x32\x03\x32\x05\x32\u{68f}\x0a\x32\x03\x33\x05\x33\
	\u{692}\x0a\x33\x03\x33\x03\x33\x03\x33\x03\x33\x05\x33\u{698}\x0a\x33\x03\
	\x34\x03\x34\x05\x34\u{69c}\x0a\x34\x03\x35\x03\x35\x05\x35\u{6a0}\x0a\x35\
	\x03\x35\x07\x35\u{6a3}\x0a\x35\x0c\x35\x0e\x35\u{6a6}\x0b\x35\x03\x35\x06\
	\x35\u{6a9}\x0a\x35\x0d\x35\x0e\x35\u{6aa}\x03\x36\x03\x36\x03\x37\x03\x37\
	\x07\x37\u{6b1}\x0a\x37\x0c\x37\x0e\x37\u{6b4}\x0b\x37\x03\x37\x03\x37\x07\
	\x37\u{6b8}\x0a\x37\x0c\x37\x0e\x37\u{6bb}\x0b\x37\x03\x37\x07\x37\u{6be}\
	\x0a\x37\x0c\x37\x0e\x37\u{6c1}\x0b\x37\x03\x38\x03\x38\x07\x38\u{6c5}\x0a\
	\x38\x0c\x38\x0e\x38\u{6c8}\x0b\x38\x03\x38\x05\x38\u{6cb}\x0a\x38\x03\x39\
	\x05\x39\u{6ce}\x0a\x39\x03\x39\x03\x39\x05\x39\u{6d2}\x0a\x39\x03\x3a\x06\
	\x3a\u{6d5}\x0a\x3a\x0d\x3a\x0e\x3a\u{6d6}\x03\x3b\x03\x3b\x07\x3b\u{6db}\
	\x0a\x3b\x0c\x3b\x0e\x3b\u{6de}\x0b\x3b\x03\x3b\x05\x3b\u{6e1}\x0a\x3b\x03\
	\x3c\x03\x3c\x07\x3c\u{6e5}\x0a\x3c\x0c\x3c\x0e\x3c\u{6e8}\x0b\x3c\x03\x3c\
	\x03\x3c\x07\x3c\u{6ec}\x0a\x3c\x0c\x3c\x0e\x3c\u{6ef}\x0b\x3c\x05\x3c\u{6f1}\
	\x0a\x3c\x03\x3c\x03\x3c\x07\x3c\u{6f5}\x0a\x3c\x0c\x3c\x0e\x3c\u{6f8}\x0b\
	\x3c\x03\x3c\x03\x3c\x07\x3c\u{6fc}\x0a\x3c\x0c\x3c\x0e\x3c\u{6ff}\x0b\x3c\
	\x03\x3c\x03\x3c\x03\x3d\x03\x3d\x07\x3d\u{705}\x0a\x3d\x0c\x3d\x0e\x3d\
	\u{708}\x0b\x3d\x03\x3d\x03\x3d\x05\x3d\u{70c}\x0a\x3d\x03\x3d\x07\x3d\u{70f}\
	\x0a\x3d\x0c\x3d\x0e\x3d\u{712}\x0b\x3d\x03\x3d\x03\x3d\x07\x3d\u{716}\x0a\
	\x3d\x0c\x3d\x0e\x3d\u{719}\x0b\x3d\x03\x3d\x03\x3d\x05\x3d\u{71d}\x0a\x3d\
	\x07\x3d\u{71f}\x0a\x3d\x0c\x3d\x0e\x3d\u{722}\x0b\x3d\x03\x3d\x07\x3d\u{725}\
	\x0a\x3d\x0c\x3d\x0e\x3d\u{728}\x0b\x3d\x03\x3d\x05\x3d\u{72b}\x0a\x3d\x03\
	\x3d\x07\x3d\u{72e}\x0a\x3d\x0c\x3d\x0e\x3d\u{731}\x0b\x3d\x03\x3d\x03\x3d\
	\x03\x3e\x03\x3e\x07\x3e\u{737}\x0a\x3e\x0c\x3e\x0e\x3e\u{73a}\x0b\x3e\x03\
	\x3e\x03\x3e\x07\x3e\u{73e}\x0a\x3e\x0c\x3e\x0e\x3e\u{741}\x0b\x3e\x03\x3e\
	\x03\x3e\x03\x3f\x05\x3f\u{746}\x0a\x3f\x03\x3f\x03\x3f\x03\x3f\x05\x3f\
	\u{74b}\x0a\x3f\x03\x40\x03\x40\x07\x40\u{74f}\x0a\x40\x0c\x40\x0e\x40\u{752}\
	\x0b\x40\x03\x40\x03\x40\x05\x40\u{756}\x0a\x40\x03\x40\x07\x40\u{759}\x0a\
	\x40\x0c\x40\x0e\x40\u{75c}\x0b\x40\x03\x40\x03\x40\x03\x41\x03\x41\x03\
	\x41\x03\x41\x07\x41\u{764}\x0a\x41\x0c\x41\x0e\x41\u{767}\x0b\x41\x05\x41\
	\u{769}\x0a\x41\x03\x41\x05\x41\u{76c}\x0a\x41\x03\x42\x03\x42\x07\x42\u{770}\
	\x0a\x42\x0c\x42\x0e\x42\u{773}\x0b\x42\x03\x42\x03\x42\x03\x42\x03\x42\
	\x05\x42\u{779}\x0a\x42\x03\x43\x03\x43\x03\x43\x07\x43\u{77e}\x0a\x43\x0c\
	\x43\x0e\x43\u{781}\x0b\x43\x03\x44\x03\x44\x05\x44\u{785}\x0a\x44\x03\x45\
	\x03\x45\x07\x45\u{789}\x0a\x45\x0c\x45\x0e\x45\u{78c}\x0b\x45\x03\x45\x03\
	\x45\x07\x45\u{790}\x0a\x45\x0c\x45\x0e\x45\u{793}\x0b\x45\x03\x45\x03\x45\
	\x03\x46\x03\x46\x03\x46\x05\x46\u{79a}\x0a\x46\x03\x47\x03\x47\x07\x47\
	\u{79e}\x0a\x47\x0c\x47\x0e\x47\u{7a1}\x0b\x47\x03\x47\x03\x47\x07\x47\u{7a5}\
	\x0a\x47\x0c\x47\x0e\x47\u{7a8}\x0b\x47\x03\x47\x03\x47\x05\x47\u{7ac}\x0a\
	\x47\x03\x47\x03\x47\x03\x47\x03\x47\x07\x47\u{7b2}\x0a\x47\x0c\x47\x0e\
	\x47\u{7b5}\x0b\x47\x03\x47\x05\x47\u{7b8}\x0a\x47\x03\x48\x03\x48\x07\x48\
	\u{7bc}\x0a\x48\x0c\x48\x0e\x48\u{7bf}\x0b\x48\x03\x48\x03\x48\x03\x48\x03\
	\x48\x07\x48\u{7c5}\x0a\x48\x0c\x48\x0e\x48\u{7c8}\x0b\x48\x03\x48\x03\x48\
	\x05\x48\u{7cc}\x0a\x48\x03\x49\x03\x49\x07\x49\u{7d0}\x0a\x49\x0c\x49\x0e\
	\x49\u{7d3}\x0b\x49\x03\x49\x05\x49\u{7d6}\x0a\x49\x03\x49\x07\x49\u{7d9}\
	\x0a\x49\x0c\x49\x0e\x49\u{7dc}\x0b\x49\x03\x49\x03\x49\x07\x49\u{7e0}\x0a\
	\x49\x0c\x49\x0e\x49\u{7e3}\x0b\x49\x03\x49\x03\x49\x03\x49\x03\x49\x03\
	\x4a\x03\x4a\x03\x4a\x03\x4a\x03\x4a\x03\x4a\x05\x4a\u{7ef}\x0a\x4a\x03\
	\x4a\x07\x4a\u{7f2}\x0a\x4a\x0c\x4a\x0e\x4a\u{7f5}\x0b\x4a\x03\x4a\x03\x4a\
	\x03\x4b\x03\x4b\x07\x4b\u{7fb}\x0a\x4b\x0c\x4b\x0e\x4b\u{7fe}\x0b\x4b\x03\
	\x4b\x05\x4b\u{801}\x0a\x4b\x03\x4c\x06\x4c\u{804}\x0a\x4c\x0d\x4c\x0e\x4c\
	\u{805}\x03\x4c\x05\x4c\u{809}\x0a\x4c\x03\x4d\x03\x4d\x03\x4e\x03\x4e\x07\
	\x4e\u{80f}\x0a\x4e\x0c\x4e\x0e\x4e\u{812}\x0b\x4e\x03\x4e\x03\x4e\x07\x4e\
	\u{816}\x0a\x4e\x0c\x4e\x0e\x4e\u{819}\x0b\x4e\x03\x4e\x07\x4e\u{81c}\x0a\
	\x4e\x0c\x4e\x0e\x4e\u{81f}\x0b\x4e\x03\x4f\x03\x4f\x07\x4f\u{823}\x0a\x4f\
	\x0c\x4f\x0e\x4f\u{826}\x0b\x4f\x03\x4f\x03\x4f\x07\x4f\u{82a}\x0a\x4f\x0c\
	\x4f\x0e\x4f\u{82d}\x0b\x4f\x03\x4f\x07\x4f\u{830}\x0a\x4f\x0c\x4f\x0e\x4f\
	\u{833}\x0b\x4f\x03\x50\x03\x50\x03\x50\x07\x50\u{838}\x0a\x50\x0c\x50\x0e\
	\x50\u{83b}\x0b\x50\x03\x50\x03\x50\x07\x50\u{83f}\x0a\x50\x0c\x50\x0e\x50\
	\u{842}\x0b\x50\x03\x51\x03\x51\x03\x51\x07\x51\u{847}\x0a\x51\x0c\x51\x0e\
	\x51\u{84a}\x0b\x51\x03\x51\x03\x51\x07\x51\u{84e}\x0a\x51\x0c\x51\x0e\x51\
	\u{851}\x0b\x51\x03\x52\x03\x52\x07\x52\u{855}\x0a\x52\x0c\x52\x0e\x52\u{858}\
	\x0b\x52\x03\x53\x03\x53\x03\x53\x07\x53\u{85d}\x0a\x53\x0c\x53\x0e\x53\
	\u{860}\x0b\x53\x03\x53\x03\x53\x03\x53\x03\x53\x07\x53\u{866}\x0a\x53\x0c\
	\x53\x0e\x53\u{869}\x0b\x53\x03\x53\x03\x53\x07\x53\u{86d}\x0a\x53\x0c\x53\
	\x0e\x53\u{870}\x0b\x53\x03\x54\x03\x54\x07\x54\u{874}\x0a\x54\x0c\x54\x0e\
	\x54\u{877}\x0b\x54\x03\x54\x03\x54\x07\x54\u{87b}\x0a\x54\x0c\x54\x0e\x54\
	\u{87e}\x0b\x54\x03\x54\x03\x54\x07\x54\u{882}\x0a\x54\x0c\x54\x0e\x54\u{885}\
	\x0b\x54\x03\x55\x03\x55\x03\x55\x03\x56\x03\x56\x03\x56\x07\x56\u{88d}\
	\x0a\x56\x0c\x56\x0e\x56\u{890}\x0b\x56\x03\x56\x03\x56\x07\x56\u{894}\x0a\
	\x56\x0c\x56\x0e\x56\u{897}\x0b\x56\x03\x57\x03\x57\x03\x57\x07\x57\u{89c}\
	\x0a\x57\x0c\x57\x0e\x57\u{89f}\x0b\x57\x03\x57\x07\x57\u{8a2}\x0a\x57\x0c\
	\x57\x0e\x57\u{8a5}\x0b\x57\x03\x58\x03\x58\x03\x58\x07\x58\u{8aa}\x0a\x58\
	\x0c\x58\x0e\x58\u{8ad}\x0b\x58\x03\x58\x03\x58\x07\x58\u{8b1}\x0a\x58\x0c\
	\x58\x0e\x58\u{8b4}\x0b\x58\x03\x59\x03\x59\x03\x59\x07\x59\u{8b9}\x0a\x59\
	\x0c\x59\x0e\x59\u{8bc}\x0b\x59\x03\x59\x03\x59\x07\x59\u{8c0}\x0a\x59\x0c\
	\x59\x0e\x59\u{8c3}\x0b\x59\x03\x5a\x03\x5a\x07\x5a\u{8c7}\x0a\x5a\x0c\x5a\
	\x0e\x5a\u{8ca}\x0b\x5a\x03\x5a\x03\x5a\x07\x5a\u{8ce}\x0a\x5a\x0c\x5a\x0e\
	\x5a\u{8d1}\x0b\x5a\x03\x5a\x03\x5a\x07\x5a\u{8d5}\x0a\x5a\x0c\x5a\x0e\x5a\
	\u{8d8}\x0b\x5a\x03\x5b\x07\x5b\u{8db}\x0a\x5b\x0c\x5b\x0e\x5b\u{8de}\x0b\
	\x5b\x03\x5b\x03\x5b\x03\x5c\x03\x5c\x03\x5c\x03\x5c\x07\x5c\u{8e6}\x0a\
	\x5c\x0c\x5c\x0e\x5c\u{8e9}\x0b\x5c\x05\x5c\u{8eb}\x0a\x5c\x03\x5d\x03\x5d\
	\x07\x5d\u{8ef}\x0a\x5d\x0c\x5d\x0e\x5d\u{8f2}\x0b\x5d\x03\x5e\x03\x5e\x03\
	\x5e\x03\x5e\x03\x5e\x05\x5e\u{8f9}\x0a\x5e\x03\x5f\x03\x5f\x03\x5f\x03\
	\x5f\x03\x5f\x05\x5f\u{900}\x0a\x5f\x03\x60\x03\x60\x07\x60\u{904}\x0a\x60\
	\x0c\x60\x0e\x60\u{907}\x0b\x60\x03\x60\x03\x60\x07\x60\u{90b}\x0a\x60\x0c\
	\x60\x0e\x60\u{90e}\x0b\x60\x03\x60\x03\x60\x03\x61\x03\x61\x05\x61\u{914}\
	\x0a\x61\x03\x62\x03\x62\x07\x62\u{918}\x0a\x62\x0c\x62\x0e\x62\u{91b}\x0b\
	\x62\x03\x62\x03\x62\x07\x62\u{91f}\x0a\x62\x0c\x62\x0e\x62\u{922}\x0b\x62\
	\x03\x62\x03\x62\x03\x63\x03\x63\x03\x63\x05\x63\u{929}\x0a\x63\x03\x64\
	\x03\x64\x07\x64\u{92d}\x0a\x64\x0c\x64\x0e\x64\u{930}\x0b\x64\x03\x64\x03\
	\x64\x07\x64\u{934}\x0a\x64\x0c\x64\x0e\x64\u{937}\x0b\x64\x03\x64\x03\x64\
	\x07\x64\u{93b}\x0a\x64\x0c\x64\x0e\x64\u{93e}\x0b\x64\x03\x64\x07\x64\u{941}\
	\x0a\x64\x0c\x64\x0e\x64\u{944}\x0b\x64\x03\x64\x07\x64\u{947}\x0a\x64\x0c\
	\x64\x0e\x64\u{94a}\x0b\x64\x03\x64\x05\x64\u{94d}\x0a\x64\x03\x64\x07\x64\
	\u{950}\x0a\x64\x0c\x64\x0e\x64\u{953}\x0b\x64\x03\x64\x03\x64\x03\x65\x03\
	\x65\x07\x65\u{959}\x0a\x65\x0c\x65\x0e\x65\u{95c}\x0b\x65\x03\x65\x03\x65\
	\x03\x65\x05\x65\u{961}\x0a\x65\x03\x66\x05\x66\u{964}\x0a\x66\x03\x66\x05\
	\x66\u{967}\x0a\x66\x03\x66\x03\x66\x05\x66\u{96b}\x0a\x66\x03\x67\x07\x67\
	\u{96e}\x0a\x67\x0c\x67\x0e\x67\u{971}\x0b\x67\x03\x67\x05\x67\u{974}\x0a\
	\x67\x03\x67\x07\x67\u{977}\x0a\x67\x0c\x67\x0e\x67\u{97a}\x0b\x67\x03\x67\
	\x03\x67\x03\x68\x03\x68\x07\x68\u{980}\x0a\x68\x0c\x68\x0e\x68\u{983}\x0b\
	\x68\x03\x68\x03\x68\x07\x68\u{987}\x0a\x68\x0c\x68\x0e\x68\u{98a}\x0b\x68\
	\x03\x68\x03\x68\x07\x68\u{98e}\x0a\x68\x0c\x68\x0e\x68\u{991}\x0b\x68\x03\
	\x68\x07\x68\u{994}\x0a\x68\x0c\x68\x0e\x68\u{997}\x0b\x68\x03\x68\x07\x68\
	\u{99a}\x0a\x68\x0c\x68\x0e\x68\u{99d}\x0b\x68\x03\x68\x05\x68\u{9a0}\x0a\
	\x68\x03\x68\x07\x68\u{9a3}\x0a\x68\x0c\x68\x0e\x68\u{9a6}\x0b\x68\x03\x68\
	\x03\x68\x03\x69\x03\x69\x07\x69\u{9ac}\x0a\x69\x0c\x69\x0e\x69\u{9af}\x0b\
	\x69\x03\x69\x03\x69\x07\x69\u{9b3}\x0a\x69\x0c\x69\x0e\x69\u{9b6}\x0b\x69\
	\x03\x69\x03\x69\x07\x69\u{9ba}\x0a\x69\x0c\x69\x0e\x69\u{9bd}\x0b\x69\x03\
	\x69\x07\x69\u{9c0}\x0a\x69\x0c\x69\x0e\x69\u{9c3}\x0b\x69\x03\x69\x07\x69\
	\u{9c6}\x0a\x69\x0c\x69\x0e\x69\u{9c9}\x0b\x69\x03\x69\x05\x69\u{9cc}\x0a\
	\x69\x03\x69\x07\x69\u{9cf}\x0a\x69\x0c\x69\x0e\x69\u{9d2}\x0b\x69\x05\x69\
	\u{9d4}\x0a\x69\x03\x69\x03\x69\x03\x6a\x05\x6a\u{9d9}\x0a\x6a\x03\x6a\x07\
	\x6a\u{9dc}\x0a\x6a\x0c\x6a\x0e\x6a\u{9df}\x0b\x6a\x03\x6a\x03\x6a\x07\x6a\
	\u{9e3}\x0a\x6a\x0c\x6a\x0e\x6a\u{9e6}\x0b\x6a\x03\x6a\x03\x6a\x07\x6a\u{9ea}\
	\x0a\x6a\x0c\x6a\x0e\x6a\u{9ed}\x0b\x6a\x05\x6a\u{9ef}\x0a\x6a\x03\x6a\x05\
	\x6a\u{9f2}\x0a\x6a\x03\x6a\x07\x6a\u{9f5}\x0a\x6a\x0c\x6a\x0e\x6a\u{9f8}\
	\x0b\x6a\x03\x6a\x03\x6a\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x03\x6b\
	\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x05\x6b\
	\u{a0a}\x0a\x6b\x03\x6c\x03\x6c\x07\x6c\u{a0e}\x0a\x6c\x0c\x6c\x0e\x6c\u{a11}\
	\x0b\x6c\x03\x6c\x03\x6c\x07\x6c\u{a15}\x0a\x6c\x0c\x6c\x0e\x6c\u{a18}\x0b\
	\x6c\x03\x6c\x03\x6c\x03\x6d\x03\x6d\x07\x6d\u{a1e}\x0a\x6d\x0c\x6d\x0e\
	\x6d\u{a21}\x0b\x6d\x03\x6d\x03\x6d\x07\x6d\u{a25}\x0a\x6d\x0c\x6d\x0e\x6d\
	\u{a28}\x0b\x6d\x03\x6d\x03\x6d\x07\x6d\u{a2c}\x0a\x6d\x0c\x6d\x0e\x6d\u{a2f}\
	\x0b\x6d\x03\x6d\x07\x6d\u{a32}\x0a\x6d\x0c\x6d\x0e\x6d\u{a35}\x0b\x6d\x03\
	\x6d\x07\x6d\u{a38}\x0a\x6d\x0c\x6d\x0e\x6d\u{a3b}\x0b\x6d\x03\x6d\x05\x6d\
	\u{a3e}\x0a\x6d\x03\x6d\x07\x6d\u{a41}\x0a\x6d\x0c\x6d\x0e\x6d\u{a44}\x0b\
	\x6d\x05\x6d\u{a46}\x0a\x6d\x03\x6d\x03\x6d\x03\x6e\x03\x6e\x03\x6f\x03\
	\x6f\x05\x6f\u{a4e}\x0a\x6f\x03\x70\x03\x70\x03\x70\x07\x70\u{a53}\x0a\x70\
	\x0c\x70\x0e\x70\u{a56}\x0b\x70\x03\x70\x03\x70\x03\x71\x03\x71\x03\x71\
	\x03\x71\x07\x71\u{a5e}\x0a\x71\x0c\x71\x0e\x71\u{a61}\x0b\x71\x03\x71\x03\
	\x71\x03\x72\x03\x72\x03\x73\x03\x73\x07\x73\u{a69}\x0a\x73\x0c\x73\x0e\
	\x73\u{a6c}\x0b\x73\x03\x73\x03\x73\x07\x73\u{a70}\x0a\x73\x0c\x73\x0e\x73\
	\u{a73}\x0b\x73\x03\x73\x03\x73\x03\x74\x03\x74\x03\x75\x03\x75\x07\x75\
	\u{a7b}\x0a\x75\x0c\x75\x0e\x75\u{a7e}\x0b\x75\x03\x75\x03\x75\x07\x75\u{a82}\
	\x0a\x75\x0c\x75\x0e\x75\u{a85}\x0b\x75\x03\x75\x03\x75\x03\x76\x03\x76\
	\x07\x76\u{a8b}\x0a\x76\x0c\x76\x0e\x76\u{a8e}\x0b\x76\x03\x76\x05\x76\u{a91}\
	\x0a\x76\x03\x76\x07\x76\u{a94}\x0a\x76\x0c\x76\x0e\x76\u{a97}\x0b\x76\x03\
	\x76\x03\x76\x07\x76\u{a9b}\x0a\x76\x0c\x76\x0e\x76\u{a9e}\x0b\x76\x05\x76\
	\u{aa0}\x0a\x76\x03\x76\x03\x76\x07\x76\u{aa4}\x0a\x76\x0c\x76\x0e\x76\u{aa7}\
	\x0b\x76\x03\x76\x03\x76\x03\x77\x03\x77\x07\x77\u{aad}\x0a\x77\x0c\x77\
	\x0e\x77\u{ab0}\x0b\x77\x03\x77\x03\x77\x07\x77\u{ab4}\x0a\x77\x0c\x77\x0e\
	\x77\u{ab7}\x0b\x77\x03\x77\x07\x77\u{aba}\x0a\x77\x0c\x77\x0e\x77\u{abd}\
	\x0b\x77\x03\x77\x07\x77\u{ac0}\x0a\x77\x0c\x77\x0e\x77\u{ac3}\x0b\x77\x03\
	\x77\x05\x77\u{ac6}\x0a\x77\x03\x78\x03\x78\x03\x78\x07\x78\u{acb}\x0a\x78\
	\x0c\x78\x0e\x78\u{ace}\x0b\x78\x03\x78\x03\x78\x07\x78\u{ad2}\x0a\x78\x0c\
	\x78\x0e\x78\u{ad5}\x0b\x78\x03\x78\x05\x78\u{ad8}\x0a\x78\x05\x78\u{ada}\
	\x0a\x78\x03\x79\x03\x79\x07\x79\u{ade}\x0a\x79\x0c\x79\x0e\x79\u{ae1}\x0b\
	\x79\x03\x79\x03\x79\x07\x79\u{ae5}\x0a\x79\x0c\x79\x0e\x79\u{ae8}\x0b\x79\
	\x03\x79\x03\x79\x05\x79\u{aec}\x0a\x79\x03\x79\x07\x79\u{aef}\x0a\x79\x0c\
	\x79\x0e\x79\u{af2}\x0b\x79\x03\x79\x03\x79\x07\x79\u{af6}\x0a\x79\x0c\x79\
	\x0e\x79\u{af9}\x0b\x79\x03\x79\x03\x79\x07\x79\u{afd}\x0a\x79\x0c\x79\x0e\
	\x79\u{b00}\x0b\x79\x03\x79\x05\x79\u{b03}\x0a\x79\x03\x79\x07\x79\u{b06}\
	\x0a\x79\x0c\x79\x0e\x79\u{b09}\x0b\x79\x03\x79\x05\x79\u{b0c}\x0a\x79\x03\
	\x79\x07\x79\u{b0f}\x0a\x79\x0c\x79\x0e\x79\u{b12}\x0b\x79\x03\x79\x05\x79\
	\u{b15}\x0a\x79\x03\x7a\x03\x7a\x05\x7a\u{b19}\x0a\x7a\x03\x7b\x03\x7b\x07\
	\x7b\u{b1d}\x0a\x7b\x0c\x7b\x0e\x7b\u{b20}\x0b\x7b\x03\x7b\x03\x7b\x07\x7b\
	\u{b24}\x0a\x7b\x0c\x7b\x0e\x7b\u{b27}\x0b\x7b\x03\x7b\x03\x7b\x07\x7b\u{b2b}\
	\x0a\x7b\x0c\x7b\x0e\x7b\u{b2e}\x0b\x7b\x05\x7b\u{b30}\x0a\x7b\x03\x7b\x07\
	\x7b\u{b33}\x0a\x7b\x0c\x7b\x0e\x7b\u{b36}\x0b\x7b\x03\x7b\x05\x7b\u{b39}\
	\x0a\x7b\x03\x7c\x03\x7c\x03\x7d\x03\x7d\x03\x7d\x07\x7d\u{b40}\x0a\x7d\
	\x0c\x7d\x0e\x7d\u{b43}\x0b\x7d\x03\x7d\x03\x7d\x07\x7d\u{b47}\x0a\x7d\x0c\
	\x7d\x0e\x7d\u{b4a}\x0b\x7d\x03\x7d\x03\x7d\x05\x7d\u{b4e}\x0a\x7d\x03\x7d\
	\x03\x7d\x05\x7d\u{b52}\x0a\x7d\x03\x7d\x05\x7d\u{b55}\x0a\x7d\x03\x7e\x03\
	\x7e\x07\x7e\u{b59}\x0a\x7e\x0c\x7e\x0e\x7e\u{b5c}\x0b\x7e\x03\x7e\x03\x7e\
	\x07\x7e\u{b60}\x0a\x7e\x0c\x7e\x0e\x7e\u{b63}\x0b\x7e\x03\x7e\x03\x7e\x07\
	\x7e\u{b67}\x0a\x7e\x0c\x7e\x0e\x7e\u{b6a}\x0b\x7e\x03\x7e\x03\x7e\x07\x7e\
	\u{b6e}\x0a\x7e\x0c\x7e\x0e\x7e\u{b71}\x0b\x7e\x03\x7e\x03\x7e\x05\x7e\u{b75}\
	\x0a\x7e\x03\x7e\x07\x7e\u{b78}\x0a\x7e\x0c\x7e\x0e\x7e\u{b7b}\x0b\x7e\x03\
	\x7e\x05\x7e\u{b7e}\x0a\x7e\x03\x7e\x07\x7e\u{b81}\x0a\x7e\x0c\x7e\x0e\x7e\
	\u{b84}\x0b\x7e\x03\x7e\x03\x7e\x07\x7e\u{b88}\x0a\x7e\x0c\x7e\x0e\x7e\u{b8b}\
	\x0b\x7e\x03\x7e\x03\x7e\x05\x7e\u{b8f}\x0a\x7e\x03\x7e\x05\x7e\u{b92}\x0a\
	\x7e\x03\x7f\x03\x7f\x07\x7f\u{b96}\x0a\x7f\x0c\x7f\x0e\x7f\u{b99}\x0b\x7f\
	\x03\x7f\x07\x7f\u{b9c}\x0a\x7f\x0c\x7f\x0e\x7f\u{b9f}\x0b\x7f\x03\x7f\x03\
	\x7f\x07\x7f\u{ba3}\x0a\x7f\x0c\x7f\x0e\x7f\u{ba6}\x0b\x7f\x03\x7f\x03\x7f\
	\x07\x7f\u{baa}\x0a\x7f\x0c\x7f\x0e\x7f\u{bad}\x0b\x7f\x03\x7f\x03\x7f\x07\
	\x7f\u{bb1}\x0a\x7f\x0c\x7f\x0e\x7f\u{bb4}\x0b\x7f\x05\x7f\u{bb6}\x0a\x7f\
	\x03\x7f\x03\x7f\x03\x7f\x03\u{80}\x03\u{80}\x07\u{80}\u{bbd}\x0a\u{80}\
	\x0c\u{80}\x0e\u{80}\u{bc0}\x0b\u{80}\x03\u{80}\x05\u{80}\u{bc3}\x0a\u{80}\
	\x03\u{80}\x07\u{80}\u{bc6}\x0a\u{80}\x0c\u{80}\x0e\u{80}\u{bc9}\x0b\u{80}\
	\x03\u{80}\x03\u{80}\x07\u{80}\u{bcd}\x0a\u{80}\x0c\u{80}\x0e\u{80}\u{bd0}\
	\x0b\u{80}\x03\u{80}\x03\u{80}\x07\u{80}\u{bd4}\x0a\u{80}\x0c\u{80}\x0e\
	\u{80}\u{bd7}\x0b\u{80}\x07\u{80}\u{bd9}\x0a\u{80}\x0c\u{80}\x0e\u{80}\u{bdc}\
	\x0b\u{80}\x03\u{80}\x07\u{80}\u{bdf}\x0a\u{80}\x0c\u{80}\x0e\u{80}\u{be2}\
	\x0b\u{80}\x03\u{80}\x03\u{80}\x03\u{81}\x03\u{81}\x07\u{81}\u{be8}\x0a\
	\u{81}\x0c\u{81}\x0e\u{81}\u{beb}\x0b\u{81}\x03\u{81}\x03\u{81}\x07\u{81}\
	\u{bef}\x0a\u{81}\x0c\u{81}\x0e\u{81}\u{bf2}\x0b\u{81}\x03\u{81}\x07\u{81}\
	\u{bf5}\x0a\u{81}\x0c\u{81}\x0e\u{81}\u{bf8}\x0b\u{81}\x03\u{81}\x07\u{81}\
	\u{bfb}\x0a\u{81}\x0c\u{81}\x0e\u{81}\u{bfe}\x0b\u{81}\x03\u{81}\x05\u{81}\
	\u{c01}\x0a\u{81}\x03\u{81}\x07\u{81}\u{c04}\x0a\u{81}\x0c\u{81}\x0e\u{81}\
	\u{c07}\x0b\u{81}\x03\u{81}\x03\u{81}\x07\u{81}\u{c0b}\x0a\u{81}\x0c\u{81}\
	\x0e\u{81}\u{c0e}\x0b\u{81}\x03\u{81}\x03\u{81}\x05\u{81}\u{c12}\x0a\u{81}\
	\x03\u{81}\x03\u{81}\x07\u{81}\u{c16}\x0a\u{81}\x0c\u{81}\x0e\u{81}\u{c19}\
	\x0b\u{81}\x03\u{81}\x03\u{81}\x07\u{81}\u{c1d}\x0a\u{81}\x0c\u{81}\x0e\
	\u{81}\u{c20}\x0b\u{81}\x03\u{81}\x03\u{81}\x05\u{81}\u{c24}\x0a\u{81}\x05\
	\u{81}\u{c26}\x0a\u{81}\x03\u{82}\x03\u{82}\x03\u{82}\x05\u{82}\u{c2b}\x0a\
	\u{82}\x03\u{83}\x03\u{83}\x07\u{83}\u{c2f}\x0a\u{83}\x0c\u{83}\x0e\u{83}\
	\u{c32}\x0b\u{83}\x03\u{83}\x03\u{83}\x03\u{84}\x03\u{84}\x07\u{84}\u{c38}\
	\x0a\u{84}\x0c\u{84}\x0e\u{84}\u{c3b}\x0b\u{84}\x03\u{84}\x03\u{84}\x03\
	\u{85}\x03\u{85}\x07\u{85}\u{c41}\x0a\u{85}\x0c\u{85}\x0e\u{85}\u{c44}\x0b\
	\u{85}\x03\u{85}\x03\u{85}\x07\u{85}\u{c48}\x0a\u{85}\x0c\u{85}\x0e\u{85}\
	\u{c4b}\x0b\u{85}\x03\u{85}\x06\u{85}\u{c4e}\x0a\u{85}\x0d\u{85}\x0e\u{85}\
	\u{c4f}\x03\u{85}\x07\u{85}\u{c53}\x0a\u{85}\x0c\u{85}\x0e\u{85}\u{c56}\
	\x0b\u{85}\x03\u{85}\x05\u{85}\u{c59}\x0a\u{85}\x03\u{85}\x07\u{85}\u{c5c}\
	\x0a\u{85}\x0c\u{85}\x0e\u{85}\u{c5f}\x0b\u{85}\x03\u{85}\x05\u{85}\u{c62}\
	\x0a\u{85}\x03\u{86}\x03\u{86}\x07\u{86}\u{c66}\x0a\u{86}\x0c\u{86}\x0e\
	\u{86}\u{c69}\x0b\u{86}\x03\u{86}\x03\u{86}\x07\u{86}\u{c6d}\x0a\u{86}\x0c\
	\u{86}\x0e\u{86}\u{c70}\x0b\u{86}\x03\u{86}\x03\u{86}\x03\u{86}\x03\u{86}\
	\x07\u{86}\u{c76}\x0a\u{86}\x0c\u{86}\x0e\u{86}\u{c79}\x0b\u{86}\x03\u{86}\
	\x05\u{86}\u{c7c}\x0a\u{86}\x03\u{86}\x03\u{86}\x07\u{86}\u{c80}\x0a\u{86}\
	\x0c\u{86}\x0e\u{86}\u{c83}\x0b\u{86}\x03\u{86}\x03\u{86}\x03\u{87}\x03\
	\u{87}\x07\u{87}\u{c89}\x0a\u{87}\x0c\u{87}\x0e\u{87}\u{c8c}\x0b\u{87}\x03\
	\u{87}\x03\u{87}\x03\u{88}\x03\u{88}\x07\u{88}\u{c92}\x0a\u{88}\x0c\u{88}\
	\x0e\u{88}\u{c95}\x0b\u{88}\x03\u{88}\x03\u{88}\x03\u{88}\x05\u{88}\u{c9a}\
	\x0a\u{88}\x03\u{88}\x03\u{88}\x03\u{88}\x03\u{88}\x05\u{88}\u{ca0}\x0a\
	\u{88}\x03\u{89}\x05\u{89}\u{ca3}\x0a\u{89}\x03\u{89}\x03\u{89}\x07\u{89}\
	\u{ca7}\x0a\u{89}\x0c\u{89}\x0e\u{89}\u{caa}\x0b\u{89}\x03\u{89}\x03\u{89}\
	\x05\u{89}\u{cae}\x0a\u{89}\x03\u{8a}\x03\u{8a}\x03\u{8b}\x03\u{8b}\x03\
	\u{8c}\x03\u{8c}\x03\u{8d}\x03\u{8d}\x03\u{8e}\x03\u{8e}\x03\u{8f}\x03\u{8f}\
	\x03\u{90}\x03\u{90}\x03\u{91}\x03\u{91}\x03\u{92}\x03\u{92}\x03\u{92}\x03\
	\u{92}\x03\u{92}\x05\u{92}\u{cc5}\x0a\u{92}\x03\u{93}\x03\u{93}\x03\u{93}\
	\x03\u{93}\x05\u{93}\u{ccb}\x0a\u{93}\x03\u{94}\x03\u{94}\x03\u{95}\x07\
	\u{95}\u{cd0}\x0a\u{95}\x0c\u{95}\x0e\u{95}\u{cd3}\x0b\u{95}\x03\u{95}\x03\
	\u{95}\x07\u{95}\u{cd7}\x0a\u{95}\x0c\u{95}\x0e\u{95}\u{cda}\x0b\u{95}\x03\
	\u{95}\x03\u{95}\x05\u{95}\u{cde}\x0a\u{95}\x03\u{96}\x03\u{96}\x03\u{96}\
	\x03\u{97}\x03\u{97}\x06\u{97}\u{ce5}\x0a\u{97}\x0d\u{97}\x0e\u{97}\u{ce6}\
	\x03\u{98}\x03\u{98}\x06\u{98}\u{ceb}\x0a\u{98}\x0d\u{98}\x0e\u{98}\u{cec}\
	\x03\u{99}\x03\u{99}\x03\u{99}\x03\u{99}\x03\u{99}\x03\u{99}\x03\u{99}\x03\
	\u{99}\x05\u{99}\u{cf7}\x0a\u{99}\x03\u{99}\x07\u{99}\u{cfa}\x0a\u{99}\x0c\
	\u{99}\x0e\u{99}\u{cfd}\x0b\u{99}\x03\u{9a}\x06\u{9a}\u{d00}\x0a\u{9a}\x0d\
	\u{9a}\x0e\u{9a}\u{d01}\x03\u{9b}\x03\u{9b}\x03\u{9b}\x07\u{9b}\u{d07}\x0a\
	\u{9b}\x0c\u{9b}\x0e\u{9b}\u{d0a}\x0b\u{9b}\x05\u{9b}\u{d0c}\x0a\u{9b}\x03\
	\u{9c}\x03\u{9c}\x03\u{9d}\x03\u{9d}\x03\u{9e}\x03\u{9e}\x03\u{9f}\x03\u{9f}\
	\x03\u{a0}\x06\u{a0}\u{d17}\x0a\u{a0}\x0d\u{a0}\x0e\u{a0}\u{d18}\x03\u{a1}\
	\x03\u{a1}\x07\u{a1}\u{d1d}\x0a\u{a1}\x0c\u{a1}\x0e\u{a1}\u{d20}\x0b\u{a1}\
	\x03\u{a1}\x03\u{a1}\x07\u{a1}\u{d24}\x0a\u{a1}\x0c\u{a1}\x0e\u{a1}\u{d27}\
	\x0b\u{a1}\x03\u{a1}\x05\u{a1}\u{d2a}\x0a\u{a1}\x03\u{a2}\x03\u{a2}\x03\
	\u{a3}\x03\u{a3}\x03\u{a4}\x03\u{a4}\x03\u{a5}\x03\u{a5}\x03\u{a6}\x03\u{a6}\
	\x03\u{a7}\x03\u{a7}\x03\u{a8}\x03\u{a8}\x05\u{a8}\u{d3a}\x0a\u{a8}\x03\
	\u{a8}\x07\u{a8}\u{d3d}\x0a\u{a8}\x0c\u{a8}\x0e\u{a8}\u{d40}\x0b\u{a8}\x03\
	\u{a9}\x03\u{a9}\x07\u{a9}\u{d44}\x0a\u{a9}\x0c\u{a9}\x0e\u{a9}\u{d47}\x0b\
	\u{a9}\x03\u{a9}\x03\u{a9}\x05\u{a9}\u{d4b}\x0a\u{a9}\x03\u{a9}\x03\u{a9}\
	\x03\u{aa}\x03\u{aa}\x07\u{aa}\u{d51}\x0a\u{aa}\x0c\u{aa}\x0e\u{aa}\u{d54}\
	\x0b\u{aa}\x03\u{aa}\x03\u{aa}\x05\u{aa}\u{d58}\x0a\u{aa}\x03\u{aa}\x03\
	\u{aa}\x06\u{aa}\u{d5c}\x0a\u{aa}\x0d\u{aa}\x0e\u{aa}\u{d5d}\x03\u{aa}\x03\
	\u{aa}\x03\u{ab}\x03\u{ab}\x03\u{ab}\x07\u{ab}\u{d65}\x0a\u{ab}\x0c\u{ab}\
	\x0e\u{ab}\u{d68}\x0b\u{ab}\x03\u{ab}\x03\u{ab}\x03\u{ac}\x03\u{ac}\x05\
	\u{ac}\u{d6e}\x0a\u{ac}\x03\u{ad}\x03\u{ad}\x03\u{ae}\x03\u{ae}\x07\u{ae}\
	\u{d74}\x0a\u{ae}\x0c\u{ae}\x0e\u{ae}\u{d77}\x0b\u{ae}\x03\u{ae}\x03\u{ae}\
	\x07\u{ae}\u{d7b}\x0a\u{ae}\x0c\u{ae}\x0e\u{ae}\u{d7e}\x0b\u{ae}\x03\u{ae}\
	\x02\x02\u{af}\x02\x04\x06\x08\x0a\x0c\x0e\x10\x12\x14\x16\x18\x1a\x1c\x1e\
	\x20\x22\x24\x26\x28\x2a\x2c\x2e\x30\x32\x34\x36\x38\x3a\x3c\x3e\x40\x42\
	\x44\x46\x48\x4a\x4c\x4e\x50\x52\x54\x56\x58\x5a\x5c\x5e\x60\x62\x64\x66\
	\x68\x6a\x6c\x6e\x70\x72\x74\x76\x78\x7a\x7c\x7e\u{80}\u{82}\u{84}\u{86}\
	\u{88}\u{8a}\u{8c}\u{8e}\u{90}\u{92}\u{94}\u{96}\u{98}\u{9a}\u{9c}\u{9e}\
	\u{a0}\u{a2}\u{a4}\u{a6}\u{a8}\u{aa}\u{ac}\u{ae}\u{b0}\u{b2}\u{b4}\u{b6}\
	\u{b8}\u{ba}\u{bc}\u{be}\u{c0}\u{c2}\u{c4}\u{c6}\u{c8}\u{ca}\u{cc}\u{ce}\
	\u{d0}\u{d2}\u{d4}\u{d6}\u{d8}\u{da}\u{dc}\u{de}\u{e0}\u{e2}\u{e4}\u{e6}\
	\u{e8}\u{ea}\u{ec}\u{ee}\u{f0}\u{f2}\u{f4}\u{f6}\u{f8}\u{fa}\u{fc}\u{fe}\
	\u{100}\u{102}\u{104}\u{106}\u{108}\u{10a}\u{10c}\u{10e}\u{110}\u{112}\u{114}\
	\u{116}\u{118}\u{11a}\u{11c}\u{11e}\u{120}\u{122}\u{124}\u{126}\u{128}\u{12a}\
	\u{12c}\u{12e}\u{130}\u{132}\u{134}\u{136}\u{138}\u{13a}\u{13c}\u{13e}\u{140}\
	\u{142}\u{144}\u{146}\u{148}\u{14a}\u{14c}\u{14e}\u{150}\u{152}\u{154}\u{156}\
	\u{158}\u{15a}\x02\x20\x04\x02\x2a\x2a\x2c\x2c\x03\x02\x4e\x4f\x03\x02\x55\
	\x56\x03\x02\x2e\x2f\x03\x02\x2a\x2b\x04\x02\x07\x07\x1d\x1d\x04\x02\u{89}\
	\u{89}\u{8c}\u{93}\x03\x02\u{a1}\u{a3}\x03\x02\u{a6}\u{a8}\x04\x02\x3d\x3d\
	\x55\x55\x04\x02\x3a\x3a\x63\x63\x03\x02\x1f\x23\x04\x02\x34\x35\x37\x38\
	\x03\x02\x30\x33\x04\x02\x68\x68\x6a\x6a\x04\x02\x67\x67\x69\x69\x03\x02\
	\x14\x15\x03\x02\x11\x13\x04\x02\x36\x36\x66\x66\x03\x02\x1a\x1b\x03\x02\
	\x71\x76\x04\x02\x7d\x7d\u{82}\u{82}\x03\x02\x6d\x70\x04\x02\x68\x68\x6b\
	\x6b\x03\x02\x77\x7c\x03\x02\x7e\u{80}\x03\x02\u{83}\u{85}\x03\x02\u{87}\
	\u{88}\x03\x02\x40\x47\x09\x02\x3f\x47\x49\x49\x51\x54\x58\x58\x5d\x5e\x6b\
	\u{88}\u{94}\u{94}\x02\u{f1c}\x02\u{15d}\x03\x02\x02\x02\x04\u{176}\x03\
	\x02\x02\x02\x06\u{190}\x03\x02\x02\x02\x08\u{196}\x03\x02\x02\x02\x0a\u{1bb}\
	\x03\x02\x02\x02\x0c\u{1c0}\x03\x02\x02\x02\x0e\u{1c3}\x03\x02\x02\x02\x10\
	\u{1cd}\x03\x02\x02\x02\x12\u{1d0}\x03\x02\x02\x02\x14\u{1d5}\x03\x02\x02\
	\x02\x16\u{1fc}\x03\x02\x02\x02\x18\u{1ff}\x03\x02\x02\x02\x1a\u{25a}\x03\
	\x02\x02\x02\x1c\u{25e}\x03\x02\x02\x02\x1e\u{26e}\x03\x02\x02\x02\x20\u{29d}\
	\x03\x02\x02\x02\x22\u{2c1}\x03\x02\x02\x02\x24\u{2d9}\x03\x02\x02\x02\x26\
	\u{2db}\x03\x02\x02\x02\x28\u{2e1}\x03\x02\x02\x02\x2a\u{2ee}\x03\x02\x02\
	\x02\x2c\u{2ff}\x03\x02\x02\x02\x2e\u{32c}\x03\x02\x02\x02\x30\u{345}\x03\
	\x02\x02\x02\x32\u{363}\x03\x02\x02\x02\x34\u{37c}\x03\x02\x02\x02\x36\u{383}\
	\x03\x02\x02\x02\x38\u{385}\x03\x02\x02\x02\x3a\u{38f}\x03\x02\x02\x02\x3c\
	\u{3bb}\x03\x02\x02\x02\x3e\u{3ea}\x03\x02\x02\x02\x40\u{3fe}\x03\x02\x02\
	\x02\x42\u{454}\x03\x02\x02\x02\x44\u{459}\x03\x02\x02\x02\x46\u{473}\x03\
	\x02\x02\x02\x48\u{4a0}\x03\x02\x02\x02\x4a\u{511}\x03\x02\x02\x02\x4c\u{51b}\
	\x03\x02\x02\x02\x4e\u{546}\x03\x02\x02\x02\x50\u{581}\x03\x02\x02\x02\x52\
	\u{5b0}\x03\x02\x02\x02\x54\u{5c3}\x03\x02\x02\x02\x56\u{5d4}\x03\x02\x02\
	\x02\x58\u{5e5}\x03\x02\x02\x02\x5a\u{609}\x03\x02\x02\x02\x5c\u{62c}\x03\
	\x02\x02\x02\x5e\u{635}\x03\x02\x02\x02\x60\u{657}\x03\x02\x02\x02\x62\u{67b}\
	\x03\x02\x02\x02\x64\u{691}\x03\x02\x02\x02\x66\u{69b}\x03\x02\x02\x02\x68\
	\u{69f}\x03\x02\x02\x02\x6a\u{6ac}\x03\x02\x02\x02\x6c\u{6ae}\x03\x02\x02\
	\x02\x6e\u{6c2}\x03\x02\x02\x02\x70\u{6d1}\x03\x02\x02\x02\x72\u{6d4}\x03\
	\x02\x02\x02\x74\u{6e0}\x03\x02\x02\x02\x76\u{6f0}\x03\x02\x02\x02\x78\u{702}\
	\x03\x02\x02\x02\x7a\u{734}\x03\x02\x02\x02\x7c\u{745}\x03\x02\x02\x02\x7e\
	\u{74c}\x03\x02\x02\x02\u{80}\u{768}\x03\x02\x02\x02\u{82}\u{771}\x03\x02\
	\x02\x02\u{84}\u{77a}\x03\x02\x02\x02\u{86}\u{784}\x03\x02\x02\x02\u{88}\
	\u{786}\x03\x02\x02\x02\u{8a}\u{799}\x03\x02\x02\x02\u{8c}\u{79b}\x03\x02\
	\x02\x02\u{8e}\u{7b9}\x03\x02\x02\x02\u{90}\u{7cd}\x03\x02\x02\x02\u{92}\
	\u{7ee}\x03\x02\x02\x02\u{94}\u{800}\x03\x02\x02\x02\u{96}\u{808}\x03\x02\
	\x02\x02\u{98}\u{80a}\x03\x02\x02\x02\u{9a}\u{80c}\x03\x02\x02\x02\u{9c}\
	\u{820}\x03\x02\x02\x02\u{9e}\u{834}\x03\x02\x02\x02\u{a0}\u{843}\x03\x02\
	\x02\x02\u{a2}\u{852}\x03\x02\x02\x02\u{a4}\u{859}\x03\x02\x02\x02\u{a6}\
	\u{871}\x03\x02\x02\x02\u{a8}\u{886}\x03\x02\x02\x02\u{aa}\u{889}\x03\x02\
	\x02\x02\u{ac}\u{898}\x03\x02\x02\x02\u{ae}\u{8a6}\x03\x02\x02\x02\u{b0}\
	\u{8b5}\x03\x02\x02\x02\u{b2}\u{8c4}\x03\x02\x02\x02\u{b4}\u{8dc}\x03\x02\
	\x02\x02\u{b6}\u{8ea}\x03\x02\x02\x02\u{b8}\u{8ec}\x03\x02\x02\x02\u{ba}\
	\u{8f8}\x03\x02\x02\x02\u{bc}\u{8ff}\x03\x02\x02\x02\u{be}\u{901}\x03\x02\
	\x02\x02\u{c0}\u{913}\x03\x02\x02\x02\u{c2}\u{915}\x03\x02\x02\x02\u{c4}\
	\u{928}\x03\x02\x02\x02\u{c6}\u{92a}\x03\x02\x02\x02\u{c8}\u{956}\x03\x02\
	\x02\x02\u{ca}\u{963}\x03\x02\x02\x02\u{cc}\u{96f}\x03\x02\x02\x02\u{ce}\
	\u{97d}\x03\x02\x02\x02\u{d0}\u{9a9}\x03\x02\x02\x02\u{d2}\u{9d8}\x03\x02\
	\x02\x02\u{d4}\u{a09}\x03\x02\x02\x02\u{d6}\u{a0b}\x03\x02\x02\x02\u{d8}\
	\u{a1b}\x03\x02\x02\x02\u{da}\u{a49}\x03\x02\x02\x02\u{dc}\u{a4d}\x03\x02\
	\x02\x02\u{de}\u{a4f}\x03\x02\x02\x02\u{e0}\u{a59}\x03\x02\x02\x02\u{e2}\
	\u{a64}\x03\x02\x02\x02\u{e4}\u{a66}\x03\x02\x02\x02\u{e6}\u{a76}\x03\x02\
	\x02\x02\u{e8}\u{a78}\x03\x02\x02\x02\u{ea}\u{a88}\x03\x02\x02\x02\u{ec}\
	\u{aaa}\x03\x02\x02\x02\u{ee}\u{ad9}\x03\x02\x02\x02\u{f0}\u{adb}\x03\x02\
	\x02\x02\u{f2}\u{b18}\x03\x02\x02\x02\u{f4}\u{b1a}\x03\x02\x02\x02\u{f6}\
	\u{b3a}\x03\x02\x02\x02\u{f8}\u{b54}\x03\x02\x02\x02\u{fa}\u{b56}\x03\x02\
	\x02\x02\u{fc}\u{b93}\x03\x02\x02\x02\u{fe}\u{bba}\x03\x02\x02\x02\u{100}\
	\u{c25}\x03\x02\x02\x02\u{102}\u{c2a}\x03\x02\x02\x02\u{104}\u{c2c}\x03\
	\x02\x02\x02\u{106}\u{c35}\x03\x02\x02\x02\u{108}\u{c3e}\x03\x02\x02\x02\
	\u{10a}\u{c63}\x03\x02\x02\x02\u{10c}\u{c86}\x03\x02\x02\x02\u{10e}\u{c9f}\
	\x03\x02\x02\x02\u{110}\u{ca2}\x03\x02\x02\x02\u{112}\u{caf}\x03\x02\x02\
	\x02\u{114}\u{cb1}\x03\x02\x02\x02\u{116}\u{cb3}\x03\x02\x02\x02\u{118}\
	\u{cb5}\x03\x02\x02\x02\u{11a}\u{cb7}\x03\x02\x02\x02\u{11c}\u{cb9}\x03\
	\x02\x02\x02\u{11e}\u{cbb}\x03\x02\x02\x02\u{120}\u{cbd}\x03\x02\x02\x02\
	\u{122}\u{cc4}\x03\x02\x02\x02\u{124}\u{cca}\x03\x02\x02\x02\u{126}\u{ccc}\
	\x03\x02\x02\x02\u{128}\u{cdd}\x03\x02\x02\x02\u{12a}\u{cdf}\x03\x02\x02\
	\x02\u{12c}\u{ce4}\x03\x02\x02\x02\u{12e}\u{cea}\x03\x02\x02\x02\u{130}\
	\u{cf6}\x03\x02\x02\x02\u{132}\u{cff}\x03\x02\x02\x02\u{134}\u{d0b}\x03\
	\x02\x02\x02\u{136}\u{d0d}\x03\x02\x02\x02\u{138}\u{d0f}\x03\x02\x02\x02\
	\u{13a}\u{d11}\x03\x02\x02\x02\u{13c}\u{d13}\x03\x02\x02\x02\u{13e}\u{d16}\
	\x03\x02\x02\x02\u{140}\u{d29}\x03\x02\x02\x02\u{142}\u{d2b}\x03\x02\x02\
	\x02\u{144}\u{d2d}\x03\x02\x02\x02\u{146}\u{d2f}\x03\x02\x02\x02\u{148}\
	\u{d31}\x03\x02\x02\x02\u{14a}\u{d33}\x03\x02\x02\x02\u{14c}\u{d35}\x03\
	\x02\x02\x02\u{14e}\u{d39}\x03\x02\x02\x02\u{150}\u{d4a}\x03\x02\x02\x02\
	\u{152}\u{d57}\x03\x02\x02\x02\u{154}\u{d61}\x03\x02\x02\x02\u{156}\u{d6d}\
	\x03\x02\x02\x02\u{158}\u{d6f}\x03\x02\x02\x02\u{15a}\u{d71}\x03\x02\x02\
	\x02\u{15c}\u{15e}\x05\x06\x04\x02\u{15d}\u{15c}\x03\x02\x02\x02\u{15d}\
	\u{15e}\x03\x02\x02\x02\u{15e}\u{162}\x03\x02\x02\x02\u{15f}\u{161}\x07\
	\x07\x02\x02\u{160}\u{15f}\x03\x02\x02\x02\u{161}\u{164}\x03\x02\x02\x02\
	\u{162}\u{160}\x03\x02\x02\x02\u{162}\u{163}\x03\x02\x02\x02\u{163}\u{168}\
	\x03\x02\x02\x02\u{164}\u{162}\x03\x02\x02\x02\u{165}\u{167}\x05\x08\x05\
	\x02\u{166}\u{165}\x03\x02\x02\x02\u{167}\u{16a}\x03\x02\x02\x02\u{168}\
	\u{166}\x03\x02\x02\x02\u{168}\u{169}\x03\x02\x02\x02\u{169}\u{16b}\x03\
	\x02\x02\x02\u{16a}\u{168}\x03\x02\x02\x02\u{16b}\u{16c}\x05\x0a\x06\x02\
	\u{16c}\u{170}\x05\x0c\x07\x02\u{16d}\u{16f}\x05\x12\x0a\x02\u{16e}\u{16d}\
	\x03\x02\x02\x02\u{16f}\u{172}\x03\x02\x02\x02\u{170}\u{16e}\x03\x02\x02\
	\x02\u{170}\u{171}\x03\x02\x02\x02\u{171}\u{173}\x03\x02\x02\x02\u{172}\
	\u{170}\x03\x02\x02\x02\u{173}\u{174}\x07\x02\x02\x03\u{174}\x03\x03\x02\
	\x02\x02\u{175}\u{177}\x05\x06\x04\x02\u{176}\u{175}\x03\x02\x02\x02\u{176}\
	\u{177}\x03\x02\x02\x02\u{177}\u{17b}\x03\x02\x02\x02\u{178}\u{17a}\x07\
	\x07\x02\x02\u{179}\u{178}\x03\x02\x02\x02\u{17a}\u{17d}\x03\x02\x02\x02\
	\u{17b}\u{179}\x03\x02\x02\x02\u{17b}\u{17c}\x03\x02\x02\x02\u{17c}\u{181}\
	\x03\x02\x02\x02\u{17d}\u{17b}\x03\x02\x02\x02\u{17e}\u{180}\x05\x08\x05\
	\x02\u{17f}\u{17e}\x03\x02\x02\x02\u{180}\u{183}\x03\x02\x02\x02\u{181}\
	\u{17f}\x03\x02\x02\x02\u{181}\u{182}\x03\x02\x02\x02\u{182}\u{184}\x03\
	\x02\x02\x02\u{183}\u{181}\x03\x02\x02\x02\u{184}\u{185}\x05\x0a\x06\x02\
	\u{185}\u{18b}\x05\x0c\x07\x02\u{186}\u{187}\x05\u{82}\x42\x02\u{187}\u{188}\
	\x05\u{94}\x4b\x02\u{188}\u{18a}\x03\x02\x02\x02\u{189}\u{186}\x03\x02\x02\
	\x02\u{18a}\u{18d}\x03\x02\x02\x02\u{18b}\u{189}\x03\x02\x02\x02\u{18b}\
	\u{18c}\x03\x02\x02\x02\u{18c}\u{18e}\x03\x02\x02\x02\u{18d}\u{18b}\x03\
	\x02\x02\x02\u{18e}\u{18f}\x07\x02\x02\x03\u{18f}\x05\x03\x02\x02\x02\u{190}\
	\u{192}\x07\x03\x02\x02\u{191}\u{193}\x07\x07\x02\x02\u{192}\u{191}\x03\
	\x02\x02\x02\u{193}\u{194}\x03\x02\x02\x02\u{194}\u{192}\x03\x02\x02\x02\
	\u{194}\u{195}\x03\x02\x02\x02\u{195}\x07\x03\x02\x02\x02\u{196}\u{197}\
	\x09\x02\x02\x02\u{197}\u{19b}\x07\x3f\x02\x02\u{198}\u{19a}\x07\x07\x02\
	\x02\u{199}\u{198}\x03\x02\x02\x02\u{19a}\u{19d}\x03\x02\x02\x02\u{19b}\
	\u{199}\x03\x02\x02\x02\u{19b}\u{19c}\x03\x02\x02\x02\u{19c}\u{19e}\x03\
	\x02\x02\x02\u{19d}\u{19b}\x03\x02\x02\x02\u{19e}\u{1a2}\x07\x1c\x02\x02\
	\u{19f}\u{1a1}\x07\x07\x02\x02\u{1a0}\u{19f}\x03\x02\x02\x02\u{1a1}\u{1a4}\
	\x03\x02\x02\x02\u{1a2}\u{1a0}\x03\x02\x02\x02\u{1a2}\u{1a3}\x03\x02\x02\
	\x02\u{1a3}\u{1ae}\x03\x02\x02\x02\u{1a4}\u{1a2}\x03\x02\x02\x02\u{1a5}\
	\u{1a7}\x07\x0d\x02\x02\u{1a6}\u{1a8}\x05\u{156}\u{ac}\x02\u{1a7}\u{1a6}\
	\x03\x02\x02\x02\u{1a8}\u{1a9}\x03\x02\x02\x02\u{1a9}\u{1a7}\x03\x02\x02\
	\x02\u{1a9}\u{1aa}\x03\x02\x02\x02\u{1aa}\u{1ab}\x03\x02\x02\x02\u{1ab}\
	\u{1ac}\x07\x0e\x02\x02\u{1ac}\u{1af}\x03\x02\x02\x02\u{1ad}\u{1af}\x05\
	\u{156}\u{ac}\x02\u{1ae}\u{1a5}\x03\x02\x02\x02\u{1ae}\u{1ad}\x03\x02\x02\
	\x02\u{1af}\u{1b3}\x03\x02\x02\x02\u{1b0}\u{1b2}\x07\x07\x02\x02\u{1b1}\
	\u{1b0}\x03\x02\x02\x02\u{1b2}\u{1b5}\x03\x02\x02\x02\u{1b3}\u{1b1}\x03\
	\x02\x02\x02\u{1b3}\u{1b4}\x03\x02\x02\x02\u{1b4}\x09\x03\x02\x02\x02\u{1b5}\
	\u{1b3}\x03\x02\x02\x02\u{1b6}\u{1b7}\x07\x48\x02\x02\u{1b7}\u{1b9}\x05\
	\u{15a}\u{ae}\x02\u{1b8}\u{1ba}\x05\u{94}\x4b\x02\u{1b9}\u{1b8}\x03\x02\
	\x02\x02\u{1b9}\u{1ba}\x03\x02\x02\x02\u{1ba}\u{1bc}\x03\x02\x02\x02\u{1bb}\
	\u{1b6}\x03\x02\x02\x02\u{1bb}\u{1bc}\x03\x02\x02\x02\u{1bc}\x0b\x03\x02\
	\x02\x02\u{1bd}\u{1bf}\x05\x0e\x08\x02\u{1be}\u{1bd}\x03\x02\x02\x02\u{1bf}\
	\u{1c2}\x03\x02\x02\x02\u{1c0}\u{1be}\x03\x02\x02\x02\u{1c0}\u{1c1}\x03\
	\x02\x02\x02\u{1c1}\x0d\x03\x02\x02\x02\u{1c2}\u{1c0}\x03\x02\x02\x02\u{1c3}\
	\u{1c4}\x07\x49\x02\x02\u{1c4}\u{1c8}\x05\u{15a}\u{ae}\x02\u{1c5}\u{1c6}\
	\x07\x09\x02\x02\u{1c6}\u{1c9}\x07\x11\x02\x02\u{1c7}\u{1c9}\x05\x10\x09\
	\x02\u{1c8}\u{1c5}\x03\x02\x02\x02\u{1c8}\u{1c7}\x03\x02\x02\x02\u{1c8}\
	\u{1c9}\x03\x02\x02\x02\u{1c9}\u{1cb}\x03\x02\x02\x02\u{1ca}\u{1cc}\x05\
	\u{94}\x4b\x02\u{1cb}\u{1ca}\x03\x02\x02\x02\u{1cb}\u{1cc}\x03\x02\x02\x02\
	\u{1cc}\x0f\x03\x02\x02\x02\u{1cd}\u{1ce}\x07\x66\x02\x02\u{1ce}\u{1cf}\
	\x05\u{158}\u{ad}\x02\u{1cf}\x11\x03\x02\x02\x02\u{1d0}\u{1d2}\x05\x16\x0c\
	\x02\u{1d1}\u{1d3}\x05\u{96}\x4c\x02\u{1d2}\u{1d1}\x03\x02\x02\x02\u{1d2}\
	\u{1d3}\x03\x02\x02\x02\u{1d3}\x13\x03\x02\x02\x02\u{1d4}\u{1d6}\x05\u{12c}\
	\u{97}\x02\u{1d5}\u{1d4}\x03\x02\x02\x02\u{1d5}\u{1d6}\x03\x02\x02\x02\u{1d6}\
	\u{1d7}\x03\x02\x02\x02\u{1d7}\u{1db}\x07\x50\x02\x02\u{1d8}\u{1da}\x07\
	\x07\x02\x02\u{1d9}\u{1d8}\x03\x02\x02\x02\u{1da}\u{1dd}\x03\x02\x02\x02\
	\u{1db}\u{1d9}\x03\x02\x02\x02\u{1db}\u{1dc}\x03\x02\x02\x02\u{1dc}\u{1de}\
	\x03\x02\x02\x02\u{1dd}\u{1db}\x03\x02\x02\x02\u{1de}\u{1e6}\x05\u{158}\
	\u{ad}\x02\u{1df}\u{1e1}\x07\x07\x02\x02\u{1e0}\u{1df}\x03\x02\x02\x02\u{1e1}\
	\u{1e4}\x03\x02\x02\x02\u{1e2}\u{1e0}\x03\x02\x02\x02\u{1e2}\u{1e3}\x03\
	\x02\x02\x02\u{1e3}\u{1e5}\x03\x02\x02\x02\u{1e4}\u{1e2}\x03\x02\x02\x02\
	\u{1e5}\u{1e7}\x05\x2c\x17\x02\u{1e6}\u{1e2}\x03\x02\x02\x02\u{1e6}\u{1e7}\
	\x03\x02\x02\x02\u{1e7}\u{1eb}\x03\x02\x02\x02\u{1e8}\u{1ea}\x07\x07\x02\
	\x02\u{1e9}\u{1e8}\x03\x02\x02\x02\u{1ea}\u{1ed}\x03\x02\x02\x02\u{1eb}\
	\u{1e9}\x03\x02\x02\x02\u{1eb}\u{1ec}\x03\x02\x02\x02\u{1ec}\u{1ee}\x03\
	\x02\x02\x02\u{1ed}\u{1eb}\x03\x02\x02\x02\u{1ee}\u{1f2}\x07\x1e\x02\x02\
	\u{1ef}\u{1f1}\x07\x07\x02\x02\u{1f0}\u{1ef}\x03\x02\x02\x02\u{1f1}\u{1f4}\
	\x03\x02\x02\x02\u{1f2}\u{1f0}\x03\x02\x02\x02\u{1f2}\u{1f3}\x03\x02\x02\
	\x02\u{1f3}\u{1f5}\x03\x02\x02\x02\u{1f4}\u{1f2}\x03\x02\x02\x02\u{1f5}\
	\u{1f6}\x05\x64\x33\x02\u{1f6}\x15\x03\x02\x02\x02\u{1f7}\u{1fd}\x05\x18\
	\x0d\x02\u{1f8}\u{1fd}\x05\x58\x2d\x02\u{1f9}\u{1fd}\x05\x40\x21\x02\u{1fa}\
	\u{1fd}\x05\x48\x25\x02\u{1fb}\u{1fd}\x05\x14\x0b\x02\u{1fc}\u{1f7}\x03\
	\x02\x02\x02\u{1fc}\u{1f8}\x03\x02\x02\x02\u{1fc}\u{1f9}\x03\x02\x02\x02\
	\u{1fc}\u{1fa}\x03\x02\x02\x02\u{1fc}\u{1fb}\x03\x02\x02\x02\u{1fd}\x17\
	\x03\x02\x02\x02\u{1fe}\u{200}\x05\u{12c}\u{97}\x02\u{1ff}\u{1fe}\x03\x02\
	\x02\x02\u{1ff}\u{200}\x03\x02\x02\x02\u{200}\u{20c}\x03\x02\x02\x02\u{201}\
	\u{20d}\x07\x4a\x02\x02\u{202}\u{206}\x07\x4c\x02\x02\u{203}\u{205}\x07\
	\x07\x02\x02\u{204}\u{203}\x03\x02\x02\x02\u{205}\u{208}\x03\x02\x02\x02\
	\u{206}\u{204}\x03\x02\x02\x02\u{206}\u{207}\x03\x02\x02\x02\u{207}\u{20a}\
	\x03\x02\x02\x02\u{208}\u{206}\x03\x02\x02\x02\u{209}\u{202}\x03\x02\x02\
	\x02\u{209}\u{20a}\x03\x02\x02\x02\u{20a}\u{20b}\x03\x02\x02\x02\u{20b}\
	\u{20d}\x07\x4b\x02\x02\u{20c}\u{201}\x03\x02\x02\x02\u{20c}\u{209}\x03\
	\x02\x02\x02\u{20d}\u{211}\x03\x02\x02\x02\u{20e}\u{210}\x07\x07\x02\x02\
	\u{20f}\u{20e}\x03\x02\x02\x02\u{210}\u{213}\x03\x02\x02\x02\u{211}\u{20f}\
	\x03\x02\x02\x02\u{211}\u{212}\x03\x02\x02\x02\u{212}\u{214}\x03\x02\x02\
	\x02\u{213}\u{211}\x03\x02\x02\x02\u{214}\u{21c}\x05\u{158}\u{ad}\x02\u{215}\
	\u{217}\x07\x07\x02\x02\u{216}\u{215}\x03\x02\x02\x02\u{217}\u{21a}\x03\
	\x02\x02\x02\u{218}\u{216}\x03\x02\x02\x02\u{218}\u{219}\x03\x02\x02\x02\
	\u{219}\u{21b}\x03\x02\x02\x02\u{21a}\u{218}\x03\x02\x02\x02\u{21b}\u{21d}\
	\x05\x2c\x17\x02\u{21c}\u{218}\x03\x02\x02\x02\u{21c}\u{21d}\x03\x02\x02\
	\x02\u{21d}\u{225}\x03\x02\x02\x02\u{21e}\u{220}\x07\x07\x02\x02\u{21f}\
	\u{21e}\x03\x02\x02\x02\u{220}\u{223}\x03\x02\x02\x02\u{221}\u{21f}\x03\
	\x02\x02\x02\u{221}\u{222}\x03\x02\x02\x02\u{222}\u{224}\x03\x02\x02\x02\
	\u{223}\u{221}\x03\x02\x02\x02\u{224}\u{226}\x05\x1a\x0e\x02\u{225}\u{221}\
	\x03\x02\x02\x02\u{225}\u{226}\x03\x02\x02\x02\u{226}\u{235}\x03\x02\x02\
	\x02\u{227}\u{229}\x07\x07\x02\x02\u{228}\u{227}\x03\x02\x02\x02\u{229}\
	\u{22c}\x03\x02\x02\x02\u{22a}\u{228}\x03\x02\x02\x02\u{22a}\u{22b}\x03\
	\x02\x02\x02\u{22b}\u{22d}\x03\x02\x02\x02\u{22c}\u{22a}\x03\x02\x02\x02\
	\u{22d}\u{231}\x07\x1c\x02\x02\u{22e}\u{230}\x07\x07\x02\x02\u{22f}\u{22e}\
	\x03\x02\x02\x02\u{230}\u{233}\x03\x02\x02\x02\u{231}\u{22f}\x03\x02\x02\
	\x02\u{231}\u{232}\x03\x02\x02\x02\u{232}\u{234}\x03\x02\x02\x02\u{233}\
	\u{231}\x03\x02\x02\x02\u{234}\u{236}\x05\x22\x12\x02\u{235}\u{22a}\x03\
	\x02\x02\x02\u{235}\u{236}\x03\x02\x02\x02\u{236}\u{23e}\x03\x02\x02\x02\
	\u{237}\u{239}\x07\x07\x02\x02\u{238}\u{237}\x03\x02\x02\x02\u{239}\u{23c}\
	\x03\x02\x02\x02\u{23a}\u{238}\x03\x02\x02\x02\u{23a}\u{23b}\x03\x02\x02\
	\x02\u{23b}\u{23d}\x03\x02\x02\x02\u{23c}\u{23a}\x03\x02\x02\x02\u{23d}\
	\u{23f}\x05\x30\x19\x02\u{23e}\u{23a}\x03\x02\x02\x02\u{23e}\u{23f}\x03\
	\x02\x02\x02\u{23f}\u{24e}\x03\x02\x02\x02\u{240}\u{242}\x07\x07\x02\x02\
	\u{241}\u{240}\x03\x02\x02\x02\u{242}\u{245}\x03\x02\x02\x02\u{243}\u{241}\
	\x03\x02\x02\x02\u{243}\u{244}\x03\x02\x02\x02\u{244}\u{246}\x03\x02\x02\
	\x02\u{245}\u{243}\x03\x02\x02\x02\u{246}\u{24f}\x05\x1c\x0f\x02\u{247}\
	\u{249}\x07\x07\x02\x02\u{248}\u{247}\x03\x02\x02\x02\u{249}\u{24c}\x03\
	\x02\x02\x02\u{24a}\u{248}\x03\x02\x02\x02\u{24a}\u{24b}\x03\x02\x02\x02\
	\u{24b}\u{24d}\x03\x02\x02\x02\u{24c}\u{24a}\x03\x02\x02\x02\u{24d}\u{24f}\
	\x05\x5e\x30\x02\u{24e}\u{243}\x03\x02\x02\x02\u{24e}\u{24a}\x03\x02\x02\
	\x02\u{24e}\u{24f}\x03\x02\x02\x02\u{24f}\x19\x03\x02\x02\x02\u{250}\u{252}\
	\x05\u{12c}\u{97}\x02\u{251}\u{250}\x03\x02\x02\x02\u{251}\u{252}\x03\x02\
	\x02\x02\u{252}\u{253}\x03\x02\x02\x02\u{253}\u{257}\x07\x51\x02\x02\u{254}\
	\u{256}\x07\x07\x02\x02\u{255}\u{254}\x03\x02\x02\x02\u{256}\u{259}\x03\
	\x02\x02\x02\u{257}\u{255}\x03\x02\x02\x02\u{257}\u{258}\x03\x02\x02\x02\
	\u{258}\u{25b}\x03\x02\x02\x02\u{259}\u{257}\x03\x02\x02\x02\u{25a}\u{251}\
	\x03\x02\x02\x02\u{25a}\u{25b}\x03\x02\x02\x02\u{25b}\u{25c}\x03\x02\x02\
	\x02\u{25c}\u{25d}\x05\x1e\x10\x02\u{25d}\x1b\x03\x02\x02\x02\u{25e}\u{262}\
	\x07\x0f\x02\x02\u{25f}\u{261}\x07\x07\x02\x02\u{260}\u{25f}\x03\x02\x02\
	\x02\u{261}\u{264}\x03\x02\x02\x02\u{262}\u{260}\x03\x02\x02\x02\u{262}\
	\u{263}\x03\x02\x02\x02\u{263}\u{265}\x03\x02\x02\x02\u{264}\u{262}\x03\
	\x02\x02\x02\u{265}\u{269}\x05\x34\x1b\x02\u{266}\u{268}\x07\x07\x02\x02\
	\u{267}\u{266}\x03\x02\x02\x02\u{268}\u{26b}\x03\x02\x02\x02\u{269}\u{267}\
	\x03\x02\x02\x02\u{269}\u{26a}\x03\x02\x02\x02\u{26a}\u{26c}\x03\x02\x02\
	\x02\u{26b}\u{269}\x03\x02\x02\x02\u{26c}\u{26d}\x07\x10\x02\x02\u{26d}\
	\x1d\x03\x02\x02\x02\u{26e}\u{272}\x07\x0b\x02\x02\u{26f}\u{271}\x07\x07\
	\x02\x02\u{270}\u{26f}\x03\x02\x02\x02\u{271}\u{274}\x03\x02\x02\x02\u{272}\
	\u{270}\x03\x02\x02\x02\u{272}\u{273}\x03\x02\x02\x02\u{273}\u{292}\x03\
	\x02\x02\x02\u{274}\u{272}\x03\x02\x02\x02\u{275}\u{286}\x05\x20\x11\x02\
	\u{276}\u{278}\x07\x07\x02\x02\u{277}\u{276}\x03\x02\x02\x02\u{278}\u{27b}\
	\x03\x02\x02\x02\u{279}\u{277}\x03\x02\x02\x02\u{279}\u{27a}\x03\x02\x02\
	\x02\u{27a}\u{27c}\x03\x02\x02\x02\u{27b}\u{279}\x03\x02\x02\x02\u{27c}\
	\u{280}\x07\x0a\x02\x02\u{27d}\u{27f}\x07\x07\x02\x02\u{27e}\u{27d}\x03\
	\x02\x02\x02\u{27f}\u{282}\x03\x02\x02\x02\u{280}\u{27e}\x03\x02\x02\x02\
	\u{280}\u{281}\x03\x02\x02\x02\u{281}\u{283}\x03\x02\x02\x02\u{282}\u{280}\
	\x03\x02\x02\x02\u{283}\u{285}\x05\x20\x11\x02\u{284}\u{279}\x03\x02\x02\
	\x02\u{285}\u{288}\x03\x02\x02\x02\u{286}\u{284}\x03\x02\x02\x02\u{286}\
	\u{287}\x03\x02\x02\x02\u{287}\u{290}\x03\x02\x02\x02\u{288}\u{286}\x03\
	\x02\x02\x02\u{289}\u{28b}\x07\x07\x02\x02\u{28a}\u{289}\x03\x02\x02\x02\
	\u{28b}\u{28e}\x03\x02\x02\x02\u{28c}\u{28a}\x03\x02\x02\x02\u{28c}\u{28d}\
	\x03\x02\x02\x02\u{28d}\u{28f}\x03\x02\x02\x02\u{28e}\u{28c}\x03\x02\x02\
	\x02\u{28f}\u{291}\x07\x0a\x02\x02\u{290}\u{28c}\x03\x02\x02\x02\u{290}\
	\u{291}\x03\x02\x02\x02\u{291}\u{293}\x03\x02\x02\x02\u{292}\u{275}\x03\
	\x02\x02\x02\u{292}\u{293}\x03\x02\x02\x02\u{293}\u{297}\x03\x02\x02\x02\
	\u{294}\u{296}\x07\x07\x02\x02\u{295}\u{294}\x03\x02\x02\x02\u{296}\u{299}\
	\x03\x02\x02\x02\u{297}\u{295}\x03\x02\x02\x02\u{297}\u{298}\x03\x02\x02\
	\x02\u{298}\u{29a}\x03\x02\x02\x02\u{299}\u{297}\x03\x02\x02\x02\u{29a}\
	\u{29b}\x07\x0c\x02\x02\u{29b}\x1f\x03\x02\x02\x02\u{29c}\u{29e}\x05\u{12c}\
	\u{97}\x02\u{29d}\u{29c}\x03\x02\x02\x02\u{29d}\u{29e}\x03\x02\x02\x02\u{29e}\
	\u{2a0}\x03\x02\x02\x02\u{29f}\u{2a1}\x09\x03\x02\x02\u{2a0}\u{29f}\x03\
	\x02\x02\x02\u{2a0}\u{2a1}\x03\x02\x02\x02\u{2a1}\u{2a5}\x03\x02\x02\x02\
	\u{2a2}\u{2a4}\x07\x07\x02\x02\u{2a3}\u{2a2}\x03\x02\x02\x02\u{2a4}\u{2a7}\
	\x03\x02\x02\x02\u{2a5}\u{2a3}\x03\x02\x02\x02\u{2a5}\u{2a6}\x03\x02\x02\
	\x02\u{2a6}\u{2a8}\x03\x02\x02\x02\u{2a7}\u{2a5}\x03\x02\x02\x02\u{2a8}\
	\u{2a9}\x05\u{158}\u{ad}\x02\u{2a9}\u{2ad}\x07\x1c\x02\x02\u{2aa}\u{2ac}\
	\x07\x07\x02\x02\u{2ab}\u{2aa}\x03\x02\x02\x02\u{2ac}\u{2af}\x03\x02\x02\
	\x02\u{2ad}\u{2ab}\x03\x02\x02\x02\u{2ad}\u{2ae}\x03\x02\x02\x02\u{2ae}\
	\u{2b0}\x03\x02\x02\x02\u{2af}\u{2ad}\x03\x02\x02\x02\u{2b0}\u{2bf}\x05\
	\x64\x33\x02\u{2b1}\u{2b3}\x07\x07\x02\x02\u{2b2}\u{2b1}\x03\x02\x02\x02\
	\u{2b3}\u{2b6}\x03\x02\x02\x02\u{2b4}\u{2b2}\x03\x02\x02\x02\u{2b4}\u{2b5}\
	\x03\x02\x02\x02\u{2b5}\u{2b7}\x03\x02\x02\x02\u{2b6}\u{2b4}\x03\x02\x02\
	\x02\u{2b7}\u{2bb}\x07\x1e\x02\x02\u{2b8}\u{2ba}\x07\x07\x02\x02\u{2b9}\
	\u{2b8}\x03\x02\x02\x02\u{2ba}\u{2bd}\x03\x02\x02\x02\u{2bb}\u{2b9}\x03\
	\x02\x02\x02\u{2bb}\u{2bc}\x03\x02\x02\x02\u{2bc}\u{2be}\x03\x02\x02\x02\
	\u{2bd}\u{2bb}\x03\x02\x02\x02\u{2be}\u{2c0}\x05\u{98}\x4d\x02\u{2bf}\u{2b4}\
	\x03\x02\x02\x02\u{2bf}\u{2c0}\x03\x02\x02\x02\u{2c0}\x21\x03\x02\x02\x02\
	\u{2c1}\u{2d2}\x05\x28\x15\x02\u{2c2}\u{2c4}\x07\x07\x02\x02\u{2c3}\u{2c2}\
	\x03\x02\x02\x02\u{2c4}\u{2c7}\x03\x02\x02\x02\u{2c5}\u{2c3}\x03\x02\x02\
	\x02\u{2c5}\u{2c6}\x03\x02\x02\x02\u{2c6}\u{2c8}\x03\x02\x02\x02\u{2c7}\
	\u{2c5}\x03\x02\x02\x02\u{2c8}\u{2cc}\x07\x0a\x02\x02\u{2c9}\u{2cb}\x07\
	\x07\x02\x02\u{2ca}\u{2c9}\x03\x02\x02\x02\u{2cb}\u{2ce}\x03\x02\x02\x02\
	\u{2cc}\u{2ca}\x03\x02\x02\x02\u{2cc}\u{2cd}\x03\x02\x02\x02\u{2cd}\u{2cf}\
	\x03\x02\x02\x02\u{2ce}\u{2cc}\x03\x02\x02\x02\u{2cf}\u{2d1}\x05\x28\x15\
	\x02\u{2d0}\u{2c5}\x03\x02\x02\x02\u{2d1}\u{2d4}\x03\x02\x02\x02\u{2d2}\
	\u{2d0}\x03\x02\x02\x02\u{2d2}\u{2d3}\x03\x02\x02\x02\u{2d3}\x23\x03\x02\
	\x02\x02\u{2d4}\u{2d2}\x03\x02\x02\x02\u{2d5}\u{2da}\x05\x26\x14\x02\u{2d6}\
	\u{2da}\x05\x2a\x16\x02\u{2d7}\u{2da}\x05\x6c\x37\x02\u{2d8}\u{2da}\x05\
	\x76\x3c\x02\u{2d9}\u{2d5}\x03\x02\x02\x02\u{2d9}\u{2d6}\x03\x02\x02\x02\
	\u{2d9}\u{2d7}\x03\x02\x02\x02\u{2d9}\u{2d8}\x03\x02\x02\x02\u{2da}\x25\
	\x03\x02\x02\x02\u{2db}\u{2dc}\x05\x6c\x37\x02\u{2dc}\u{2dd}\x05\u{d0}\x69\
	\x02\u{2dd}\x27\x03\x02\x02\x02\u{2de}\u{2e0}\x05\u{14e}\u{a8}\x02\u{2df}\
	\u{2de}\x03\x02\x02\x02\u{2e0}\u{2e3}\x03\x02\x02\x02\u{2e1}\u{2df}\x03\
	\x02\x02\x02\u{2e1}\u{2e2}\x03\x02\x02\x02\u{2e2}\u{2e7}\x03\x02\x02\x02\
	\u{2e3}\u{2e1}\x03\x02\x02\x02\u{2e4}\u{2e6}\x07\x07\x02\x02\u{2e5}\u{2e4}\
	\x03\x02\x02\x02\u{2e6}\u{2e9}\x03\x02\x02\x02\u{2e7}\u{2e5}\x03\x02\x02\
	\x02\u{2e7}\u{2e8}\x03\x02\x02\x02\u{2e8}\u{2ea}\x03\x02\x02\x02\u{2e9}\
	\u{2e7}\x03\x02\x02\x02\u{2ea}\u{2eb}\x05\x24\x13\x02\u{2eb}\x29\x03\x02\
	\x02\x02\u{2ec}\u{2ef}\x05\x6c\x37\x02\u{2ed}\u{2ef}\x05\x76\x3c\x02\u{2ee}\
	\u{2ec}\x03\x02\x02\x02\u{2ee}\u{2ed}\x03\x02\x02\x02\u{2ef}\u{2f3}\x03\
	\x02\x02\x02\u{2f0}\u{2f2}\x07\x07\x02\x02\u{2f1}\u{2f0}\x03\x02\x02\x02\
	\u{2f2}\u{2f5}\x03\x02\x02\x02\u{2f3}\u{2f1}\x03\x02\x02\x02\u{2f3}\u{2f4}\
	\x03\x02\x02\x02\u{2f4}\u{2f6}\x03\x02\x02\x02\u{2f5}\u{2f3}\x03\x02\x02\
	\x02\u{2f6}\u{2fa}\x07\x52\x02\x02\u{2f7}\u{2f9}\x07\x07\x02\x02\u{2f8}\
	\u{2f7}\x03\x02\x02\x02\u{2f9}\u{2fc}\x03\x02\x02\x02\u{2fa}\u{2f8}\x03\
	\x02\x02\x02\u{2fa}\u{2fb}\x03\x02\x02\x02\u{2fb}\u{2fd}\x03\x02\x02\x02\
	\u{2fc}\u{2fa}\x03\x02\x02\x02\u{2fd}\u{2fe}\x05\u{98}\x4d\x02\u{2fe}\x2b\
	\x03\x02\x02\x02\u{2ff}\u{303}\x07\x30\x02\x02\u{300}\u{302}\x07\x07\x02\
	\x02\u{301}\u{300}\x03\x02\x02\x02\u{302}\u{305}\x03\x02\x02\x02\u{303}\
	\u{301}\x03\x02\x02\x02\u{303}\u{304}\x03\x02\x02\x02\u{304}\u{306}\x03\
	\x02\x02\x02\u{305}\u{303}\x03\x02\x02\x02\u{306}\u{317}\x05\x2e\x18\x02\
	\u{307}\u{309}\x07\x07\x02\x02\u{308}\u{307}\x03\x02\x02\x02\u{309}\u{30c}\
	\x03\x02\x02\x02\u{30a}\u{308}\x03\x02\x02\x02\u{30a}\u{30b}\x03\x02\x02\
	\x02\u{30b}\u{30d}\x03\x02\x02\x02\u{30c}\u{30a}\x03\x02\x02\x02\u{30d}\
	\u{311}\x07\x0a\x02\x02\u{30e}\u{310}\x07\x07\x02\x02\u{30f}\u{30e}\x03\
	\x02\x02\x02\u{310}\u{313}\x03\x02\x02\x02\u{311}\u{30f}\x03\x02\x02\x02\
	\u{311}\u{312}\x03\x02\x02\x02\u{312}\u{314}\x03\x02\x02\x02\u{313}\u{311}\
	\x03\x02\x02\x02\u{314}\u{316}\x05\x2e\x18\x02\u{315}\u{30a}\x03\x02\x02\
	\x02\u{316}\u{319}\x03\x02\x02\x02\u{317}\u{315}\x03\x02\x02\x02\u{317}\
	\u{318}\x03\x02\x02\x02\u{318}\u{321}\x03\x02\x02\x02\u{319}\u{317}\x03\
	\x02\x02\x02\u{31a}\u{31c}\x07\x07\x02\x02\u{31b}\u{31a}\x03\x02\x02\x02\
	\u{31c}\u{31f}\x03\x02\x02\x02\u{31d}\u{31b}\x03\x02\x02\x02\u{31d}\u{31e}\
	\x03\x02\x02\x02\u{31e}\u{320}\x03\x02\x02\x02\u{31f}\u{31d}\x03\x02\x02\
	\x02\u{320}\u{322}\x07\x0a\x02\x02\u{321}\u{31d}\x03\x02\x02\x02\u{321}\
	\u{322}\x03\x02\x02\x02\u{322}\u{326}\x03\x02\x02\x02\u{323}\u{325}\x07\
	\x07\x02\x02\u{324}\u{323}\x03\x02\x02\x02\u{325}\u{328}\x03\x02\x02\x02\
	\u{326}\u{324}\x03\x02\x02\x02\u{326}\u{327}\x03\x02\x02\x02\u{327}\u{329}\
	\x03\x02\x02\x02\u{328}\u{326}\x03\x02\x02\x02\u{329}\u{32a}\x07\x31\x02\
	\x02\u{32a}\x2d\x03\x02\x02\x02\u{32b}\u{32d}\x05\u{13e}\u{a0}\x02\u{32c}\
	\u{32b}\x03\x02\x02\x02\u{32c}\u{32d}\x03\x02\x02\x02\u{32d}\u{331}\x03\
	\x02\x02\x02\u{32e}\u{330}\x07\x07\x02\x02\u{32f}\u{32e}\x03\x02\x02\x02\
	\u{330}\u{333}\x03\x02\x02\x02\u{331}\u{32f}\x03\x02\x02\x02\u{331}\u{332}\
	\x03\x02\x02\x02\u{332}\u{334}\x03\x02\x02\x02\u{333}\u{331}\x03\x02\x02\
	\x02\u{334}\u{343}\x05\u{158}\u{ad}\x02\u{335}\u{337}\x07\x07\x02\x02\u{336}\
	\u{335}\x03\x02\x02\x02\u{337}\u{33a}\x03\x02\x02\x02\u{338}\u{336}\x03\
	\x02\x02\x02\u{338}\u{339}\x03\x02\x02\x02\u{339}\u{33b}\x03\x02\x02\x02\
	\u{33a}\u{338}\x03\x02\x02\x02\u{33b}\u{33f}\x07\x1c\x02\x02\u{33c}\u{33e}\
	\x07\x07\x02\x02\u{33d}\u{33c}\x03\x02\x02\x02\u{33e}\u{341}\x03\x02\x02\
	\x02\u{33f}\u{33d}\x03\x02\x02\x02\u{33f}\u{340}\x03\x02\x02\x02\u{340}\
	\u{342}\x03\x02\x02\x02\u{341}\u{33f}\x03\x02\x02\x02\u{342}\u{344}\x05\
	\x64\x33\x02\u{343}\u{338}\x03\x02\x02\x02\u{343}\u{344}\x03\x02\x02\x02\
	\u{344}\x2f\x03\x02\x02\x02\u{345}\u{349}\x07\x58\x02\x02\u{346}\u{348}\
	\x07\x07\x02\x02\u{347}\u{346}\x03\x02\x02\x02\u{348}\u{34b}\x03\x02\x02\
	\x02\u{349}\u{347}\x03\x02\x02\x02\u{349}\u{34a}\x03\x02\x02\x02\u{34a}\
	\u{34c}\x03\x02\x02\x02\u{34b}\u{349}\x03\x02\x02\x02\u{34c}\u{35d}\x05\
	\x32\x1a\x02\u{34d}\u{34f}\x07\x07\x02\x02\u{34e}\u{34d}\x03\x02\x02\x02\
	\u{34f}\u{352}\x03\x02\x02\x02\u{350}\u{34e}\x03\x02\x02\x02\u{350}\u{351}\
	\x03\x02\x02\x02\u{351}\u{353}\x03\x02\x02\x02\u{352}\u{350}\x03\x02\x02\
	\x02\u{353}\u{357}\x07\x0a\x02\x02\u{354}\u{356}\x07\x07\x02\x02\u{355}\
	\u{354}\x03\x02\x02\x02\u{356}\u{359}\x03\x02\x02\x02\u{357}\u{355}\x03\
	\x02\x02\x02\u{357}\u{358}\x03\x02\x02\x02\u{358}\u{35a}\x03\x02\x02\x02\
	\u{359}\u{357}\x03\x02\x02\x02\u{35a}\u{35c}\x05\x32\x1a\x02\u{35b}\u{350}\
	\x03\x02\x02\x02\u{35c}\u{35f}\x03\x02\x02\x02\u{35d}\u{35b}\x03\x02\x02\
	\x02\u{35d}\u{35e}\x03\x02\x02\x02\u{35e}\x31\x03\x02\x02\x02\u{35f}\u{35d}\
	\x03\x02\x02\x02\u{360}\u{362}\x05\u{14e}\u{a8}\x02\u{361}\u{360}\x03\x02\
	\x02\x02\u{362}\u{365}\x03\x02\x02\x02\u{363}\u{361}\x03\x02\x02\x02\u{363}\
	\u{364}\x03\x02\x02\x02\u{364}\u{366}\x03\x02\x02\x02\u{365}\u{363}\x03\
	\x02\x02\x02\u{366}\u{36a}\x05\u{158}\u{ad}\x02\u{367}\u{369}\x07\x07\x02\
	\x02\u{368}\u{367}\x03\x02\x02\x02\u{369}\u{36c}\x03\x02\x02\x02\u{36a}\
	\u{368}\x03\x02\x02\x02\u{36a}\u{36b}\x03\x02\x02\x02\u{36b}\u{36d}\x03\
	\x02\x02\x02\u{36c}\u{36a}\x03\x02\x02\x02\u{36d}\u{371}\x07\x1c\x02\x02\
	\u{36e}\u{370}\x07\x07\x02\x02\u{36f}\u{36e}\x03\x02\x02\x02\u{370}\u{373}\
	\x03\x02\x02\x02\u{371}\u{36f}\x03\x02\x02\x02\u{371}\u{372}\x03\x02\x02\
	\x02\u{372}\u{374}\x03\x02\x02\x02\u{373}\u{371}\x03\x02\x02\x02\u{374}\
	\u{375}\x05\x64\x33\x02\u{375}\x33\x03\x02\x02\x02\u{376}\u{378}\x05\x36\
	\x1c\x02\u{377}\u{379}\x05\u{96}\x4c\x02\u{378}\u{377}\x03\x02\x02\x02\u{378}\
	\u{379}\x03\x02\x02\x02\u{379}\u{37b}\x03\x02\x02\x02\u{37a}\u{376}\x03\
	\x02\x02\x02\u{37b}\u{37e}\x03\x02\x02\x02\u{37c}\u{37a}\x03\x02\x02\x02\
	\u{37c}\u{37d}\x03\x02\x02\x02\u{37d}\x35\x03\x02\x02\x02\u{37e}\u{37c}\
	\x03\x02\x02\x02\u{37f}\u{384}\x05\x16\x0c\x02\u{380}\u{384}\x05\x3a\x1e\
	\x02\u{381}\u{384}\x05\x38\x1d\x02\u{382}\u{384}\x05\x5a\x2e\x02\u{383}\
	\u{37f}\x03\x02\x02\x02\u{383}\u{380}\x03\x02\x02\x02\u{383}\u{381}\x03\
	\x02\x02\x02\u{383}\u{382}\x03\x02\x02\x02\u{384}\x37\x03\x02\x02\x02\u{385}\
	\u{389}\x07\x54\x02\x02\u{386}\u{388}\x07\x07\x02\x02\u{387}\u{386}\x03\
	\x02\x02\x02\u{388}\u{38b}\x03\x02\x02\x02\u{389}\u{387}\x03\x02\x02\x02\
	\u{389}\u{38a}\x03\x02\x02\x02\u{38a}\u{38c}\x03\x02\x02\x02\u{38b}\u{389}\
	\x03\x02\x02\x02\u{38c}\u{38d}\x05\u{88}\x45\x02\u{38d}\x39\x03\x02\x02\
	\x02\u{38e}\u{390}\x05\u{12c}\u{97}\x02\u{38f}\u{38e}\x03\x02\x02\x02\u{38f}\
	\u{390}\x03\x02\x02\x02\u{390}\u{391}\x03\x02\x02\x02\u{391}\u{395}\x07\
	\x53\x02\x02\u{392}\u{394}\x07\x07\x02\x02\u{393}\u{392}\x03\x02\x02\x02\
	\u{394}\u{397}\x03\x02\x02\x02\u{395}\u{393}\x03\x02\x02\x02\u{395}\u{396}\
	\x03\x02\x02\x02\u{396}\u{398}\x03\x02\x02\x02\u{397}\u{395}\x03\x02\x02\
	\x02\u{398}\u{3a0}\x07\x4d\x02\x02\u{399}\u{39b}\x07\x07\x02\x02\u{39a}\
	\u{399}\x03\x02\x02\x02\u{39b}\u{39e}\x03\x02\x02\x02\u{39c}\u{39a}\x03\
	\x02\x02\x02\u{39c}\u{39d}\x03\x02\x02\x02\u{39d}\u{39f}\x03\x02\x02\x02\
	\u{39e}\u{39c}\x03\x02\x02\x02\u{39f}\u{3a1}\x05\u{158}\u{ad}\x02\u{3a0}\
	\u{39c}\x03\x02\x02\x02\u{3a0}\u{3a1}\x03\x02\x02\x02\u{3a1}\u{3b0}\x03\
	\x02\x02\x02\u{3a2}\u{3a4}\x07\x07\x02\x02\u{3a3}\u{3a2}\x03\x02\x02\x02\
	\u{3a4}\u{3a7}\x03\x02\x02\x02\u{3a5}\u{3a3}\x03\x02\x02\x02\u{3a5}\u{3a6}\
	\x03\x02\x02\x02\u{3a6}\u{3a8}\x03\x02\x02\x02\u{3a7}\u{3a5}\x03\x02\x02\
	\x02\u{3a8}\u{3ac}\x07\x1c\x02\x02\u{3a9}\u{3ab}\x07\x07\x02\x02\u{3aa}\
	\u{3a9}\x03\x02\x02\x02\u{3ab}\u{3ae}\x03\x02\x02\x02\u{3ac}\u{3aa}\x03\
	\x02\x02\x02\u{3ac}\u{3ad}\x03\x02\x02\x02\u{3ad}\u{3af}\x03\x02\x02\x02\
	\u{3ae}\u{3ac}\x03\x02\x02\x02\u{3af}\u{3b1}\x05\x22\x12\x02\u{3b0}\u{3a5}\
	\x03\x02\x02\x02\u{3b0}\u{3b1}\x03\x02\x02\x02\u{3b1}\u{3b9}\x03\x02\x02\
	\x02\u{3b2}\u{3b4}\x07\x07\x02\x02\u{3b3}\u{3b2}\x03\x02\x02\x02\u{3b4}\
	\u{3b7}\x03\x02\x02\x02\u{3b5}\u{3b3}\x03\x02\x02\x02\u{3b5}\u{3b6}\x03\
	\x02\x02\x02\u{3b6}\u{3b8}\x03\x02\x02\x02\u{3b7}\u{3b5}\x03\x02\x02\x02\
	\u{3b8}\u{3ba}\x05\x1c\x0f\x02\u{3b9}\u{3b5}\x03\x02\x02\x02\u{3b9}\u{3ba}\
	\x03\x02\x02\x02\u{3ba}\x3b\x03\x02\x02\x02\u{3bb}\u{3bf}\x07\x0b\x02\x02\
	\u{3bc}\u{3be}\x07\x07\x02\x02\u{3bd}\u{3bc}\x03\x02\x02\x02\u{3be}\u{3c1}\
	\x03\x02\x02\x02\u{3bf}\u{3bd}\x03\x02\x02\x02\u{3bf}\u{3c0}\x03\x02\x02\
	\x02\u{3c0}\u{3df}\x03\x02\x02\x02\u{3c1}\u{3bf}\x03\x02\x02\x02\u{3c2}\
	\u{3d3}\x05\x3e\x20\x02\u{3c3}\u{3c5}\x07\x07\x02\x02\u{3c4}\u{3c3}\x03\
	\x02\x02\x02\u{3c5}\u{3c8}\x03\x02\x02\x02\u{3c6}\u{3c4}\x03\x02\x02\x02\
	\u{3c6}\u{3c7}\x03\x02\x02\x02\u{3c7}\u{3c9}\x03\x02\x02\x02\u{3c8}\u{3c6}\
	\x03\x02\x02\x02\u{3c9}\u{3cd}\x07\x0a\x02\x02\u{3ca}\u{3cc}\x07\x07\x02\
	\x02\u{3cb}\u{3ca}\x03\x02\x02\x02\u{3cc}\u{3cf}\x03\x02\x02\x02\u{3cd}\
	\u{3cb}\x03\x02\x02\x02\u{3cd}\u{3ce}\x03\x02\x02\x02\u{3ce}\u{3d0}\x03\
	\x02\x02\x02\u{3cf}\u{3cd}\x03\x02\x02\x02\u{3d0}\u{3d2}\x05\x3e\x20\x02\
	\u{3d1}\u{3c6}\x03\x02\x02\x02\u{3d2}\u{3d5}\x03\x02\x02\x02\u{3d3}\u{3d1}\
	\x03\x02\x02\x02\u{3d3}\u{3d4}\x03\x02\x02\x02\u{3d4}\u{3dd}\x03\x02\x02\
	\x02\u{3d5}\u{3d3}\x03\x02\x02\x02\u{3d6}\u{3d8}\x07\x07\x02\x02\u{3d7}\
	\u{3d6}\x03\x02\x02\x02\u{3d8}\u{3db}\x03\x02\x02\x02\u{3d9}\u{3d7}\x03\
	\x02\x02\x02\u{3d9}\u{3da}\x03\x02\x02\x02\u{3da}\u{3dc}\x03\x02\x02\x02\
	\u{3db}\u{3d9}\x03\x02\x02\x02\u{3dc}\u{3de}\x07\x0a\x02\x02\u{3dd}\u{3d9}\
	\x03\x02\x02\x02\u{3dd}\u{3de}\x03\x02\x02\x02\u{3de}\u{3e0}\x03\x02\x02\
	\x02\u{3df}\u{3c2}\x03\x02\x02\x02\u{3df}\u{3e0}\x03\x02\x02\x02\u{3e0}\
	\u{3e4}\x03\x02\x02\x02\u{3e1}\u{3e3}\x07\x07\x02\x02\u{3e2}\u{3e1}\x03\
	\x02\x02\x02\u{3e3}\u{3e6}\x03\x02\x02\x02\u{3e4}\u{3e2}\x03\x02\x02\x02\
	\u{3e4}\u{3e5}\x03\x02\x02\x02\u{3e5}\u{3e7}\x03\x02\x02\x02\u{3e6}\u{3e4}\
	\x03\x02\x02\x02\u{3e7}\u{3e8}\x07\x0c\x02\x02\u{3e8}\x3d\x03\x02\x02\x02\
	\u{3e9}\u{3eb}\x05\u{12e}\u{98}\x02\u{3ea}\u{3e9}\x03\x02\x02\x02\u{3ea}\
	\u{3eb}\x03\x02\x02\x02\u{3eb}\u{3ec}\x03\x02\x02\x02\u{3ec}\u{3fb}\x05\
	\x56\x2c\x02\u{3ed}\u{3ef}\x07\x07\x02\x02\u{3ee}\u{3ed}\x03\x02\x02\x02\
	\u{3ef}\u{3f2}\x03\x02\x02\x02\u{3f0}\u{3ee}\x03\x02\x02\x02\u{3f0}\u{3f1}\
	\x03\x02\x02\x02\u{3f1}\u{3f3}\x03\x02\x02\x02\u{3f2}\u{3f0}\x03\x02\x02\
	\x02\u{3f3}\u{3f7}\x07\x1e\x02\x02\u{3f4}\u{3f6}\x07\x07\x02\x02\u{3f5}\
	\u{3f4}\x03\x02\x02\x02\u{3f6}\u{3f9}\x03\x02\x02\x02\u{3f7}\u{3f5}\x03\
	\x02\x02\x02\u{3f7}\u{3f8}\x03\x02\x02\x02\u{3f8}\u{3fa}\x03\x02\x02\x02\
	\u{3f9}\u{3f7}\x03\x02\x02\x02\u{3fa}\u{3fc}\x05\u{98}\x4d\x02\u{3fb}\u{3f0}\
	\x03\x02\x02\x02\u{3fb}\u{3fc}\x03\x02\x02\x02\u{3fc}\x3f\x03\x02\x02\x02\
	\u{3fd}\u{3ff}\x05\u{12c}\u{97}\x02\u{3fe}\u{3fd}\x03\x02\x02\x02\u{3fe}\
	\u{3ff}\x03\x02\x02\x02\u{3ff}\u{400}\x03\x02\x02\x02\u{400}\u{408}\x07\
	\x4c\x02\x02\u{401}\u{403}\x07\x07\x02\x02\u{402}\u{401}\x03\x02\x02\x02\
	\u{403}\u{406}\x03\x02\x02\x02\u{404}\u{402}\x03\x02\x02\x02\u{404}\u{405}\
	\x03\x02\x02\x02\u{405}\u{407}\x03\x02\x02\x02\u{406}\u{404}\x03\x02\x02\
	\x02\u{407}\u{409}\x05\x2c\x17\x02\u{408}\u{404}\x03\x02\x02\x02\u{408}\
	\u{409}\x03\x02\x02\x02\u{409}\u{419}\x03\x02\x02\x02\u{40a}\u{40c}\x07\
	\x07\x02\x02\u{40b}\u{40a}\x03\x02\x02\x02\u{40c}\u{40f}\x03\x02\x02\x02\
	\u{40d}\u{40b}\x03\x02\x02\x02\u{40d}\u{40e}\x03\x02\x02\x02\u{40e}\u{410}\
	\x03\x02\x02\x02\u{40f}\u{40d}\x03\x02\x02\x02\u{410}\u{414}\x05\x7c\x3f\
	\x02\u{411}\u{413}\x07\x07\x02\x02\u{412}\u{411}\x03\x02\x02\x02\u{413}\
	\u{416}\x03\x02\x02\x02\u{414}\u{412}\x03\x02\x02\x02\u{414}\u{415}\x03\
	\x02\x02\x02\u{415}\u{417}\x03\x02\x02\x02\u{416}\u{414}\x03\x02\x02\x02\
	\u{417}\u{418}\x07\x09\x02\x02\u{418}\u{41a}\x03\x02\x02\x02\u{419}\u{40d}\
	\x03\x02\x02\x02\u{419}\u{41a}\x03\x02\x02\x02\u{41a}\u{41e}\x03\x02\x02\
	\x02\u{41b}\u{41d}\x07\x07\x02\x02\u{41c}\u{41b}\x03\x02\x02\x02\u{41d}\
	\u{420}\x03\x02\x02\x02\u{41e}\u{41c}\x03\x02\x02\x02\u{41e}\u{41f}\x03\
	\x02\x02\x02\u{41f}\u{421}\x03\x02\x02\x02\u{420}\u{41e}\x03\x02\x02\x02\
	\u{421}\u{425}\x05\u{158}\u{ad}\x02\u{422}\u{424}\x07\x07\x02\x02\u{423}\
	\u{422}\x03\x02\x02\x02\u{424}\u{427}\x03\x02\x02\x02\u{425}\u{423}\x03\
	\x02\x02\x02\u{425}\u{426}\x03\x02\x02\x02\u{426}\u{428}\x03\x02\x02\x02\
	\u{427}\u{425}\x03\x02\x02\x02\u{428}\u{437}\x05\x3c\x1f\x02\u{429}\u{42b}\
	\x07\x07\x02\x02\u{42a}\u{429}\x03\x02\x02\x02\u{42b}\u{42e}\x03\x02\x02\
	\x02\u{42c}\u{42a}\x03\x02\x02\x02\u{42c}\u{42d}\x03\x02\x02\x02\u{42d}\
	\u{42f}\x03\x02\x02\x02\u{42e}\u{42c}\x03\x02\x02\x02\u{42f}\u{433}\x07\
	\x1c\x02\x02\u{430}\u{432}\x07\x07\x02\x02\u{431}\u{430}\x03\x02\x02\x02\
	\u{432}\u{435}\x03\x02\x02\x02\u{433}\u{431}\x03\x02\x02\x02\u{433}\u{434}\
	\x03\x02\x02\x02\u{434}\u{436}\x03\x02\x02\x02\u{435}\u{433}\x03\x02\x02\
	\x02\u{436}\u{438}\x05\x64\x33\x02\u{437}\u{42c}\x03\x02\x02\x02\u{437}\
	\u{438}\x03\x02\x02\x02\u{438}\u{440}\x03\x02\x02\x02\u{439}\u{43b}\x07\
	\x07\x02\x02\u{43a}\u{439}\x03\x02\x02\x02\u{43b}\u{43e}\x03\x02\x02\x02\
	\u{43c}\u{43a}\x03\x02\x02\x02\u{43c}\u{43d}\x03\x02\x02\x02\u{43d}\u{43f}\
	\x03\x02\x02\x02\u{43e}\u{43c}\x03\x02\x02\x02\u{43f}\u{441}\x05\x30\x19\
	\x02\u{440}\u{43c}\x03\x02\x02\x02\u{440}\u{441}\x03\x02\x02\x02\u{441}\
	\u{449}\x03\x02\x02\x02\u{442}\u{444}\x07\x07\x02\x02\u{443}\u{442}\x03\
	\x02\x02\x02\u{444}\u{447}\x03\x02\x02\x02\u{445}\u{443}\x03\x02\x02\x02\
	\u{445}\u{446}\x03\x02\x02\x02\u{446}\u{448}\x03\x02\x02\x02\u{447}\u{445}\
	\x03\x02\x02\x02\u{448}\u{44a}\x05\x42\x22\x02\u{449}\u{445}\x03\x02\x02\
	\x02\u{449}\u{44a}\x03\x02\x02\x02\u{44a}\x41\x03\x02\x02\x02\u{44b}\u{455}\
	\x05\u{88}\x45\x02\u{44c}\u{450}\x07\x1e\x02\x02\u{44d}\u{44f}\x07\x07\x02\
	\x02\u{44e}\u{44d}\x03\x02\x02\x02\u{44f}\u{452}\x03\x02\x02\x02\u{450}\
	\u{44e}\x03\x02\x02\x02\u{450}\u{451}\x03\x02\x02\x02\u{451}\u{453}\x03\
	\x02\x02\x02\u{452}\u{450}\x03\x02\x02\x02\u{453}\u{455}\x05\u{98}\x4d\x02\
	\u{454}\u{44b}\x03\x02\x02\x02\u{454}\u{44c}\x03\x02\x02\x02\u{455}\x43\
	\x03\x02\x02\x02\u{456}\u{458}\x05\u{14e}\u{a8}\x02\u{457}\u{456}\x03\x02\
	\x02\x02\u{458}\u{45b}\x03\x02\x02\x02\u{459}\u{457}\x03\x02\x02\x02\u{459}\
	\u{45a}\x03\x02\x02\x02\u{45a}\u{45f}\x03\x02\x02\x02\u{45b}\u{459}\x03\
	\x02\x02\x02\u{45c}\u{45e}\x07\x07\x02\x02\u{45d}\u{45c}\x03\x02\x02\x02\
	\u{45e}\u{461}\x03\x02\x02\x02\u{45f}\u{45d}\x03\x02\x02\x02\u{45f}\u{460}\
	\x03\x02\x02\x02\u{460}\u{462}\x03\x02\x02\x02\u{461}\u{45f}\x03\x02\x02\
	\x02\u{462}\u{471}\x05\u{158}\u{ad}\x02\u{463}\u{465}\x07\x07\x02\x02\u{464}\
	\u{463}\x03\x02\x02\x02\u{465}\u{468}\x03\x02\x02\x02\u{466}\u{464}\x03\
	\x02\x02\x02\u{466}\u{467}\x03\x02\x02\x02\u{467}\u{469}\x03\x02\x02\x02\
	\u{468}\u{466}\x03\x02\x02\x02\u{469}\u{46d}\x07\x1c\x02\x02\u{46a}\u{46c}\
	\x07\x07\x02\x02\u{46b}\u{46a}\x03\x02\x02\x02\u{46c}\u{46f}\x03\x02\x02\
	\x02\u{46d}\u{46b}\x03\x02\x02\x02\u{46d}\u{46e}\x03\x02\x02\x02\u{46e}\
	\u{470}\x03\x02\x02\x02\u{46f}\u{46d}\x03\x02\x02\x02\u{470}\u{472}\x05\
	\x64\x33\x02\u{471}\u{466}\x03\x02\x02\x02\u{471}\u{472}\x03\x02\x02\x02\
	\u{472}\x45\x03\x02\x02\x02\u{473}\u{477}\x07\x0b\x02\x02\u{474}\u{476}\
	\x07\x07\x02\x02\u{475}\u{474}\x03\x02\x02\x02\u{476}\u{479}\x03\x02\x02\
	\x02\u{477}\u{475}\x03\x02\x02\x02\u{477}\u{478}\x03\x02\x02\x02\u{478}\
	\u{47a}\x03\x02\x02\x02\u{479}\u{477}\x03\x02\x02\x02\u{47a}\u{48b}\x05\
	\x44\x23\x02\u{47b}\u{47d}\x07\x07\x02\x02\u{47c}\u{47b}\x03\x02\x02\x02\
	\u{47d}\u{480}\x03\x02\x02\x02\u{47e}\u{47c}\x03\x02\x02\x02\u{47e}\u{47f}\
	\x03\x02\x02\x02\u{47f}\u{481}\x03\x02\x02\x02\u{480}\u{47e}\x03\x02\x02\
	\x02\u{481}\u{485}\x07\x0a\x02\x02\u{482}\u{484}\x07\x07\x02\x02\u{483}\
	\u{482}\x03\x02\x02\x02\u{484}\u{487}\x03\x02\x02\x02\u{485}\u{483}\x03\
	\x02\x02\x02\u{485}\u{486}\x03\x02\x02\x02\u{486}\u{488}\x03\x02\x02\x02\
	\u{487}\u{485}\x03\x02\x02\x02\u{488}\u{48a}\x05\x44\x23\x02\u{489}\u{47e}\
	\x03\x02\x02\x02\u{48a}\u{48d}\x03\x02\x02\x02\u{48b}\u{489}\x03\x02\x02\
	\x02\u{48b}\u{48c}\x03\x02\x02\x02\u{48c}\u{495}\x03\x02\x02\x02\u{48d}\
	\u{48b}\x03\x02\x02\x02\u{48e}\u{490}\x07\x07\x02\x02\u{48f}\u{48e}\x03\
	\x02\x02\x02\u{490}\u{493}\x03\x02\x02\x02\u{491}\u{48f}\x03\x02\x02\x02\
	\u{491}\u{492}\x03\x02\x02\x02\u{492}\u{494}\x03\x02\x02\x02\u{493}\u{491}\
	\x03\x02\x02\x02\u{494}\u{496}\x07\x0a\x02\x02\u{495}\u{491}\x03\x02\x02\
	\x02\u{495}\u{496}\x03\x02\x02\x02\u{496}\u{49a}\x03\x02\x02\x02\u{497}\
	\u{499}\x07\x07\x02\x02\u{498}\u{497}\x03\x02\x02\x02\u{499}\u{49c}\x03\
	\x02\x02\x02\u{49a}\u{498}\x03\x02\x02\x02\u{49a}\u{49b}\x03\x02\x02\x02\
	\u{49b}\u{49d}\x03\x02\x02\x02\u{49c}\u{49a}\x03\x02\x02\x02\u{49d}\u{49e}\
	\x07\x0c\x02\x02\u{49e}\x47\x03\x02\x02\x02\u{49f}\u{4a1}\x05\u{12c}\u{97}\
	\x02\u{4a0}\u{49f}\x03\x02\x02\x02\u{4a0}\u{4a1}\x03\x02\x02\x02\u{4a1}\
	\u{4a2}\x03\x02\x02\x02\u{4a2}\u{4aa}\x09\x03\x02\x02\u{4a3}\u{4a5}\x07\
	\x07\x02\x02\u{4a4}\u{4a3}\x03\x02\x02\x02\u{4a5}\u{4a8}\x03\x02\x02\x02\
	\u{4a6}\u{4a4}\x03\x02\x02\x02\u{4a6}\u{4a7}\x03\x02\x02\x02\u{4a7}\u{4a9}\
	\x03\x02\x02\x02\u{4a8}\u{4a6}\x03\x02\x02\x02\u{4a9}\u{4ab}\x05\x2c\x17\
	\x02\u{4aa}\u{4a6}\x03\x02\x02\x02\u{4aa}\u{4ab}\x03\x02\x02\x02\u{4ab}\
	\u{4bb}\x03\x02\x02\x02\u{4ac}\u{4ae}\x07\x07\x02\x02\u{4ad}\u{4ac}\x03\
	\x02\x02\x02\u{4ae}\u{4b1}\x03\x02\x02\x02\u{4af}\u{4ad}\x03\x02\x02\x02\
	\u{4af}\u{4b0}\x03\x02\x02\x02\u{4b0}\u{4b2}\x03\x02\x02\x02\u{4b1}\u{4af}\
	\x03\x02\x02\x02\u{4b2}\u{4b6}\x05\x7c\x3f\x02\u{4b3}\u{4b5}\x07\x07\x02\
	\x02\u{4b4}\u{4b3}\x03\x02\x02\x02\u{4b5}\u{4b8}\x03\x02\x02\x02\u{4b6}\
	\u{4b4}\x03\x02\x02\x02\u{4b6}\u{4b7}\x03\x02\x02\x02\u{4b7}\u{4b9}\x03\
	\x02\x02\x02\u{4b8}\u{4b6}\x03\x02\x02\x02\u{4b9}\u{4ba}\x07\x09\x02\x02\
	\u{4ba}\u{4bc}\x03\x02\x02\x02\u{4bb}\u{4af}\x03\x02\x02\x02\u{4bb}\u{4bc}\
	\x03\x02\x02\x02\u{4bc}\u{4c0}\x03\x02\x02\x02\u{4bd}\u{4bf}\x07\x07\x02\
	\x02\u{4be}\u{4bd}\x03\x02\x02\x02\u{4bf}\u{4c2}\x03\x02\x02\x02\u{4c0}\
	\u{4be}\x03\x02\x02\x02\u{4c0}\u{4c1}\x03\x02\x02\x02\u{4c1}\u{4c5}\x03\
	\x02\x02\x02\u{4c2}\u{4c0}\x03\x02\x02\x02\u{4c3}\u{4c6}\x05\x46\x24\x02\
	\u{4c4}\u{4c6}\x05\x44\x23\x02\u{4c5}\u{4c3}\x03\x02\x02\x02\u{4c5}\u{4c4}\
	\x03\x02\x02\x02\u{4c6}\u{4ce}\x03\x02\x02\x02\u{4c7}\u{4c9}\x07\x07\x02\
	\x02\u{4c8}\u{4c7}\x03\x02\x02\x02\u{4c9}\u{4cc}\x03\x02\x02\x02\u{4ca}\
	\u{4c8}\x03\x02\x02\x02\u{4ca}\u{4cb}\x03\x02\x02\x02\u{4cb}\u{4cd}\x03\
	\x02\x02\x02\u{4cc}\u{4ca}\x03\x02\x02\x02\u{4cd}\u{4cf}\x05\x30\x19\x02\
	\u{4ce}\u{4ca}\x03\x02\x02\x02\u{4ce}\u{4cf}\x03\x02\x02\x02\u{4cf}\u{4e1}\
	\x03\x02\x02\x02\u{4d0}\u{4d2}\x07\x07\x02\x02\u{4d1}\u{4d0}\x03\x02\x02\
	\x02\u{4d2}\u{4d5}\x03\x02\x02\x02\u{4d3}\u{4d1}\x03\x02\x02\x02\u{4d3}\
	\u{4d4}\x03\x02\x02\x02\u{4d4}\u{4df}\x03\x02\x02\x02\u{4d5}\u{4d3}\x03\
	\x02\x02\x02\u{4d6}\u{4da}\x07\x1e\x02\x02\u{4d7}\u{4d9}\x07\x07\x02\x02\
	\u{4d8}\u{4d7}\x03\x02\x02\x02\u{4d9}\u{4dc}\x03\x02\x02\x02\u{4da}\u{4d8}\
	\x03\x02\x02\x02\u{4da}\u{4db}\x03\x02\x02\x02\u{4db}\u{4dd}\x03\x02\x02\
	\x02\u{4dc}\u{4da}\x03\x02\x02\x02\u{4dd}\u{4e0}\x05\u{98}\x4d\x02\u{4de}\
	\u{4e0}\x05\x4a\x26\x02\u{4df}\u{4d6}\x03\x02\x02\x02\u{4df}\u{4de}\x03\
	\x02\x02\x02\u{4e0}\u{4e2}\x03\x02\x02\x02\u{4e1}\u{4d3}\x03\x02\x02\x02\
	\u{4e1}\u{4e2}\x03\x02\x02\x02\u{4e2}\u{4e9}\x03\x02\x02\x02\u{4e3}\u{4e5}\
	\x07\x07\x02\x02\u{4e4}\u{4e3}\x03\x02\x02\x02\u{4e5}\u{4e6}\x03\x02\x02\
	\x02\u{4e6}\u{4e4}\x03\x02\x02\x02\u{4e6}\u{4e7}\x03\x02\x02\x02\u{4e7}\
	\u{4e8}\x03\x02\x02\x02\u{4e8}\u{4ea}\x07\x1d\x02\x02\u{4e9}\u{4e4}\x03\
	\x02\x02\x02\u{4e9}\u{4ea}\x03\x02\x02\x02\u{4ea}\u{4ee}\x03\x02\x02\x02\
	\u{4eb}\u{4ed}\x07\x07\x02\x02\u{4ec}\u{4eb}\x03\x02\x02\x02\u{4ed}\u{4f0}\
	\x03\x02\x02\x02\u{4ee}\u{4ec}\x03\x02\x02\x02\u{4ee}\u{4ef}\x03\x02\x02\
	\x02\u{4ef}\u{50f}\x03\x02\x02\x02\u{4f0}\u{4ee}\x03\x02\x02\x02\u{4f1}\
	\u{4f3}\x05\x4c\x27\x02\u{4f2}\u{4f1}\x03\x02\x02\x02\u{4f2}\u{4f3}\x03\
	\x02\x02\x02\u{4f3}\u{4fe}\x03\x02\x02\x02\u{4f4}\u{4f6}\x07\x07\x02\x02\
	\u{4f5}\u{4f4}\x03\x02\x02\x02\u{4f6}\u{4f9}\x03\x02\x02\x02\u{4f7}\u{4f5}\
	\x03\x02\x02\x02\u{4f7}\u{4f8}\x03\x02\x02\x02\u{4f8}\u{4fb}\x03\x02\x02\
	\x02\u{4f9}\u{4f7}\x03\x02\x02\x02\u{4fa}\u{4fc}\x05\u{94}\x4b\x02\u{4fb}\
	\u{4fa}\x03\x02\x02\x02\u{4fb}\u{4fc}\x03\x02\x02\x02\u{4fc}\u{4fd}\x03\
	\x02\x02\x02\u{4fd}\u{4ff}\x05\x4e\x28\x02\u{4fe}\u{4f7}\x03\x02\x02\x02\
	\u{4fe}\u{4ff}\x03\x02\x02\x02\u{4ff}\u{510}\x03\x02\x02\x02\u{500}\u{502}\
	\x05\x4e\x28\x02\u{501}\u{500}\x03\x02\x02\x02\u{501}\u{502}\x03\x02\x02\
	\x02\u{502}\u{50d}\x03\x02\x02\x02\u{503}\u{505}\x07\x07\x02\x02\u{504}\
	\u{503}\x03\x02\x02\x02\u{505}\u{508}\x03\x02\x02\x02\u{506}\u{504}\x03\
	\x02\x02\x02\u{506}\u{507}\x03\x02\x02\x02\u{507}\u{50a}\x03\x02\x02\x02\
	\u{508}\u{506}\x03\x02\x02\x02\u{509}\u{50b}\x05\u{94}\x4b\x02\u{50a}\u{509}\
	\x03\x02\x02\x02\u{50a}\u{50b}\x03\x02\x02\x02\u{50b}\u{50c}\x03\x02\x02\
	\x02\u{50c}\u{50e}\x05\x4c\x27\x02\u{50d}\u{506}\x03\x02\x02\x02\u{50d}\
	\u{50e}\x03\x02\x02\x02\u{50e}\u{510}\x03\x02\x02\x02\u{50f}\u{4f2}\x03\
	\x02\x02\x02\u{50f}\u{501}\x03\x02\x02\x02\u{510}\x49\x03\x02\x02\x02\u{511}\
	\u{515}\x07\x52\x02\x02\u{512}\u{514}\x07\x07\x02\x02\u{513}\u{512}\x03\
	\x02\x02\x02\u{514}\u{517}\x03\x02\x02\x02\u{515}\u{513}\x03\x02\x02\x02\
	\u{515}\u{516}\x03\x02\x02\x02\u{516}\u{518}\x03\x02\x02\x02\u{517}\u{515}\
	\x03\x02\x02\x02\u{518}\u{519}\x05\u{98}\x4d\x02\u{519}\x4b\x03\x02\x02\
	\x02\u{51a}\u{51c}\x05\u{12c}\u{97}\x02\u{51b}\u{51a}\x03\x02\x02\x02\u{51b}\
	\u{51c}\x03\x02\x02\x02\u{51c}\u{51d}\x03\x02\x02\x02\u{51d}\u{543}\x07\
	\x42\x02\x02\u{51e}\u{520}\x07\x07\x02\x02\u{51f}\u{51e}\x03\x02\x02\x02\
	\u{520}\u{523}\x03\x02\x02\x02\u{521}\u{51f}\x03\x02\x02\x02\u{521}\u{522}\
	\x03\x02\x02\x02\u{522}\u{524}\x03\x02\x02\x02\u{523}\u{521}\x03\x02\x02\
	\x02\u{524}\u{528}\x07\x0b\x02\x02\u{525}\u{527}\x07\x07\x02\x02\u{526}\
	\u{525}\x03\x02\x02\x02\u{527}\u{52a}\x03\x02\x02\x02\u{528}\u{526}\x03\
	\x02\x02\x02\u{528}\u{529}\x03\x02\x02\x02\u{529}\u{52b}\x03\x02\x02\x02\
	\u{52a}\u{528}\x03\x02\x02\x02\u{52b}\u{53a}\x07\x0c\x02\x02\u{52c}\u{52e}\
	\x07\x07\x02\x02\u{52d}\u{52c}\x03\x02\x02\x02\u{52e}\u{531}\x03\x02\x02\
	\x02\u{52f}\u{52d}\x03\x02\x02\x02\u{52f}\u{530}\x03\x02\x02\x02\u{530}\
	\u{532}\x03\x02\x02\x02\u{531}\u{52f}\x03\x02\x02\x02\u{532}\u{536}\x07\
	\x1c\x02\x02\u{533}\u{535}\x07\x07\x02\x02\u{534}\u{533}\x03\x02\x02\x02\
	\u{535}\u{538}\x03\x02\x02\x02\u{536}\u{534}\x03\x02\x02\x02\u{536}\u{537}\
	\x03\x02\x02\x02\u{537}\u{539}\x03\x02\x02\x02\u{538}\u{536}\x03\x02\x02\
	\x02\u{539}\u{53b}\x05\x64\x33\x02\u{53a}\u{52f}\x03\x02\x02\x02\u{53a}\
	\u{53b}\x03\x02\x02\x02\u{53b}\u{53f}\x03\x02\x02\x02\u{53c}\u{53e}\x07\
	\x07\x02\x02\u{53d}\u{53c}\x03\x02\x02\x02\u{53e}\u{541}\x03\x02\x02\x02\
	\u{53f}\u{53d}\x03\x02\x02\x02\u{53f}\u{540}\x03\x02\x02\x02\u{540}\u{542}\
	\x03\x02\x02\x02\u{541}\u{53f}\x03\x02\x02\x02\u{542}\u{544}\x05\x42\x22\
	\x02\u{543}\u{521}\x03\x02\x02\x02\u{543}\u{544}\x03\x02\x02\x02\u{544}\
	\x4d\x03\x02\x02\x02\u{545}\u{547}\x05\u{12c}\u{97}\x02\u{546}\u{545}\x03\
	\x02\x02\x02\u{546}\u{547}\x03\x02\x02\x02\u{547}\u{548}\x03\x02\x02\x02\
	\u{548}\u{57f}\x07\x43\x02\x02\u{549}\u{54b}\x07\x07\x02\x02\u{54a}\u{549}\
	\x03\x02\x02\x02\u{54b}\u{54e}\x03\x02\x02\x02\u{54c}\u{54a}\x03\x02\x02\
	\x02\u{54c}\u{54d}\x03\x02\x02\x02\u{54d}\u{54f}\x03\x02\x02\x02\u{54e}\
	\u{54c}\x03\x02\x02\x02\u{54f}\u{553}\x07\x0b\x02\x02\u{550}\u{552}\x07\
	\x07\x02\x02\u{551}\u{550}\x03\x02\x02\x02\u{552}\u{555}\x03\x02\x02\x02\
	\u{553}\u{551}\x03\x02\x02\x02\u{553}\u{554}\x03\x02\x02\x02\u{554}\u{556}\
	\x03\x02\x02\x02\u{555}\u{553}\x03\x02\x02\x02\u{556}\u{55e}\x05\x52\x2a\
	\x02\u{557}\u{559}\x07\x07\x02\x02\u{558}\u{557}\x03\x02\x02\x02\u{559}\
	\u{55c}\x03\x02\x02\x02\u{55a}\u{558}\x03\x02\x02\x02\u{55a}\u{55b}\x03\
	\x02\x02\x02\u{55b}\u{55d}\x03\x02\x02\x02\u{55c}\u{55a}\x03\x02\x02\x02\
	\u{55d}\u{55f}\x07\x0a\x02\x02\u{55e}\u{55a}\x03\x02\x02\x02\u{55e}\u{55f}\
	\x03\x02\x02\x02\u{55f}\u{563}\x03\x02\x02\x02\u{560}\u{562}\x07\x07\x02\
	\x02\u{561}\u{560}\x03\x02\x02\x02\u{562}\u{565}\x03\x02\x02\x02\u{563}\
	\u{561}\x03\x02\x02\x02\u{563}\u{564}\x03\x02\x02\x02\u{564}\u{566}\x03\
	\x02\x02\x02\u{565}\u{563}\x03\x02\x02\x02\u{566}\u{575}\x07\x0c\x02\x02\
	\u{567}\u{569}\x07\x07\x02\x02\u{568}\u{567}\x03\x02\x02\x02\u{569}\u{56c}\
	\x03\x02\x02\x02\u{56a}\u{568}\x03\x02\x02\x02\u{56a}\u{56b}\x03\x02\x02\
	\x02\u{56b}\u{56d}\x03\x02\x02\x02\u{56c}\u{56a}\x03\x02\x02\x02\u{56d}\
	\u{571}\x07\x1c\x02\x02\u{56e}\u{570}\x07\x07\x02\x02\u{56f}\u{56e}\x03\
	\x02\x02\x02\u{570}\u{573}\x03\x02\x02\x02\u{571}\u{56f}\x03\x02\x02\x02\
	\u{571}\u{572}\x03\x02\x02\x02\u{572}\u{574}\x03\x02\x02\x02\u{573}\u{571}\
	\x03\x02\x02\x02\u{574}\u{576}\x05\x64\x33\x02\u{575}\u{56a}\x03\x02\x02\
	\x02\u{575}\u{576}\x03\x02\x02\x02\u{576}\u{57a}\x03\x02\x02\x02\u{577}\
	\u{579}\x07\x07\x02\x02\u{578}\u{577}\x03\x02\x02\x02\u{579}\u{57c}\x03\
	\x02\x02\x02\u{57a}\u{578}\x03\x02\x02\x02\u{57a}\u{57b}\x03\x02\x02\x02\
	\u{57b}\u{57d}\x03\x02\x02\x02\u{57c}\u{57a}\x03\x02\x02\x02\u{57d}\u{57e}\
	\x05\x42\x22\x02\u{57e}\u{580}\x03\x02\x02\x02\u{57f}\u{54c}\x03\x02\x02\
	\x02\u{57f}\u{580}\x03\x02\x02\x02\u{580}\x4f\x03\x02\x02\x02\u{581}\u{585}\
	\x07\x0b\x02\x02\u{582}\u{584}\x07\x07\x02\x02\u{583}\u{582}\x03\x02\x02\
	\x02\u{584}\u{587}\x03\x02\x02\x02\u{585}\u{583}\x03\x02\x02\x02\u{585}\
	\u{586}\x03\x02\x02\x02\u{586}\u{5a5}\x03\x02\x02\x02\u{587}\u{585}\x03\
	\x02\x02\x02\u{588}\u{599}\x05\x52\x2a\x02\u{589}\u{58b}\x07\x07\x02\x02\
	\u{58a}\u{589}\x03\x02\x02\x02\u{58b}\u{58e}\x03\x02\x02\x02\u{58c}\u{58a}\
	\x03\x02\x02\x02\u{58c}\u{58d}\x03\x02\x02\x02\u{58d}\u{58f}\x03\x02\x02\
	\x02\u{58e}\u{58c}\x03\x02\x02\x02\u{58f}\u{593}\x07\x0a\x02\x02\u{590}\
	\u{592}\x07\x07\x02\x02\u{591}\u{590}\x03\x02\x02\x02\u{592}\u{595}\x03\
	\x02\x02\x02\u{593}\u{591}\x03\x02\x02\x02\u{593}\u{594}\x03\x02\x02\x02\
	\u{594}\u{596}\x03\x02\x02\x02\u{595}\u{593}\x03\x02\x02\x02\u{596}\u{598}\
	\x05\x52\x2a\x02\u{597}\u{58c}\x03\x02\x02\x02\u{598}\u{59b}\x03\x02\x02\
	\x02\u{599}\u{597}\x03\x02\x02\x02\u{599}\u{59a}\x03\x02\x02\x02\u{59a}\
	\u{5a3}\x03\x02\x02\x02\u{59b}\u{599}\x03\x02\x02\x02\u{59c}\u{59e}\x07\
	\x07\x02\x02\u{59d}\u{59c}\x03\x02\x02\x02\u{59e}\u{5a1}\x03\x02\x02\x02\
	\u{59f}\u{59d}\x03\x02\x02\x02\u{59f}\u{5a0}\x03\x02\x02\x02\u{5a0}\u{5a2}\
	\x03\x02\x02\x02\u{5a1}\u{59f}\x03\x02\x02\x02\u{5a2}\u{5a4}\x07\x0a\x02\
	\x02\u{5a3}\u{59f}\x03\x02\x02\x02\u{5a3}\u{5a4}\x03\x02\x02\x02\u{5a4}\
	\u{5a6}\x03\x02\x02\x02\u{5a5}\u{588}\x03\x02\x02\x02\u{5a5}\u{5a6}\x03\
	\x02\x02\x02\u{5a6}\u{5aa}\x03\x02\x02\x02\u{5a7}\u{5a9}\x07\x07\x02\x02\
	\u{5a8}\u{5a7}\x03\x02\x02\x02\u{5a9}\u{5ac}\x03\x02\x02\x02\u{5aa}\u{5a8}\
	\x03\x02\x02\x02\u{5aa}\u{5ab}\x03\x02\x02\x02\u{5ab}\u{5ad}\x03\x02\x02\
	\x02\u{5ac}\u{5aa}\x03\x02\x02\x02\u{5ad}\u{5ae}\x07\x0c\x02\x02\u{5ae}\
	\x51\x03\x02\x02\x02\u{5af}\u{5b1}\x05\u{12e}\u{98}\x02\u{5b0}\u{5af}\x03\
	\x02\x02\x02\u{5b0}\u{5b1}\x03\x02\x02\x02\u{5b1}\u{5b2}\x03\x02\x02\x02\
	\u{5b2}\u{5c1}\x05\x54\x2b\x02\u{5b3}\u{5b5}\x07\x07\x02\x02\u{5b4}\u{5b3}\
	\x03\x02\x02\x02\u{5b5}\u{5b8}\x03\x02\x02\x02\u{5b6}\u{5b4}\x03\x02\x02\
	\x02\u{5b6}\u{5b7}\x03\x02\x02\x02\u{5b7}\u{5b9}\x03\x02\x02\x02\u{5b8}\
	\u{5b6}\x03\x02\x02\x02\u{5b9}\u{5bd}\x07\x1e\x02\x02\u{5ba}\u{5bc}\x07\
	\x07\x02\x02\u{5bb}\u{5ba}\x03\x02\x02\x02\u{5bc}\u{5bf}\x03\x02\x02\x02\
	\u{5bd}\u{5bb}\x03\x02\x02\x02\u{5bd}\u{5be}\x03\x02\x02\x02\u{5be}\u{5c0}\
	\x03\x02\x02\x02\u{5bf}\u{5bd}\x03\x02\x02\x02\u{5c0}\u{5c2}\x05\u{98}\x4d\
	\x02\u{5c1}\u{5b6}\x03\x02\x02\x02\u{5c1}\u{5c2}\x03\x02\x02\x02\u{5c2}\
	\x53\x03\x02\x02\x02\u{5c3}\u{5c7}\x05\u{158}\u{ad}\x02\u{5c4}\u{5c6}\x07\
	\x07\x02\x02\u{5c5}\u{5c4}\x03\x02\x02\x02\u{5c6}\u{5c9}\x03\x02\x02\x02\
	\u{5c7}\u{5c5}\x03\x02\x02\x02\u{5c7}\u{5c8}\x03\x02\x02\x02\u{5c8}\u{5d2}\
	\x03\x02\x02\x02\u{5c9}\u{5c7}\x03\x02\x02\x02\u{5ca}\u{5ce}\x07\x1c\x02\
	\x02\u{5cb}\u{5cd}\x07\x07\x02\x02\u{5cc}\u{5cb}\x03\x02\x02\x02\u{5cd}\
	\u{5d0}\x03\x02\x02\x02\u{5ce}\u{5cc}\x03\x02\x02\x02\u{5ce}\u{5cf}\x03\
	\x02\x02\x02\u{5cf}\u{5d1}\x03\x02\x02\x02\u{5d0}\u{5ce}\x03\x02\x02\x02\
	\u{5d1}\u{5d3}\x05\x64\x33\x02\u{5d2}\u{5ca}\x03\x02\x02\x02\u{5d2}\u{5d3}\
	\x03\x02\x02\x02\u{5d3}\x55\x03\x02\x02\x02\u{5d4}\u{5d8}\x05\u{158}\u{ad}\
	\x02\u{5d5}\u{5d7}\x07\x07\x02\x02\u{5d6}\u{5d5}\x03\x02\x02\x02\u{5d7}\
	\u{5da}\x03\x02\x02\x02\u{5d8}\u{5d6}\x03\x02\x02\x02\u{5d8}\u{5d9}\x03\
	\x02\x02\x02\u{5d9}\u{5db}\x03\x02\x02\x02\u{5da}\u{5d8}\x03\x02\x02\x02\
	\u{5db}\u{5df}\x07\x1c\x02\x02\u{5dc}\u{5de}\x07\x07\x02\x02\u{5dd}\u{5dc}\
	\x03\x02\x02\x02\u{5de}\u{5e1}\x03\x02\x02\x02\u{5df}\u{5dd}\x03\x02\x02\
	\x02\u{5df}\u{5e0}\x03\x02\x02\x02\u{5e0}\u{5e2}\x03\x02\x02\x02\u{5e1}\
	\u{5df}\x03\x02\x02\x02\u{5e2}\u{5e3}\x05\x64\x33\x02\u{5e3}\x57\x03\x02\
	\x02\x02\u{5e4}\u{5e6}\x05\u{12c}\u{97}\x02\u{5e5}\u{5e4}\x03\x02\x02\x02\
	\u{5e5}\u{5e6}\x03\x02\x02\x02\u{5e6}\u{5e7}\x03\x02\x02\x02\u{5e7}\u{5eb}\
	\x07\x4d\x02\x02\u{5e8}\u{5ea}\x07\x07\x02\x02\u{5e9}\u{5e8}\x03\x02\x02\
	\x02\u{5ea}\u{5ed}\x03\x02\x02\x02\u{5eb}\u{5e9}\x03\x02\x02\x02\u{5eb}\
	\u{5ec}\x03\x02\x02\x02\u{5ec}\u{5ee}\x03\x02\x02\x02\u{5ed}\u{5eb}\x03\
	\x02\x02\x02\u{5ee}\u{5fd}\x05\u{158}\u{ad}\x02\u{5ef}\u{5f1}\x07\x07\x02\
	\x02\u{5f0}\u{5ef}\x03\x02\x02\x02\u{5f1}\u{5f4}\x03\x02\x02\x02\u{5f2}\
	\u{5f0}\x03\x02\x02\x02\u{5f2}\u{5f3}\x03\x02\x02\x02\u{5f3}\u{5f5}\x03\
	\x02\x02\x02\u{5f4}\u{5f2}\x03\x02\x02\x02\u{5f5}\u{5f9}\x07\x1c\x02\x02\
	\u{5f6}\u{5f8}\x07\x07\x02\x02\u{5f7}\u{5f6}\x03\x02\x02\x02\u{5f8}\u{5fb}\
	\x03\x02\x02\x02\u{5f9}\u{5f7}\x03\x02\x02\x02\u{5f9}\u{5fa}\x03\x02\x02\
	\x02\u{5fa}\u{5fc}\x03\x02\x02\x02\u{5fb}\u{5f9}\x03\x02\x02\x02\u{5fc}\
	\u{5fe}\x05\x22\x12\x02\u{5fd}\u{5f2}\x03\x02\x02\x02\u{5fd}\u{5fe}\x03\
	\x02\x02\x02\u{5fe}\u{606}\x03\x02\x02\x02\u{5ff}\u{601}\x07\x07\x02\x02\
	\u{600}\u{5ff}\x03\x02\x02\x02\u{601}\u{604}\x03\x02\x02\x02\u{602}\u{600}\
	\x03\x02\x02\x02\u{602}\u{603}\x03\x02\x02\x02\u{603}\u{605}\x03\x02\x02\
	\x02\u{604}\u{602}\x03\x02\x02\x02\u{605}\u{607}\x05\x1c\x0f\x02\u{606}\
	\u{602}\x03\x02\x02\x02\u{606}\u{607}\x03\x02\x02\x02\u{607}\x59\x03\x02\
	\x02\x02\u{608}\u{60a}\x05\u{12c}\u{97}\x02\u{609}\u{608}\x03\x02\x02\x02\
	\u{609}\u{60a}\x03\x02\x02\x02\u{60a}\u{60b}\x03\x02\x02\x02\u{60b}\u{60f}\
	\x07\x51\x02\x02\u{60c}\u{60e}\x07\x07\x02\x02\u{60d}\u{60c}\x03\x02\x02\
	\x02\u{60e}\u{611}\x03\x02\x02\x02\u{60f}\u{60d}\x03\x02\x02\x02\u{60f}\
	\u{610}\x03\x02\x02\x02\u{610}\u{612}\x03\x02\x02\x02\u{611}\u{60f}\x03\
	\x02\x02\x02\u{612}\u{621}\x05\x3c\x1f\x02\u{613}\u{615}\x07\x07\x02\x02\
	\u{614}\u{613}\x03\x02\x02\x02\u{615}\u{618}\x03\x02\x02\x02\u{616}\u{614}\
	\x03\x02\x02\x02\u{616}\u{617}\x03\x02\x02\x02\u{617}\u{619}\x03\x02\x02\
	\x02\u{618}\u{616}\x03\x02\x02\x02\u{619}\u{61d}\x07\x1c\x02\x02\u{61a}\
	\u{61c}\x07\x07\x02\x02\u{61b}\u{61a}\x03\x02\x02\x02\u{61c}\u{61f}\x03\
	\x02\x02\x02\u{61d}\u{61b}\x03\x02\x02\x02\u{61d}\u{61e}\x03\x02\x02\x02\
	\u{61e}\u{620}\x03\x02\x02\x02\u{61f}\u{61d}\x03\x02\x02\x02\u{620}\u{622}\
	\x05\x5c\x2f\x02\u{621}\u{616}\x03\x02\x02\x02\u{621}\u{622}\x03\x02\x02\
	\x02\u{622}\u{626}\x03\x02\x02\x02\u{623}\u{625}\x07\x07\x02\x02\u{624}\
	\u{623}\x03\x02\x02\x02\u{625}\u{628}\x03\x02\x02\x02\u{626}\u{624}\x03\
	\x02\x02\x02\u{626}\u{627}\x03\x02\x02\x02\u{627}\u{62a}\x03\x02\x02\x02\
	\u{628}\u{626}\x03\x02\x02\x02\u{629}\u{62b}\x05\u{88}\x45\x02\u{62a}\u{629}\
	\x03\x02\x02\x02\u{62a}\u{62b}\x03\x02\x02\x02\u{62b}\x5b\x03\x02\x02\x02\
	\u{62c}\u{630}\x09\x04\x02\x02\u{62d}\u{62f}\x07\x07\x02\x02\u{62e}\u{62d}\
	\x03\x02\x02\x02\u{62f}\u{632}\x03\x02\x02\x02\u{630}\u{62e}\x03\x02\x02\
	\x02\u{630}\u{631}\x03\x02\x02\x02\u{631}\u{633}\x03\x02\x02\x02\u{632}\
	\u{630}\x03\x02\x02\x02\u{633}\u{634}\x05\u{d0}\x69\x02\u{634}\x5d\x03\x02\
	\x02\x02\u{635}\u{639}\x07\x0f\x02\x02\u{636}\u{638}\x07\x07\x02\x02\u{637}\
	\u{636}\x03\x02\x02\x02\u{638}\u{63b}\x03\x02\x02\x02\u{639}\u{637}\x03\
	\x02\x02\x02\u{639}\u{63a}\x03\x02\x02\x02\u{63a}\u{63d}\x03\x02\x02\x02\
	\u{63b}\u{639}\x03\x02\x02\x02\u{63c}\u{63e}\x05\x60\x31\x02\u{63d}\u{63c}\
	\x03\x02\x02\x02\u{63d}\u{63e}\x03\x02\x02\x02\u{63e}\u{64d}\x03\x02\x02\
	\x02\u{63f}\u{641}\x07\x07\x02\x02\u{640}\u{63f}\x03\x02\x02\x02\u{641}\
	\u{644}\x03\x02\x02\x02\u{642}\u{640}\x03\x02\x02\x02\u{642}\u{643}\x03\
	\x02\x02\x02\u{643}\u{645}\x03\x02\x02\x02\u{644}\u{642}\x03\x02\x02\x02\
	\u{645}\u{649}\x07\x1d\x02\x02\u{646}\u{648}\x07\x07\x02\x02\u{647}\u{646}\
	\x03\x02\x02\x02\u{648}\u{64b}\x03\x02\x02\x02\u{649}\u{647}\x03\x02\x02\
	\x02\u{649}\u{64a}\x03\x02\x02\x02\u{64a}\u{64c}\x03\x02\x02\x02\u{64b}\
	\u{649}\x03\x02\x02\x02\u{64c}\u{64e}\x05\x34\x1b\x02\u{64d}\u{642}\x03\
	\x02\x02\x02\u{64d}\u{64e}\x03\x02\x02\x02\u{64e}\u{652}\x03\x02\x02\x02\
	\u{64f}\u{651}\x07\x07\x02\x02\u{650}\u{64f}\x03\x02\x02\x02\u{651}\u{654}\
	\x03\x02\x02\x02\u{652}\u{650}\x03\x02\x02\x02\u{652}\u{653}\x03\x02\x02\
	\x02\u{653}\u{655}\x03\x02\x02\x02\u{654}\u{652}\x03\x02\x02\x02\u{655}\
	\u{656}\x07\x10\x02\x02\u{656}\x5f\x03\x02\x02\x02\u{657}\u{668}\x05\x62\
	\x32\x02\u{658}\u{65a}\x07\x07\x02\x02\u{659}\u{658}\x03\x02\x02\x02\u{65a}\
	\u{65d}\x03\x02\x02\x02\u{65b}\u{659}\x03\x02\x02\x02\u{65b}\u{65c}\x03\
	\x02\x02\x02\u{65c}\u{65e}\x03\x02\x02\x02\u{65d}\u{65b}\x03\x02\x02\x02\
	\u{65e}\u{662}\x07\x0a\x02\x02\u{65f}\u{661}\x07\x07\x02\x02\u{660}\u{65f}\
	\x03\x02\x02\x02\u{661}\u{664}\x03\x02\x02\x02\u{662}\u{660}\x03\x02\x02\
	\x02\u{662}\u{663}\x03\x02\x02\x02\u{663}\u{665}\x03\x02\x02\x02\u{664}\
	\u{662}\x03\x02\x02\x02\u{665}\u{667}\x05\x62\x32\x02\u{666}\u{65b}\x03\
	\x02\x02\x02\u{667}\u{66a}\x03\x02\x02\x02\u{668}\u{666}\x03\x02\x02\x02\
	\u{668}\u{669}\x03\x02\x02\x02\u{669}\u{66e}\x03\x02\x02\x02\u{66a}\u{668}\
	\x03\x02\x02\x02\u{66b}\u{66d}\x07\x07\x02\x02\u{66c}\u{66b}\x03\x02\x02\
	\x02\u{66d}\u{670}\x03\x02\x02\x02\u{66e}\u{66c}\x03\x02\x02\x02\u{66e}\
	\u{66f}\x03\x02\x02\x02\u{66f}\u{672}\x03\x02\x02\x02\u{670}\u{66e}\x03\
	\x02\x02\x02\u{671}\u{673}\x07\x0a\x02\x02\u{672}\u{671}\x03\x02\x02\x02\
	\u{672}\u{673}\x03\x02\x02\x02\u{673}\x61\x03\x02\x02\x02\u{674}\u{678}\
	\x05\u{12c}\u{97}\x02\u{675}\u{677}\x07\x07\x02\x02\u{676}\u{675}\x03\x02\
	\x02\x02\u{677}\u{67a}\x03\x02\x02\x02\u{678}\u{676}\x03\x02\x02\x02\u{678}\
	\u{679}\x03\x02\x02\x02\u{679}\u{67c}\x03\x02\x02\x02\u{67a}\u{678}\x03\
	\x02\x02\x02\u{67b}\u{674}\x03\x02\x02\x02\u{67b}\u{67c}\x03\x02\x02\x02\
	\u{67c}\u{67d}\x03\x02\x02\x02\u{67d}\u{685}\x05\u{158}\u{ad}\x02\u{67e}\
	\u{680}\x07\x07\x02\x02\u{67f}\u{67e}\x03\x02\x02\x02\u{680}\u{683}\x03\
	\x02\x02\x02\u{681}\u{67f}\x03\x02\x02\x02\u{681}\u{682}\x03\x02\x02\x02\
	\u{682}\u{684}\x03\x02\x02\x02\u{683}\u{681}\x03\x02\x02\x02\u{684}\u{686}\
	\x05\u{d0}\x69\x02\u{685}\u{681}\x03\x02\x02\x02\u{685}\u{686}\x03\x02\x02\
	\x02\u{686}\u{68e}\x03\x02\x02\x02\u{687}\u{689}\x07\x07\x02\x02\u{688}\
	\u{687}\x03\x02\x02\x02\u{689}\u{68c}\x03\x02\x02\x02\u{68a}\u{688}\x03\
	\x02\x02\x02\u{68a}\u{68b}\x03\x02\x02\x02\u{68b}\u{68d}\x03\x02\x02\x02\
	\u{68c}\u{68a}\x03\x02\x02\x02\u{68d}\u{68f}\x05\x1c\x0f\x02\u{68e}\u{68a}\
	\x03\x02\x02\x02\u{68e}\u{68f}\x03\x02\x02\x02\u{68f}\x63\x03\x02\x02\x02\
	\u{690}\u{692}\x05\u{132}\u{9a}\x02\u{691}\u{690}\x03\x02\x02\x02\u{691}\
	\u{692}\x03\x02\x02\x02\u{692}\u{697}\x03\x02\x02\x02\u{693}\u{698}\x05\
	\x7a\x3e\x02\u{694}\u{698}\x05\x68\x35\x02\u{695}\u{698}\x05\x66\x34\x02\
	\u{696}\u{698}\x05\x76\x3c\x02\u{697}\u{693}\x03\x02\x02\x02\u{697}\u{694}\
	\x03\x02\x02\x02\u{697}\u{695}\x03\x02\x02\x02\u{697}\u{696}\x03\x02\x02\
	\x02\u{698}\x65\x03\x02\x02\x02\u{699}\u{69c}\x05\x6c\x37\x02\u{69a}\u{69c}\
	\x07\x6c\x02\x02\u{69b}\u{699}\x03\x02\x02\x02\u{69b}\u{69a}\x03\x02\x02\
	\x02\u{69c}\x67\x03\x02\x02\x02\u{69d}\u{6a0}\x05\x66\x34\x02\u{69e}\u{6a0}\
	\x05\x7a\x3e\x02\u{69f}\u{69d}\x03\x02\x02\x02\u{69f}\u{69e}\x03\x02\x02\
	\x02\u{6a0}\u{6a4}\x03\x02\x02\x02\u{6a1}\u{6a3}\x07\x07\x02\x02\u{6a2}\
	\u{6a1}\x03\x02\x02\x02\u{6a3}\u{6a6}\x03\x02\x02\x02\u{6a4}\u{6a2}\x03\
	\x02\x02\x02\u{6a4}\u{6a5}\x03\x02\x02\x02\u{6a5}\u{6a8}\x03\x02\x02\x02\
	\u{6a6}\u{6a4}\x03\x02\x02\x02\u{6a7}\u{6a9}\x05\x6a\x36\x02\u{6a8}\u{6a7}\
	\x03\x02\x02\x02\u{6a9}\u{6aa}\x03\x02\x02\x02\u{6aa}\u{6a8}\x03\x02\x02\
	\x02\u{6aa}\u{6ab}\x03\x02\x02\x02\u{6ab}\x69\x03\x02\x02\x02\u{6ac}\u{6ad}\
	\x09\x05\x02\x02\u{6ad}\x6b\x03\x02\x02\x02\u{6ae}\u{6bf}\x05\x6e\x38\x02\
	\u{6af}\u{6b1}\x07\x07\x02\x02\u{6b0}\u{6af}\x03\x02\x02\x02\u{6b1}\u{6b4}\
	\x03\x02\x02\x02\u{6b2}\u{6b0}\x03\x02\x02\x02\u{6b2}\u{6b3}\x03\x02\x02\
	\x02\u{6b3}\u{6b5}\x03\x02\x02\x02\u{6b4}\u{6b2}\x03\x02\x02\x02\u{6b5}\
	\u{6b9}\x07\x09\x02\x02\u{6b6}\u{6b8}\x07\x07\x02\x02\u{6b7}\u{6b6}\x03\
	\x02\x02\x02\u{6b8}\u{6bb}\x03\x02\x02\x02\u{6b9}\u{6b7}\x03\x02\x02\x02\
	\u{6b9}\u{6ba}\x03\x02\x02\x02\u{6ba}\u{6bc}\x03\x02\x02\x02\u{6bb}\u{6b9}\
	\x03\x02\x02\x02\u{6bc}\u{6be}\x05\x6e\x38\x02\u{6bd}\u{6b2}\x03\x02\x02\
	\x02\u{6be}\u{6c1}\x03\x02\x02\x02\u{6bf}\u{6bd}\x03\x02\x02\x02\u{6bf}\
	\u{6c0}\x03\x02\x02\x02\u{6c0}\x6d\x03\x02\x02\x02\u{6c1}\u{6bf}\x03\x02\
	\x02\x02\u{6c2}\u{6ca}\x05\u{158}\u{ad}\x02\u{6c3}\u{6c5}\x07\x07\x02\x02\
	\u{6c4}\u{6c3}\x03\x02\x02\x02\u{6c5}\u{6c8}\x03\x02\x02\x02\u{6c6}\u{6c4}\
	\x03\x02\x02\x02\u{6c6}\u{6c7}\x03\x02\x02\x02\u{6c7}\u{6c9}\x03\x02\x02\
	\x02\u{6c8}\u{6c6}\x03\x02\x02\x02\u{6c9}\u{6cb}\x05\u{ce}\x68\x02\u{6ca}\
	\u{6c6}\x03\x02\x02\x02\u{6ca}\u{6cb}\x03\x02\x02\x02\u{6cb}\x6f\x03\x02\
	\x02\x02\u{6cc}\u{6ce}\x05\x72\x3a\x02\u{6cd}\u{6cc}\x03\x02\x02\x02\u{6cd}\
	\u{6ce}\x03\x02\x02\x02\u{6ce}\u{6cf}\x03\x02\x02\x02\u{6cf}\u{6d2}\x05\
	\x64\x33\x02\u{6d0}\u{6d2}\x07\x11\x02\x02\u{6d1}\u{6cd}\x03\x02\x02\x02\
	\u{6d1}\u{6d0}\x03\x02\x02\x02\u{6d2}\x71\x03\x02\x02\x02\u{6d3}\u{6d5}\
	\x05\x74\x3b\x02\u{6d4}\u{6d3}\x03\x02\x02\x02\u{6d5}\u{6d6}\x03\x02\x02\
	\x02\u{6d6}\u{6d4}\x03\x02\x02\x02\u{6d6}\u{6d7}\x03\x02\x02\x02\u{6d7}\
	\x73\x03\x02\x02\x02\u{6d8}\u{6dc}\x05\u{13c}\u{9f}\x02\u{6d9}\u{6db}\x07\
	\x07\x02\x02\u{6da}\u{6d9}\x03\x02\x02\x02\u{6db}\u{6de}\x03\x02\x02\x02\
	\u{6dc}\u{6da}\x03\x02\x02\x02\u{6dc}\u{6dd}\x03\x02\x02\x02\u{6dd}\u{6e1}\
	\x03\x02\x02\x02\u{6de}\u{6dc}\x03\x02\x02\x02\u{6df}\u{6e1}\x05\u{14e}\
	\u{a8}\x02\u{6e0}\u{6d8}\x03\x02\x02\x02\u{6e0}\u{6df}\x03\x02\x02\x02\u{6e1}\
	\x75\x03\x02\x02\x02\u{6e2}\u{6e6}\x05\x7c\x3f\x02\u{6e3}\u{6e5}\x07\x07\
	\x02\x02\u{6e4}\u{6e3}\x03\x02\x02\x02\u{6e5}\u{6e8}\x03\x02\x02\x02\u{6e6}\
	\u{6e4}\x03\x02\x02\x02\u{6e6}\u{6e7}\x03\x02\x02\x02\u{6e7}\u{6e9}\x03\
	\x02\x02\x02\u{6e8}\u{6e6}\x03\x02\x02\x02\u{6e9}\u{6ed}\x07\x09\x02\x02\
	\u{6ea}\u{6ec}\x07\x07\x02\x02\u{6eb}\u{6ea}\x03\x02\x02\x02\u{6ec}\u{6ef}\
	\x03\x02\x02\x02\u{6ed}\u{6eb}\x03\x02\x02\x02\u{6ed}\u{6ee}\x03\x02\x02\
	\x02\u{6ee}\u{6f1}\x03\x02\x02\x02\u{6ef}\u{6ed}\x03\x02\x02\x02\u{6f0}\
	\u{6e2}\x03\x02\x02\x02\u{6f0}\u{6f1}\x03\x02\x02\x02\u{6f1}\u{6f2}\x03\
	\x02\x02\x02\u{6f2}\u{6f6}\x05\x78\x3d\x02\u{6f3}\u{6f5}\x07\x07\x02\x02\
	\u{6f4}\u{6f3}\x03\x02\x02\x02\u{6f5}\u{6f8}\x03\x02\x02\x02\u{6f6}\u{6f4}\
	\x03\x02\x02\x02\u{6f6}\u{6f7}\x03\x02\x02\x02\u{6f7}\u{6f9}\x03\x02\x02\
	\x02\u{6f8}\u{6f6}\x03\x02\x02\x02\u{6f9}\u{6fd}\x07\x24\x02\x02\u{6fa}\
	\u{6fc}\x07\x07\x02\x02\u{6fb}\u{6fa}\x03\x02\x02\x02\u{6fc}\u{6ff}\x03\
	\x02\x02\x02\u{6fd}\u{6fb}\x03\x02\x02\x02\u{6fd}\u{6fe}\x03\x02\x02\x02\
	\u{6fe}\u{700}\x03\x02\x02\x02\u{6ff}\u{6fd}\x03\x02\x02\x02\u{700}\u{701}\
	\x05\x64\x33\x02\u{701}\x77\x03\x02\x02\x02\u{702}\u{706}\x07\x0b\x02\x02\
	\u{703}\u{705}\x07\x07\x02\x02\u{704}\u{703}\x03\x02\x02\x02\u{705}\u{708}\
	\x03\x02\x02\x02\u{706}\u{704}\x03\x02\x02\x02\u{706}\u{707}\x03\x02\x02\
	\x02\u{707}\u{70b}\x03\x02\x02\x02\u{708}\u{706}\x03\x02\x02\x02\u{709}\
	\u{70c}\x05\x56\x2c\x02\u{70a}\u{70c}\x05\x64\x33\x02\u{70b}\u{709}\x03\
	\x02\x02\x02\u{70b}\u{70a}\x03\x02\x02\x02\u{70b}\u{70c}\x03\x02\x02\x02\
	\u{70c}\u{720}\x03\x02\x02\x02\u{70d}\u{70f}\x07\x07\x02\x02\u{70e}\u{70d}\
	\x03\x02\x02\x02\u{70f}\u{712}\x03\x02\x02\x02\u{710}\u{70e}\x03\x02\x02\
	\x02\u{710}\u{711}\x03\x02\x02\x02\u{711}\u{713}\x03\x02\x02\x02\u{712}\
	\u{710}\x03\x02\x02\x02\u{713}\u{717}\x07\x0a\x02\x02\u{714}\u{716}\x07\
	\x07\x02\x02\u{715}\u{714}\x03\x02\x02\x02\u{716}\u{719}\x03\x02\x02\x02\
	\u{717}\u{715}\x03\x02\x02\x02\u{717}\u{718}\x03\x02\x02\x02\u{718}\u{71c}\
	\x03\x02\x02\x02\u{719}\u{717}\x03\x02\x02\x02\u{71a}\u{71d}\x05\x56\x2c\
	\x02\u{71b}\u{71d}\x05\x64\x33\x02\u{71c}\u{71a}\x03\x02\x02\x02\u{71c}\
	\u{71b}\x03\x02\x02\x02\u{71d}\u{71f}\x03\x02\x02\x02\u{71e}\u{710}\x03\
	\x02\x02\x02\u{71f}\u{722}\x03\x02\x02\x02\u{720}\u{71e}\x03\x02\x02\x02\
	\u{720}\u{721}\x03\x02\x02\x02\u{721}\u{72a}\x03\x02\x02\x02\u{722}\u{720}\
	\x03\x02\x02\x02\u{723}\u{725}\x07\x07\x02\x02\u{724}\u{723}\x03\x02\x02\
	\x02\u{725}\u{728}\x03\x02\x02\x02\u{726}\u{724}\x03\x02\x02\x02\u{726}\
	\u{727}\x03\x02\x02\x02\u{727}\u{729}\x03\x02\x02\x02\u{728}\u{726}\x03\
	\x02\x02\x02\u{729}\u{72b}\x07\x0a\x02\x02\u{72a}\u{726}\x03\x02\x02\x02\
	\u{72a}\u{72b}\x03\x02\x02\x02\u{72b}\u{72f}\x03\x02\x02\x02\u{72c}\u{72e}\
	\x07\x07\x02\x02\u{72d}\u{72c}\x03\x02\x02\x02\u{72e}\u{731}\x03\x02\x02\
	\x02\u{72f}\u{72d}\x03\x02\x02\x02\u{72f}\u{730}\x03\x02\x02\x02\u{730}\
	\u{732}\x03\x02\x02\x02\u{731}\u{72f}\x03\x02\x02\x02\u{732}\u{733}\x07\
	\x0c\x02\x02\u{733}\x79\x03\x02\x02\x02\u{734}\u{738}\x07\x0b\x02\x02\u{735}\
	\u{737}\x07\x07\x02\x02\u{736}\u{735}\x03\x02\x02\x02\u{737}\u{73a}\x03\
	\x02\x02\x02\u{738}\u{736}\x03\x02\x02\x02\u{738}\u{739}\x03\x02\x02\x02\
	\u{739}\u{73b}\x03\x02\x02\x02\u{73a}\u{738}\x03\x02\x02\x02\u{73b}\u{73f}\
	\x05\x64\x33\x02\u{73c}\u{73e}\x07\x07\x02\x02\u{73d}\u{73c}\x03\x02\x02\
	\x02\u{73e}\u{741}\x03\x02\x02\x02\u{73f}\u{73d}\x03\x02\x02\x02\u{73f}\
	\u{740}\x03\x02\x02\x02\u{740}\u{742}\x03\x02\x02\x02\u{741}\u{73f}\x03\
	\x02\x02\x02\u{742}\u{743}\x07\x0c\x02\x02\u{743}\x7b\x03\x02\x02\x02\u{744}\
	\u{746}\x05\u{132}\u{9a}\x02\u{745}\u{744}\x03\x02\x02\x02\u{745}\u{746}\
	\x03\x02\x02\x02\u{746}\u{74a}\x03\x02\x02\x02\u{747}\u{74b}\x05\x7a\x3e\
	\x02\u{748}\u{74b}\x05\x68\x35\x02\u{749}\u{74b}\x05\x66\x34\x02\u{74a}\
	\u{747}\x03\x02\x02\x02\u{74a}\u{748}\x03\x02\x02\x02\u{74a}\u{749}\x03\
	\x02\x02\x02\u{74b}\x7d\x03\x02\x02\x02\u{74c}\u{750}\x07\x0b\x02\x02\u{74d}\
	\u{74f}\x07\x07\x02\x02\u{74e}\u{74d}\x03\x02\x02\x02\u{74f}\u{752}\x03\
	\x02\x02\x02\u{750}\u{74e}\x03\x02\x02\x02\u{750}\u{751}\x03\x02\x02\x02\
	\u{751}\u{755}\x03\x02\x02\x02\u{752}\u{750}\x03\x02\x02\x02\u{753}\u{756}\
	\x05\x6c\x37\x02\u{754}\u{756}\x05\x7e\x40\x02\u{755}\u{753}\x03\x02\x02\
	\x02\u{755}\u{754}\x03\x02\x02\x02\u{756}\u{75a}\x03\x02\x02\x02\u{757}\
	\u{759}\x07\x07\x02\x02\u{758}\u{757}\x03\x02\x02\x02\u{759}\u{75c}\x03\
	\x02\x02\x02\u{75a}\u{758}\x03\x02\x02\x02\u{75a}\u{75b}\x03\x02\x02\x02\
	\u{75b}\u{75d}\x03\x02\x02\x02\u{75c}\u{75a}\x03\x02\x02\x02\u{75d}\u{75e}\
	\x07\x0c\x02\x02\u{75e}\x7f\x03\x02\x02\x02\u{75f}\u{765}\x05\u{82}\x42\
	\x02\u{760}\u{761}\x05\u{96}\x4c\x02\u{761}\u{762}\x05\u{82}\x42\x02\u{762}\
	\u{764}\x03\x02\x02\x02\u{763}\u{760}\x03\x02\x02\x02\u{764}\u{767}\x03\
	\x02\x02\x02\u{765}\u{763}\x03\x02\x02\x02\u{765}\u{766}\x03\x02\x02\x02\
	\u{766}\u{769}\x03\x02\x02\x02\u{767}\u{765}\x03\x02\x02\x02\u{768}\u{75f}\
	\x03\x02\x02\x02\u{768}\u{769}\x03\x02\x02\x02\u{769}\u{76b}\x03\x02\x02\
	\x02\u{76a}\u{76c}\x05\u{96}\x4c\x02\u{76b}\u{76a}\x03\x02\x02\x02\u{76b}\
	\u{76c}\x03\x02\x02\x02\u{76c}\u{81}\x03\x02\x02\x02\u{76d}\u{770}\x05\u{84}\
	\x43\x02\u{76e}\u{770}\x05\u{14e}\u{a8}\x02\u{76f}\u{76d}\x03\x02\x02\x02\
	\u{76f}\u{76e}\x03\x02\x02\x02\u{770}\u{773}\x03\x02\x02\x02\u{771}\u{76f}\
	\x03\x02\x02\x02\u{771}\u{772}\x03\x02\x02\x02\u{772}\u{778}\x03\x02\x02\
	\x02\u{773}\u{771}\x03\x02\x02\x02\u{774}\u{779}\x05\x16\x0c\x02\u{775}\
	\u{779}\x05\u{92}\x4a\x02\u{776}\u{779}\x05\u{8a}\x46\x02\u{777}\u{779}\
	\x05\u{98}\x4d\x02\u{778}\u{774}\x03\x02\x02\x02\u{778}\u{775}\x03\x02\x02\
	\x02\u{778}\u{776}\x03\x02\x02\x02\u{778}\u{777}\x03\x02\x02\x02\u{779}\
	\u{83}\x03\x02\x02\x02\u{77a}\u{77b}\x05\u{158}\u{ad}\x02\u{77b}\u{77f}\
	\x09\x06\x02\x02\u{77c}\u{77e}\x07\x07\x02\x02\u{77d}\u{77c}\x03\x02\x02\
	\x02\u{77e}\u{781}\x03\x02\x02\x02\u{77f}\u{77d}\x03\x02\x02\x02\u{77f}\
	\u{780}\x03\x02\x02\x02\u{780}\u{85}\x03\x02\x02\x02\u{781}\u{77f}\x03\x02\
	\x02\x02\u{782}\u{785}\x05\u{88}\x45\x02\u{783}\u{785}\x05\u{82}\x42\x02\
	\u{784}\u{782}\x03\x02\x02\x02\u{784}\u{783}\x03\x02\x02\x02\u{785}\u{87}\
	\x03\x02\x02\x02\u{786}\u{78a}\x07\x0f\x02\x02\u{787}\u{789}\x07\x07\x02\
	\x02\u{788}\u{787}\x03\x02\x02\x02\u{789}\u{78c}\x03\x02\x02\x02\u{78a}\
	\u{788}\x03\x02\x02\x02\u{78a}\u{78b}\x03\x02\x02\x02\u{78b}\u{78d}\x03\
	\x02\x02\x02\u{78c}\u{78a}\x03\x02\x02\x02\u{78d}\u{791}\x05\u{80}\x41\x02\
	\u{78e}\u{790}\x07\x07\x02\x02\u{78f}\u{78e}\x03\x02\x02\x02\u{790}\u{793}\
	\x03\x02\x02\x02\u{791}\u{78f}\x03\x02\x02\x02\u{791}\u{792}\x03\x02\x02\
	\x02\u{792}\u{794}\x03\x02\x02\x02\u{793}\u{791}\x03\x02\x02\x02\u{794}\
	\u{795}\x07\x10\x02\x02\u{795}\u{89}\x03\x02\x02\x02\u{796}\u{79a}\x05\u{8c}\
	\x47\x02\u{797}\u{79a}\x05\u{8e}\x48\x02\u{798}\u{79a}\x05\u{90}\x49\x02\
	\u{799}\u{796}\x03\x02\x02\x02\u{799}\u{797}\x03\x02\x02\x02\u{799}\u{798}\
	\x03\x02\x02\x02\u{79a}\u{8b}\x03\x02\x02\x02\u{79b}\u{79f}\x07\x5f\x02\
	\x02\u{79c}\u{79e}\x07\x07\x02\x02\u{79d}\u{79c}\x03\x02\x02\x02\u{79e}\
	\u{7a1}\x03\x02\x02\x02\u{79f}\u{79d}\x03\x02\x02\x02\u{79f}\u{7a0}\x03\
	\x02\x02\x02\u{7a0}\u{7a2}\x03\x02\x02\x02\u{7a1}\u{79f}\x03\x02\x02\x02\
	\u{7a2}\u{7a6}\x07\x0b\x02\x02\u{7a3}\u{7a5}\x05\u{14e}\u{a8}\x02\u{7a4}\
	\u{7a3}\x03\x02\x02\x02\u{7a5}\u{7a8}\x03\x02\x02\x02\u{7a6}\u{7a4}\x03\
	\x02\x02\x02\u{7a6}\u{7a7}\x03\x02\x02\x02\u{7a7}\u{7ab}\x03\x02\x02\x02\
	\u{7a8}\u{7a6}\x03\x02\x02\x02\u{7a9}\u{7ac}\x05\x44\x23\x02\u{7aa}\u{7ac}\
	\x05\x46\x24\x02\u{7ab}\u{7a9}\x03\x02\x02\x02\u{7ab}\u{7aa}\x03\x02\x02\
	\x02\u{7ac}\u{7ad}\x03\x02\x02\x02\u{7ad}\u{7ae}\x07\x68\x02\x02\u{7ae}\
	\u{7af}\x05\u{98}\x4d\x02\u{7af}\u{7b3}\x07\x0c\x02\x02\u{7b0}\u{7b2}\x07\
	\x07\x02\x02\u{7b1}\u{7b0}\x03\x02\x02\x02\u{7b2}\u{7b5}\x03\x02\x02\x02\
	\u{7b3}\u{7b1}\x03\x02\x02\x02\u{7b3}\u{7b4}\x03\x02\x02\x02\u{7b4}\u{7b7}\
	\x03\x02\x02\x02\u{7b5}\u{7b3}\x03\x02\x02\x02\u{7b6}\u{7b8}\x05\u{86}\x44\
	\x02\u{7b7}\u{7b6}\x03\x02\x02\x02\u{7b7}\u{7b8}\x03\x02\x02\x02\u{7b8}\
	\u{8d}\x03\x02\x02\x02\u{7b9}\u{7bd}\x07\x61\x02\x02\u{7ba}\u{7bc}\x07\x07\
	\x02\x02\u{7bb}\u{7ba}\x03\x02\x02\x02\u{7bc}\u{7bf}\x03\x02\x02\x02\u{7bd}\
	\u{7bb}\x03\x02\x02\x02\u{7bd}\u{7be}\x03\x02\x02\x02\u{7be}\u{7c0}\x03\
	\x02\x02\x02\u{7bf}\u{7bd}\x03\x02\x02\x02\u{7c0}\u{7c1}\x07\x0b\x02\x02\
	\u{7c1}\u{7c2}\x05\u{98}\x4d\x02\u{7c2}\u{7c6}\x07\x0c\x02\x02\u{7c3}\u{7c5}\
	\x07\x07\x02\x02\u{7c4}\u{7c3}\x03\x02\x02\x02\u{7c5}\u{7c8}\x03\x02\x02\
	\x02\u{7c6}\u{7c4}\x03\x02\x02\x02\u{7c6}\u{7c7}\x03\x02\x02\x02\u{7c7}\
	\u{7cb}\x03\x02\x02\x02\u{7c8}\u{7c6}\x03\x02\x02\x02\u{7c9}\u{7cc}\x05\
	\u{86}\x44\x02\u{7ca}\u{7cc}\x07\x1d\x02\x02\u{7cb}\u{7c9}\x03\x02\x02\x02\
	\u{7cb}\u{7ca}\x03\x02\x02\x02\u{7cc}\u{8f}\x03\x02\x02\x02\u{7cd}\u{7d1}\
	\x07\x60\x02\x02\u{7ce}\u{7d0}\x07\x07\x02\x02\u{7cf}\u{7ce}\x03\x02\x02\
	\x02\u{7d0}\u{7d3}\x03\x02\x02\x02\u{7d1}\u{7cf}\x03\x02\x02\x02\u{7d1}\
	\u{7d2}\x03\x02\x02\x02\u{7d2}\u{7d5}\x03\x02\x02\x02\u{7d3}\u{7d1}\x03\
	\x02\x02\x02\u{7d4}\u{7d6}\x05\u{86}\x44\x02\u{7d5}\u{7d4}\x03\x02\x02\x02\
	\u{7d5}\u{7d6}\x03\x02\x02\x02\u{7d6}\u{7da}\x03\x02\x02\x02\u{7d7}\u{7d9}\
	\x07\x07\x02\x02\u{7d8}\u{7d7}\x03\x02\x02\x02\u{7d9}\u{7dc}\x03\x02\x02\
	\x02\u{7da}\u{7d8}\x03\x02\x02\x02\u{7da}\u{7db}\x03\x02\x02\x02\u{7db}\
	\u{7dd}\x03\x02\x02\x02\u{7dc}\u{7da}\x03\x02\x02\x02\u{7dd}\u{7e1}\x07\
	\x61\x02\x02\u{7de}\u{7e0}\x07\x07\x02\x02\u{7df}\u{7de}\x03\x02\x02\x02\
	\u{7e0}\u{7e3}\x03\x02\x02\x02\u{7e1}\u{7df}\x03\x02\x02\x02\u{7e1}\u{7e2}\
	\x03\x02\x02\x02\u{7e2}\u{7e4}\x03\x02\x02\x02\u{7e3}\u{7e1}\x03\x02\x02\
	\x02\u{7e4}\u{7e5}\x07\x0b\x02\x02\u{7e5}\u{7e6}\x05\u{98}\x4d\x02\u{7e6}\
	\u{7e7}\x07\x0c\x02\x02\u{7e7}\u{91}\x03\x02\x02\x02\u{7e8}\u{7e9}\x05\u{bc}\
	\x5f\x02\u{7e9}\u{7ea}\x07\x1e\x02\x02\u{7ea}\u{7ef}\x03\x02\x02\x02\u{7eb}\
	\u{7ec}\x05\u{c0}\x61\x02\u{7ec}\u{7ed}\x05\u{112}\u{8a}\x02\u{7ed}\u{7ef}\
	\x03\x02\x02\x02\u{7ee}\u{7e8}\x03\x02\x02\x02\u{7ee}\u{7eb}\x03\x02\x02\
	\x02\u{7ef}\u{7f3}\x03\x02\x02\x02\u{7f0}\u{7f2}\x07\x07\x02\x02\u{7f1}\
	\u{7f0}\x03\x02\x02\x02\u{7f2}\u{7f5}\x03\x02\x02\x02\u{7f3}\u{7f1}\x03\
	\x02\x02\x02\u{7f3}\u{7f4}\x03\x02\x02\x02\u{7f4}\u{7f6}\x03\x02\x02\x02\
	\u{7f5}\u{7f3}\x03\x02\x02\x02\u{7f6}\u{7f7}\x05\u{98}\x4d\x02\u{7f7}\u{93}\
	\x03\x02\x02\x02\u{7f8}\u{7fc}\x09\x07\x02\x02\u{7f9}\u{7fb}\x07\x07\x02\
	\x02\u{7fa}\u{7f9}\x03\x02\x02\x02\u{7fb}\u{7fe}\x03\x02\x02\x02\u{7fc}\
	\u{7fa}\x03\x02\x02\x02\u{7fc}\u{7fd}\x03\x02\x02\x02\u{7fd}\u{801}\x03\
	\x02\x02\x02\u{7fe}\u{7fc}\x03\x02\x02\x02\u{7ff}\u{801}\x07\x02\x02\x03\
	\u{800}\u{7f8}\x03\x02\x02\x02\u{800}\u{7ff}\x03\x02\x02\x02\u{801}\u{95}\
	\x03\x02\x02\x02\u{802}\u{804}\x09\x07\x02\x02\u{803}\u{802}\x03\x02\x02\
	\x02\u{804}\u{805}\x03\x02\x02\x02\u{805}\u{803}\x03\x02\x02\x02\u{805}\
	\u{806}\x03\x02\x02\x02\u{806}\u{809}\x03\x02\x02\x02\u{807}\u{809}\x07\
	\x02\x02\x03\u{808}\u{803}\x03\x02\x02\x02\u{808}\u{807}\x03\x02\x02\x02\
	\u{809}\u{97}\x03\x02\x02\x02\u{80a}\u{80b}\x05\u{9a}\x4e\x02\u{80b}\u{99}\
	\x03\x02\x02\x02\u{80c}\u{81d}\x05\u{9c}\x4f\x02\u{80d}\u{80f}\x07\x07\x02\
	\x02\u{80e}\u{80d}\x03\x02\x02\x02\u{80f}\u{812}\x03\x02\x02\x02\u{810}\
	\u{80e}\x03\x02\x02\x02\u{810}\u{811}\x03\x02\x02\x02\u{811}\u{813}\x03\
	\x02\x02\x02\u{812}\u{810}\x03\x02\x02\x02\u{813}\u{817}\x07\x19\x02\x02\
	\u{814}\u{816}\x07\x07\x02\x02\u{815}\u{814}\x03\x02\x02\x02\u{816}\u{819}\
	\x03\x02\x02\x02\u{817}\u{815}\x03\x02\x02\x02\u{817}\u{818}\x03\x02\x02\
	\x02\u{818}\u{81a}\x03\x02\x02\x02\u{819}\u{817}\x03\x02\x02\x02\u{81a}\
	\u{81c}\x05\u{9c}\x4f\x02\u{81b}\u{810}\x03\x02\x02\x02\u{81c}\u{81f}\x03\
	\x02\x02\x02\u{81d}\u{81b}\x03\x02\x02\x02\u{81d}\u{81e}\x03\x02\x02\x02\
	\u{81e}\u{9b}\x03\x02\x02\x02\u{81f}\u{81d}\x03\x02\x02\x02\u{820}\u{831}\
	\x05\u{9e}\x50\x02\u{821}\u{823}\x07\x07\x02\x02\u{822}\u{821}\x03\x02\x02\
	\x02\u{823}\u{826}\x03\x02\x02\x02\u{824}\u{822}\x03\x02\x02\x02\u{824}\
	\u{825}\x03\x02\x02\x02\u{825}\u{827}\x03\x02\x02\x02\u{826}\u{824}\x03\
	\x02\x02\x02\u{827}\u{82b}\x07\x18\x02\x02\u{828}\u{82a}\x07\x07\x02\x02\
	\u{829}\u{828}\x03\x02\x02\x02\u{82a}\u{82d}\x03\x02\x02\x02\u{82b}\u{829}\
	\x03\x02\x02\x02\u{82b}\u{82c}\x03\x02\x02\x02\u{82c}\u{82e}\x03\x02\x02\
	\x02\u{82d}\u{82b}\x03\x02\x02\x02\u{82e}\u{830}\x05\u{9e}\x50\x02\u{82f}\
	\u{824}\x03\x02\x02\x02\u{830}\u{833}\x03\x02\x02\x02\u{831}\u{82f}\x03\
	\x02\x02\x02\u{831}\u{832}\x03\x02\x02\x02\u{832}\u{9d}\x03\x02\x02\x02\
	\u{833}\u{831}\x03\x02\x02\x02\u{834}\u{840}\x05\u{a0}\x51\x02\u{835}\u{839}\
	\x05\u{114}\u{8b}\x02\u{836}\u{838}\x07\x07\x02\x02\u{837}\u{836}\x03\x02\
	\x02\x02\u{838}\u{83b}\x03\x02\x02\x02\u{839}\u{837}\x03\x02\x02\x02\u{839}\
	\u{83a}\x03\x02\x02\x02\u{83a}\u{83c}\x03\x02\x02\x02\u{83b}\u{839}\x03\
	\x02\x02\x02\u{83c}\u{83d}\x05\u{a0}\x51\x02\u{83d}\u{83f}\x03\x02\x02\x02\
	\u{83e}\u{835}\x03\x02\x02\x02\u{83f}\u{842}\x03\x02\x02\x02\u{840}\u{83e}\
	\x03\x02\x02\x02\u{840}\u{841}\x03\x02\x02\x02\u{841}\u{9f}\x03\x02\x02\
	\x02\u{842}\u{840}\x03\x02\x02\x02\u{843}\u{84f}\x05\u{a2}\x52\x02\u{844}\
	\u{848}\x05\u{116}\u{8c}\x02\u{845}\u{847}\x07\x07\x02\x02\u{846}\u{845}\
	\x03\x02\x02\x02\u{847}\u{84a}\x03\x02\x02\x02\u{848}\u{846}\x03\x02\x02\
	\x02\u{848}\u{849}\x03\x02\x02\x02\u{849}\u{84b}\x03\x02\x02\x02\u{84a}\
	\u{848}\x03\x02\x02\x02\u{84b}\u{84c}\x05\u{a2}\x52\x02\u{84c}\u{84e}\x03\
	\x02\x02\x02\u{84d}\u{844}\x03\x02\x02\x02\u{84e}\u{851}\x03\x02\x02\x02\
	\u{84f}\u{84d}\x03\x02\x02\x02\u{84f}\u{850}\x03\x02\x02\x02\u{850}\u{a1}\
	\x03\x02\x02\x02\u{851}\u{84f}\x03\x02\x02\x02\u{852}\u{856}\x05\u{a4}\x53\
	\x02\u{853}\u{855}\x05\u{ca}\x66\x02\u{854}\u{853}\x03\x02\x02\x02\u{855}\
	\u{858}\x03\x02\x02\x02\u{856}\u{854}\x03\x02\x02\x02\u{856}\u{857}\x03\
	\x02\x02\x02\u{857}\u{a3}\x03\x02\x02\x02\u{858}\u{856}\x03\x02\x02\x02\
	\u{859}\u{86e}\x05\u{a6}\x54\x02\u{85a}\u{85e}\x05\u{118}\u{8d}\x02\u{85b}\
	\u{85d}\x07\x07\x02\x02\u{85c}\u{85b}\x03\x02\x02\x02\u{85d}\u{860}\x03\
	\x02\x02\x02\u{85e}\u{85c}\x03\x02\x02\x02\u{85e}\u{85f}\x03\x02\x02\x02\
	\u{85f}\u{861}\x03\x02\x02\x02\u{860}\u{85e}\x03\x02\x02\x02\u{861}\u{862}\
	\x05\u{a6}\x54\x02\u{862}\u{86d}\x03\x02\x02\x02\u{863}\u{867}\x05\u{11a}\
	\u{8e}\x02\u{864}\u{866}\x07\x07\x02\x02\u{865}\u{864}\x03\x02\x02\x02\u{866}\
	\u{869}\x03\x02\x02\x02\u{867}\u{865}\x03\x02\x02\x02\u{867}\u{868}\x03\
	\x02\x02\x02\u{868}\u{86a}\x03\x02\x02\x02\u{869}\u{867}\x03\x02\x02\x02\
	\u{86a}\u{86b}\x05\x64\x33\x02\u{86b}\u{86d}\x03\x02\x02\x02\u{86c}\u{85a}\
	\x03\x02\x02\x02\u{86c}\u{863}\x03\x02\x02\x02\u{86d}\u{870}\x03\x02\x02\
	\x02\u{86e}\u{86c}\x03\x02\x02\x02\u{86e}\u{86f}\x03\x02\x02\x02\u{86f}\
	\u{a5}\x03\x02\x02\x02\u{870}\u{86e}\x03\x02\x02\x02\u{871}\u{883}\x05\u{aa}\
	\x56\x02\u{872}\u{874}\x07\x07\x02\x02\u{873}\u{872}\x03\x02\x02\x02\u{874}\
	\u{877}\x03\x02\x02\x02\u{875}\u{873}\x03\x02\x02\x02\u{875}\u{876}\x03\
	\x02\x02\x02\u{876}\u{878}\x03\x02\x02\x02\u{877}\u{875}\x03\x02\x02\x02\
	\u{878}\u{87c}\x05\u{a8}\x55\x02\u{879}\u{87b}\x07\x07\x02\x02\u{87a}\u{879}\
	\x03\x02\x02\x02\u{87b}\u{87e}\x03\x02\x02\x02\u{87c}\u{87a}\x03\x02\x02\
	\x02\u{87c}\u{87d}\x03\x02\x02\x02\u{87d}\u{87f}\x03\x02\x02\x02\u{87e}\
	\u{87c}\x03\x02\x02\x02\u{87f}\u{880}\x05\u{aa}\x56\x02\u{880}\u{882}\x03\
	\x02\x02\x02\u{881}\u{875}\x03\x02\x02\x02\u{882}\u{885}\x03\x02\x02\x02\
	\u{883}\u{881}\x03\x02\x02\x02\u{883}\u{884}\x03\x02\x02\x02\u{884}\u{a7}\
	\x03\x02\x02\x02\u{885}\u{883}\x03\x02\x02\x02\u{886}\u{887}\x07\x2f\x02\
	\x02\u{887}\u{888}\x07\x1c\x02\x02\u{888}\u{a9}\x03\x02\x02\x02\u{889}\u{895}\
	\x05\u{ac}\x57\x02\u{88a}\u{88e}\x05\u{158}\u{ad}\x02\u{88b}\u{88d}\x07\
	\x07\x02\x02\u{88c}\u{88b}\x03\x02\x02\x02\u{88d}\u{890}\x03\x02\x02\x02\
	\u{88e}\u{88c}\x03\x02\x02\x02\u{88e}\u{88f}\x03\x02\x02\x02\u{88f}\u{891}\
	\x03\x02\x02\x02\u{890}\u{88e}\x03\x02\x02\x02\u{891}\u{892}\x05\u{ac}\x57\
	\x02\u{892}\u{894}\x03\x02\x02\x02\u{893}\u{88a}\x03\x02\x02\x02\u{894}\
	\u{897}\x03\x02\x02\x02\u{895}\u{893}\x03\x02\x02\x02\u{895}\u{896}\x03\
	\x02\x02\x02\u{896}\u{ab}\x03\x02\x02\x02\u{897}\u{895}\x03\x02\x02\x02\
	\u{898}\u{8a3}\x05\u{ae}\x58\x02\u{899}\u{89d}\x07\x26\x02\x02\u{89a}\u{89c}\
	\x07\x07\x02\x02\u{89b}\u{89a}\x03\x02\x02\x02\u{89c}\u{89f}\x03\x02\x02\
	\x02\u{89d}\u{89b}\x03\x02\x02\x02\u{89d}\u{89e}\x03\x02\x02\x02\u{89e}\
	\u{8a0}\x03\x02\x02\x02\u{89f}\u{89d}\x03\x02\x02\x02\u{8a0}\u{8a2}\x05\
	\u{ae}\x58\x02\u{8a1}\u{899}\x03\x02\x02\x02\u{8a2}\u{8a5}\x03\x02\x02\x02\
	\u{8a3}\u{8a1}\x03\x02\x02\x02\u{8a3}\u{8a4}\x03\x02\x02\x02\u{8a4}\u{ad}\
	\x03\x02\x02\x02\u{8a5}\u{8a3}\x03\x02\x02\x02\u{8a6}\u{8b2}\x05\u{b0}\x59\
	\x02\u{8a7}\u{8ab}\x05\u{11c}\u{8f}\x02\u{8a8}\u{8aa}\x07\x07\x02\x02\u{8a9}\
	\u{8a8}\x03\x02\x02\x02\u{8aa}\u{8ad}\x03\x02\x02\x02\u{8ab}\u{8a9}\x03\
	\x02\x02\x02\u{8ab}\u{8ac}\x03\x02\x02\x02\u{8ac}\u{8ae}\x03\x02\x02\x02\
	\u{8ad}\u{8ab}\x03\x02\x02\x02\u{8ae}\u{8af}\x05\u{b0}\x59\x02\u{8af}\u{8b1}\
	\x03\x02\x02\x02\u{8b0}\u{8a7}\x03\x02\x02\x02\u{8b1}\u{8b4}\x03\x02\x02\
	\x02\u{8b2}\u{8b0}\x03\x02\x02\x02\u{8b2}\u{8b3}\x03\x02\x02\x02\u{8b3}\
	\u{af}\x03\x02\x02\x02\u{8b4}\u{8b2}\x03\x02\x02\x02\u{8b5}\u{8c1}\x05\u{b2}\
	\x5a\x02\u{8b6}\u{8ba}\x05\u{11e}\u{90}\x02\u{8b7}\u{8b9}\x07\x07\x02\x02\
	\u{8b8}\u{8b7}\x03\x02\x02\x02\u{8b9}\u{8bc}\x03\x02\x02\x02\u{8ba}\u{8b8}\
	\x03\x02\x02\x02\u{8ba}\u{8bb}\x03\x02\x02\x02\u{8bb}\u{8bd}\x03\x02\x02\
	\x02\u{8bc}\u{8ba}\x03\x02\x02\x02\u{8bd}\u{8be}\x05\u{b2}\x5a\x02\u{8be}\
	\u{8c0}\x03\x02\x02\x02\u{8bf}\u{8b6}\x03\x02\x02\x02\u{8c0}\u{8c3}\x03\
	\x02\x02\x02\u{8c1}\u{8bf}\x03\x02\x02\x02\u{8c1}\u{8c2}\x03\x02\x02\x02\
	\u{8c2}\u{b1}\x03\x02\x02\x02\u{8c3}\u{8c1}\x03\x02\x02\x02\u{8c4}\u{8d6}\
	\x05\u{b4}\x5b\x02\u{8c5}\u{8c7}\x07\x07\x02\x02\u{8c6}\u{8c5}\x03\x02\x02\
	\x02\u{8c7}\u{8ca}\x03\x02\x02\x02\u{8c8}\u{8c6}\x03\x02\x02\x02\u{8c8}\
	\u{8c9}\x03\x02\x02\x02\u{8c9}\u{8cb}\x03\x02\x02\x02\u{8ca}\u{8c8}\x03\
	\x02\x02\x02\u{8cb}\u{8cf}\x05\u{120}\u{91}\x02\u{8cc}\u{8ce}\x07\x07\x02\
	\x02\u{8cd}\u{8cc}\x03\x02\x02\x02\u{8ce}\u{8d1}\x03\x02\x02\x02\u{8cf}\
	\u{8cd}\x03\x02\x02\x02\u{8cf}\u{8d0}\x03\x02\x02\x02\u{8d0}\u{8d2}\x03\
	\x02\x02\x02\u{8d1}\u{8cf}\x03\x02\x02\x02\u{8d2}\u{8d3}\x05\x64\x33\x02\
	\u{8d3}\u{8d5}\x03\x02\x02\x02\u{8d4}\u{8c8}\x03\x02\x02\x02\u{8d5}\u{8d8}\
	\x03\x02\x02\x02\u{8d6}\u{8d4}\x03\x02\x02\x02\u{8d6}\u{8d7}\x03\x02\x02\
	\x02\u{8d7}\u{b3}\x03\x02\x02\x02\u{8d8}\u{8d6}\x03\x02\x02\x02\u{8d9}\u{8db}\
	\x05\u{b6}\x5c\x02\u{8da}\u{8d9}\x03\x02\x02\x02\u{8db}\u{8de}\x03\x02\x02\
	\x02\u{8dc}\u{8da}\x03\x02\x02\x02\u{8dc}\u{8dd}\x03\x02\x02\x02\u{8dd}\
	\u{8df}\x03\x02\x02\x02\u{8de}\u{8dc}\x03\x02\x02\x02\u{8df}\u{8e0}\x05\
	\u{b8}\x5d\x02\u{8e0}\u{b5}\x03\x02\x02\x02\u{8e1}\u{8eb}\x05\u{14e}\u{a8}\
	\x02\u{8e2}\u{8eb}\x05\u{84}\x43\x02\u{8e3}\u{8e7}\x05\u{122}\u{92}\x02\
	\u{8e4}\u{8e6}\x07\x07\x02\x02\u{8e5}\u{8e4}\x03\x02\x02\x02\u{8e6}\u{8e9}\
	\x03\x02\x02\x02\u{8e7}\u{8e5}\x03\x02\x02\x02\u{8e7}\u{8e8}\x03\x02\x02\
	\x02\u{8e8}\u{8eb}\x03\x02\x02\x02\u{8e9}\u{8e7}\x03\x02\x02\x02\u{8ea}\
	\u{8e1}\x03\x02\x02\x02\u{8ea}\u{8e2}\x03\x02\x02\x02\u{8ea}\u{8e3}\x03\
	\x02\x02\x02\u{8eb}\u{b7}\x03\x02\x02\x02\u{8ec}\u{8f0}\x05\u{d4}\x6b\x02\
	\u{8ed}\u{8ef}\x05\u{ba}\x5e\x02\u{8ee}\u{8ed}\x03\x02\x02\x02\u{8ef}\u{8f2}\
	\x03\x02\x02\x02\u{8f0}\u{8ee}\x03\x02\x02\x02\u{8f0}\u{8f1}\x03\x02\x02\
	\x02\u{8f1}\u{b9}\x03\x02\x02\x02\u{8f2}\u{8f0}\x03\x02\x02\x02\u{8f3}\u{8f9}\
	\x05\u{124}\u{93}\x02\u{8f4}\u{8f9}\x05\u{ce}\x68\x02\u{8f5}\u{8f9}\x05\
	\u{ca}\x66\x02\u{8f6}\u{8f9}\x05\u{c6}\x64\x02\u{8f7}\u{8f9}\x05\u{c8}\x65\
	\x02\u{8f8}\u{8f3}\x03\x02\x02\x02\u{8f8}\u{8f4}\x03\x02\x02\x02\u{8f8}\
	\u{8f5}\x03\x02\x02\x02\u{8f8}\u{8f6}\x03\x02\x02\x02\u{8f8}\u{8f7}\x03\
	\x02\x02\x02\u{8f9}\u{bb}\x03\x02\x02\x02\u{8fa}\u{8fb}\x05\u{b8}\x5d\x02\
	\u{8fb}\u{8fc}\x05\u{c4}\x63\x02\u{8fc}\u{900}\x03\x02\x02\x02\u{8fd}\u{900}\
	\x05\u{158}\u{ad}\x02\u{8fe}\u{900}\x05\u{be}\x60\x02\u{8ff}\u{8fa}\x03\
	\x02\x02\x02\u{8ff}\u{8fd}\x03\x02\x02\x02\u{8ff}\u{8fe}\x03\x02\x02\x02\
	\u{900}\u{bd}\x03\x02\x02\x02\u{901}\u{905}\x07\x0b\x02\x02\u{902}\u{904}\
	\x07\x07\x02\x02\u{903}\u{902}\x03\x02\x02\x02\u{904}\u{907}\x03\x02\x02\
	\x02\u{905}\u{903}\x03\x02\x02\x02\u{905}\u{906}\x03\x02\x02\x02\u{906}\
	\u{908}\x03\x02\x02\x02\u{907}\u{905}\x03\x02\x02\x02\u{908}\u{90c}\x05\
	\u{bc}\x5f\x02\u{909}\u{90b}\x07\x07\x02\x02\u{90a}\u{909}\x03\x02\x02\x02\
	\u{90b}\u{90e}\x03\x02\x02\x02\u{90c}\u{90a}\x03\x02\x02\x02\u{90c}\u{90d}\
	\x03\x02\x02\x02\u{90d}\u{90f}\x03\x02\x02\x02\u{90e}\u{90c}\x03\x02\x02\
	\x02\u{90f}\u{910}\x07\x0c\x02\x02\u{910}\u{bf}\x03\x02\x02\x02\u{911}\u{914}\
	\x05\u{b4}\x5b\x02\u{912}\u{914}\x05\u{c2}\x62\x02\u{913}\u{911}\x03\x02\
	\x02\x02\u{913}\u{912}\x03\x02\x02\x02\u{914}\u{c1}\x03\x02\x02\x02\u{915}\
	\u{919}\x07\x0b\x02\x02\u{916}\u{918}\x07\x07\x02\x02\u{917}\u{916}\x03\
	\x02\x02\x02\u{918}\u{91b}\x03\x02\x02\x02\u{919}\u{917}\x03\x02\x02\x02\
	\u{919}\u{91a}\x03\x02\x02\x02\u{91a}\u{91c}\x03\x02\x02\x02\u{91b}\u{919}\
	\x03\x02\x02\x02\u{91c}\u{920}\x05\u{c0}\x61\x02\u{91d}\u{91f}\x07\x07\x02\
	\x02\u{91e}\u{91d}\x03\x02\x02\x02\u{91f}\u{922}\x03\x02\x02\x02\u{920}\
	\u{91e}\x03\x02\x02\x02\u{920}\u{921}\x03\x02\x02\x02\u{921}\u{923}\x03\
	\x02\x02\x02\u{922}\u{920}\x03\x02\x02\x02\u{923}\u{924}\x07\x0c\x02\x02\
	\u{924}\u{c3}\x03\x02\x02\x02\u{925}\u{929}\x05\u{ce}\x68\x02\u{926}\u{929}\
	\x05\u{c6}\x64\x02\u{927}\u{929}\x05\u{c8}\x65\x02\u{928}\u{925}\x03\x02\
	\x02\x02\u{928}\u{926}\x03\x02\x02\x02\u{928}\u{927}\x03\x02\x02\x02\u{929}\
	\u{c5}\x03\x02\x02\x02\u{92a}\u{92e}\x07\x0d\x02\x02\u{92b}\u{92d}\x07\x07\
	\x02\x02\u{92c}\u{92b}\x03\x02\x02\x02\u{92d}\u{930}\x03\x02\x02\x02\u{92e}\
	\u{92c}\x03\x02\x02\x02\u{92e}\u{92f}\x03\x02\x02\x02\u{92f}\u{931}\x03\
	\x02\x02\x02\u{930}\u{92e}\x03\x02\x02\x02\u{931}\u{942}\x05\u{98}\x4d\x02\
	\u{932}\u{934}\x07\x07\x02\x02\u{933}\u{932}\x03\x02\x02\x02\u{934}\u{937}\
	\x03\x02\x02\x02\u{935}\u{933}\x03\x02\x02\x02\u{935}\u{936}\x03\x02\x02\
	\x02\u{936}\u{938}\x03\x02\x02\x02\u{937}\u{935}\x03\x02\x02\x02\u{938}\
	\u{93c}\x07\x0a\x02\x02\u{939}\u{93b}\x07\x07\x02\x02\u{93a}\u{939}\x03\
	\x02\x02\x02\u{93b}\u{93e}\x03\x02\x02\x02\u{93c}\u{93a}\x03\x02\x02\x02\
	\u{93c}\u{93d}\x03\x02\x02\x02\u{93d}\u{93f}\x03\x02\x02\x02\u{93e}\u{93c}\
	\x03\x02\x02\x02\u{93f}\u{941}\x05\u{98}\x4d\x02\u{940}\u{935}\x03\x02\x02\
	\x02\u{941}\u{944}\x03\x02\x02\x02\u{942}\u{940}\x03\x02\x02\x02\u{942}\
	\u{943}\x03\x02\x02\x02\u{943}\u{94c}\x03\x02\x02\x02\u{944}\u{942}\x03\
	\x02\x02\x02\u{945}\u{947}\x07\x07\x02\x02\u{946}\u{945}\x03\x02\x02\x02\
	\u{947}\u{94a}\x03\x02\x02\x02\u{948}\u{946}\x03\x02\x02\x02\u{948}\u{949}\
	\x03\x02\x02\x02\u{949}\u{94b}\x03\x02\x02\x02\u{94a}\u{948}\x03\x02\x02\
	\x02\u{94b}\u{94d}\x07\x0a\x02\x02\u{94c}\u{948}\x03\x02\x02\x02\u{94c}\
	\u{94d}\x03\x02\x02\x02\u{94d}\u{951}\x03\x02\x02\x02\u{94e}\u{950}\x07\
	\x07\x02\x02\u{94f}\u{94e}\x03\x02\x02\x02\u{950}\u{953}\x03\x02\x02\x02\
	\u{951}\u{94f}\x03\x02\x02\x02\u{951}\u{952}\x03\x02\x02\x02\u{952}\u{954}\
	\x03\x02\x02\x02\u{953}\u{951}\x03\x02\x02\x02\u{954}\u{955}\x07\x0e\x02\
	\x02\u{955}\u{c7}\x03\x02\x02\x02\u{956}\u{95a}\x05\u{128}\u{95}\x02\u{957}\
	\u{959}\x07\x07\x02\x02\u{958}\u{957}\x03\x02\x02\x02\u{959}\u{95c}\x03\
	\x02\x02\x02\u{95a}\u{958}\x03\x02\x02\x02\u{95a}\u{95b}\x03\x02\x02\x02\
	\u{95b}\u{960}\x03\x02\x02\x02\u{95c}\u{95a}\x03\x02\x02\x02\u{95d}\u{961}\
	\x05\u{158}\u{ad}\x02\u{95e}\u{961}\x05\u{d6}\x6c\x02\u{95f}\u{961}\x07\
	\x4a\x02\x02\u{960}\u{95d}\x03\x02\x02\x02\u{960}\u{95e}\x03\x02\x02\x02\
	\u{960}\u{95f}\x03\x02\x02\x02\u{961}\u{c9}\x03\x02\x02\x02\u{962}\u{964}\
	\x05\u{ce}\x68\x02\u{963}\u{962}\x03\x02\x02\x02\u{963}\u{964}\x03\x02\x02\
	\x02\u{964}\u{96a}\x03\x02\x02\x02\u{965}\u{967}\x05\u{d0}\x69\x02\u{966}\
	\u{965}\x03\x02\x02\x02\u{966}\u{967}\x03\x02\x02\x02\u{967}\u{968}\x03\
	\x02\x02\x02\u{968}\u{96b}\x05\u{cc}\x67\x02\u{969}\u{96b}\x05\u{d0}\x69\
	\x02\u{96a}\u{966}\x03\x02\x02\x02\u{96a}\u{969}\x03\x02\x02\x02\u{96b}\
	\u{cb}\x03\x02\x02\x02\u{96c}\u{96e}\x05\u{14e}\u{a8}\x02\u{96d}\u{96c}\
	\x03\x02\x02\x02\u{96e}\u{971}\x03\x02\x02\x02\u{96f}\u{96d}\x03\x02\x02\
	\x02\u{96f}\u{970}\x03\x02\x02\x02\u{970}\u{973}\x03\x02\x02\x02\u{971}\
	\u{96f}\x03\x02\x02\x02\u{972}\u{974}\x05\u{84}\x43\x02\u{973}\u{972}\x03\
	\x02\x02\x02\u{973}\u{974}\x03\x02\x02\x02\u{974}\u{978}\x03\x02\x02\x02\
	\u{975}\u{977}\x07\x07\x02\x02\u{976}\u{975}\x03\x02\x02\x02\u{977}\u{97a}\
	\x03\x02\x02\x02\u{978}\u{976}\x03\x02\x02\x02\u{978}\u{979}\x03\x02\x02\
	\x02\u{979}\u{97b}\x03\x02\x02\x02\u{97a}\u{978}\x03\x02\x02\x02\u{97b}\
	\u{97c}\x05\u{ea}\x76\x02\u{97c}\u{cd}\x03\x02\x02\x02\u{97d}\u{981}\x07\
	\x30\x02\x02\u{97e}\u{980}\x07\x07\x02\x02\u{97f}\u{97e}\x03\x02\x02\x02\
	\u{980}\u{983}\x03\x02\x02\x02\u{981}\u{97f}\x03\x02\x02\x02\u{981}\u{982}\
	\x03\x02\x02\x02\u{982}\u{984}\x03\x02\x02\x02\u{983}\u{981}\x03\x02\x02\
	\x02\u{984}\u{995}\x05\x70\x39\x02\u{985}\u{987}\x07\x07\x02\x02\u{986}\
	\u{985}\x03\x02\x02\x02\u{987}\u{98a}\x03\x02\x02\x02\u{988}\u{986}\x03\
	\x02\x02\x02\u{988}\u{989}\x03\x02\x02\x02\u{989}\u{98b}\x03\x02\x02\x02\
	\u{98a}\u{988}\x03\x02\x02\x02\u{98b}\u{98f}\x07\x0a\x02\x02\u{98c}\u{98e}\
	\x07\x07\x02\x02\u{98d}\u{98c}\x03\x02\x02\x02\u{98e}\u{991}\x03\x02\x02\
	\x02\u{98f}\u{98d}\x03\x02\x02\x02\u{98f}\u{990}\x03\x02\x02\x02\u{990}\
	\u{992}\x03\x02\x02\x02\u{991}\u{98f}\x03\x02\x02\x02\u{992}\u{994}\x05\
	\x70\x39\x02\u{993}\u{988}\x03\x02\x02\x02\u{994}\u{997}\x03\x02\x02\x02\
	\u{995}\u{993}\x03\x02\x02\x02\u{995}\u{996}\x03\x02\x02\x02\u{996}\u{99f}\
	\x03\x02\x02\x02\u{997}\u{995}\x03\x02\x02\x02\u{998}\u{99a}\x07\x07\x02\
	\x02\u{999}\u{998}\x03\x02\x02\x02\u{99a}\u{99d}\x03\x02\x02\x02\u{99b}\
	\u{999}\x03\x02\x02\x02\u{99b}\u{99c}\x03\x02\x02\x02\u{99c}\u{99e}\x03\
	\x02\x02\x02\u{99d}\u{99b}\x03\x02\x02\x02\u{99e}\u{9a0}\x07\x0a\x02\x02\
	\u{99f}\u{99b}\x03\x02\x02\x02\u{99f}\u{9a0}\x03\x02\x02\x02\u{9a0}\u{9a4}\
	\x03\x02\x02\x02\u{9a1}\u{9a3}\x07\x07\x02\x02\u{9a2}\u{9a1}\x03\x02\x02\
	\x02\u{9a3}\u{9a6}\x03\x02\x02\x02\u{9a4}\u{9a2}\x03\x02\x02\x02\u{9a4}\
	\u{9a5}\x03\x02\x02\x02\u{9a5}\u{9a7}\x03\x02\x02\x02\u{9a6}\u{9a4}\x03\
	\x02\x02\x02\u{9a7}\u{9a8}\x07\x31\x02\x02\u{9a8}\u{cf}\x03\x02\x02\x02\
	\u{9a9}\u{9ad}\x07\x0b\x02\x02\u{9aa}\u{9ac}\x07\x07\x02\x02\u{9ab}\u{9aa}\
	\x03\x02\x02\x02\u{9ac}\u{9af}\x03\x02\x02\x02\u{9ad}\u{9ab}\x03\x02\x02\
	\x02\u{9ad}\u{9ae}\x03\x02\x02\x02\u{9ae}\u{9d3}\x03\x02\x02\x02\u{9af}\
	\u{9ad}\x03\x02\x02\x02\u{9b0}\u{9c1}\x05\u{d2}\x6a\x02\u{9b1}\u{9b3}\x07\
	\x07\x02\x02\u{9b2}\u{9b1}\x03\x02\x02\x02\u{9b3}\u{9b6}\x03\x02\x02\x02\
	\u{9b4}\u{9b2}\x03\x02\x02\x02\u{9b4}\u{9b5}\x03\x02\x02\x02\u{9b5}\u{9b7}\
	\x03\x02\x02\x02\u{9b6}\u{9b4}\x03\x02\x02\x02\u{9b7}\u{9bb}\x07\x0a\x02\
	\x02\u{9b8}\u{9ba}\x07\x07\x02\x02\u{9b9}\u{9b8}\x03\x02\x02\x02\u{9ba}\
	\u{9bd}\x03\x02\x02\x02\u{9bb}\u{9b9}\x03\x02\x02\x02\u{9bb}\u{9bc}\x03\
	\x02\x02\x02\u{9bc}\u{9be}\x03\x02\x02\x02\u{9bd}\u{9bb}\x03\x02\x02\x02\
	\u{9be}\u{9c0}\x05\u{d2}\x6a\x02\u{9bf}\u{9b4}\x03\x02\x02\x02\u{9c0}\u{9c3}\
	\x03\x02\x02\x02\u{9c1}\u{9bf}\x03\x02\x02\x02\u{9c1}\u{9c2}\x03\x02\x02\
	\x02\u{9c2}\u{9cb}\x03\x02\x02\x02\u{9c3}\u{9c1}\x03\x02\x02\x02\u{9c4}\
	\u{9c6}\x07\x07\x02\x02\u{9c5}\u{9c4}\x03\x02\x02\x02\u{9c6}\u{9c9}\x03\
	\x02\x02\x02\u{9c7}\u{9c5}\x03\x02\x02\x02\u{9c7}\u{9c8}\x03\x02\x02\x02\
	\u{9c8}\u{9ca}\x03\x02\x02\x02\u{9c9}\u{9c7}\x03\x02\x02\x02\u{9ca}\u{9cc}\
	\x07\x0a\x02\x02\u{9cb}\u{9c7}\x03\x02\x02\x02\u{9cb}\u{9cc}\x03\x02\x02\
	\x02\u{9cc}\u{9d0}\x03\x02\x02\x02\u{9cd}\u{9cf}\x07\x07\x02\x02\u{9ce}\
	\u{9cd}\x03\x02\x02\x02\u{9cf}\u{9d2}\x03\x02\x02\x02\u{9d0}\u{9ce}\x03\
	\x02\x02\x02\u{9d0}\u{9d1}\x03\x02\x02\x02\u{9d1}\u{9d4}\x03\x02\x02\x02\
	\u{9d2}\u{9d0}\x03\x02\x02\x02\u{9d3}\u{9b0}\x03\x02\x02\x02\u{9d3}\u{9d4}\
	\x03\x02\x02\x02\u{9d4}\u{9d5}\x03\x02\x02\x02\u{9d5}\u{9d6}\x07\x0c\x02\
	\x02\u{9d6}\u{d1}\x03\x02\x02\x02\u{9d7}\u{9d9}\x05\u{14e}\u{a8}\x02\u{9d8}\
	\u{9d7}\x03\x02\x02\x02\u{9d8}\u{9d9}\x03\x02\x02\x02\u{9d9}\u{9dd}\x03\
	\x02\x02\x02\u{9da}\u{9dc}\x07\x07\x02\x02\u{9db}\u{9da}\x03\x02\x02\x02\
	\u{9dc}\u{9df}\x03\x02\x02\x02\u{9dd}\u{9db}\x03\x02\x02\x02\u{9dd}\u{9de}\
	\x03\x02\x02\x02\u{9de}\u{9ee}\x03\x02\x02\x02\u{9df}\u{9dd}\x03\x02\x02\
	\x02\u{9e0}\u{9e4}\x05\u{158}\u{ad}\x02\u{9e1}\u{9e3}\x07\x07\x02\x02\u{9e2}\
	\u{9e1}\x03\x02\x02\x02\u{9e3}\u{9e6}\x03\x02\x02\x02\u{9e4}\u{9e2}\x03\
	\x02\x02\x02\u{9e4}\u{9e5}\x03\x02\x02\x02\u{9e5}\u{9e7}\x03\x02\x02\x02\
	\u{9e6}\u{9e4}\x03\x02\x02\x02\u{9e7}\u{9eb}\x07\x1e\x02\x02\u{9e8}\u{9ea}\
	\x07\x07\x02\x02\u{9e9}\u{9e8}\x03\x02\x02\x02\u{9ea}\u{9ed}\x03\x02\x02\
	\x02\u{9eb}\u{9e9}\x03\x02\x02\x02\u{9eb}\u{9ec}\x03\x02\x02\x02\u{9ec}\
	\u{9ef}\x03\x02\x02\x02\u{9ed}\u{9eb}\x03\x02\x02\x02\u{9ee}\u{9e0}\x03\
	\x02\x02\x02\u{9ee}\u{9ef}\x03\x02\x02\x02\u{9ef}\u{9f1}\x03\x02\x02\x02\
	\u{9f0}\u{9f2}\x07\x11\x02\x02\u{9f1}\u{9f0}\x03\x02\x02\x02\u{9f1}\u{9f2}\
	\x03\x02\x02\x02\u{9f2}\u{9f6}\x03\x02\x02\x02\u{9f3}\u{9f5}\x07\x07\x02\
	\x02\u{9f4}\u{9f3}\x03\x02\x02\x02\u{9f5}\u{9f8}\x03\x02\x02\x02\u{9f6}\
	\u{9f4}\x03\x02\x02\x02\u{9f6}\u{9f7}\x03\x02\x02\x02\u{9f7}\u{9f9}\x03\
	\x02\x02\x02\u{9f8}\u{9f6}\x03\x02\x02\x02\u{9f9}\u{9fa}\x05\u{98}\x4d\x02\
	\u{9fa}\u{d3}\x03\x02\x02\x02\u{9fb}\u{a0a}\x05\u{d6}\x6c\x02\u{9fc}\u{a0a}\
	\x05\u{158}\u{ad}\x02\u{9fd}\u{a0a}\x05\u{da}\x6e\x02\u{9fe}\u{a0a}\x05\
	\u{dc}\x6f\x02\u{9ff}\u{a0a}\x05\u{110}\u{89}\x02\u{a00}\u{a0a}\x05\u{f2}\
	\x7a\x02\u{a01}\u{a0a}\x05\u{f4}\x7b\x02\u{a02}\u{a0a}\x05\u{d8}\x6d\x02\
	\u{a03}\u{a0a}\x05\u{f6}\x7c\x02\u{a04}\u{a0a}\x05\u{f8}\x7d\x02\u{a05}\
	\u{a0a}\x05\u{fa}\x7e\x02\u{a06}\u{a0a}\x05\u{fe}\u{80}\x02\u{a07}\u{a0a}\
	\x05\u{108}\u{85}\x02\u{a08}\u{a0a}\x05\u{10e}\u{88}\x02\u{a09}\u{9fb}\x03\
	\x02\x02\x02\u{a09}\u{9fc}\x03\x02\x02\x02\u{a09}\u{9fd}\x03\x02\x02\x02\
	\u{a09}\u{9fe}\x03\x02\x02\x02\u{a09}\u{9ff}\x03\x02\x02\x02\u{a09}\u{a00}\
	\x03\x02\x02\x02\u{a09}\u{a01}\x03\x02\x02\x02\u{a09}\u{a02}\x03\x02\x02\
	\x02\u{a09}\u{a03}\x03\x02\x02\x02\u{a09}\u{a04}\x03\x02\x02\x02\u{a09}\
	\u{a05}\x03\x02\x02\x02\u{a09}\u{a06}\x03\x02\x02\x02\u{a09}\u{a07}\x03\
	\x02\x02\x02\u{a09}\u{a08}\x03\x02\x02\x02\u{a0a}\u{d5}\x03\x02\x02\x02\
	\u{a0b}\u{a0f}\x07\x0b\x02\x02\u{a0c}\u{a0e}\x07\x07\x02\x02\u{a0d}\u{a0c}\
	\x03\x02\x02\x02\u{a0e}\u{a11}\x03\x02\x02\x02\u{a0f}\u{a0d}\x03\x02\x02\
	\x02\u{a0f}\u{a10}\x03\x02\x02\x02\u{a10}\u{a12}\x03\x02\x02\x02\u{a11}\
	\u{a0f}\x03\x02\x02\x02\u{a12}\u{a16}\x05\u{98}\x4d\x02\u{a13}\u{a15}\x07\
	\x07\x02\x02\u{a14}\u{a13}\x03\x02\x02\x02\u{a15}\u{a18}\x03\x02\x02\x02\
	\u{a16}\u{a14}\x03\x02\x02\x02\u{a16}\u{a17}\x03\x02\x02\x02\u{a17}\u{a19}\
	\x03\x02\x02\x02\u{a18}\u{a16}\x03\x02\x02\x02\u{a19}\u{a1a}\x07\x0c\x02\
	\x02\u{a1a}\u{d7}\x03\x02\x02\x02\u{a1b}\u{a1f}\x07\x0d\x02\x02\u{a1c}\u{a1e}\
	\x07\x07\x02\x02\u{a1d}\u{a1c}\x03\x02\x02\x02\u{a1e}\u{a21}\x03\x02\x02\
	\x02\u{a1f}\u{a1d}\x03\x02\x02\x02\u{a1f}\u{a20}\x03\x02\x02\x02\u{a20}\
	\u{a45}\x03\x02\x02\x02\u{a21}\u{a1f}\x03\x02\x02\x02\u{a22}\u{a33}\x05\
	\u{98}\x4d\x02\u{a23}\u{a25}\x07\x07\x02\x02\u{a24}\u{a23}\x03\x02\x02\x02\
	\u{a25}\u{a28}\x03\x02\x02\x02\u{a26}\u{a24}\x03\x02\x02\x02\u{a26}\u{a27}\
	\x03\x02\x02\x02\u{a27}\u{a29}\x03\x02\x02\x02\u{a28}\u{a26}\x03\x02\x02\
	\x02\u{a29}\u{a2d}\x07\x0a\x02\x02\u{a2a}\u{a2c}\x07\x07\x02\x02\u{a2b}\
	\u{a2a}\x03\x02\x02\x02\u{a2c}\u{a2f}\x03\x02\x02\x02\u{a2d}\u{a2b}\x03\
	\x02\x02\x02\u{a2d}\u{a2e}\x03\x02\x02\x02\u{a2e}\u{a30}\x03\x02\x02\x02\
	\u{a2f}\u{a2d}\x03\x02\x02\x02\u{a30}\u{a32}\x05\u{98}\x4d\x02\u{a31}\u{a26}\
	\x03\x02\x02\x02\u{a32}\u{a35}\x03\x02\x02\x02\u{a33}\u{a31}\x03\x02\x02\
	\x02\u{a33}\u{a34}\x03\x02\x02\x02\u{a34}\u{a3d}\x03\x02\x02\x02\u{a35}\
	\u{a33}\x03\x02\x02\x02\u{a36}\u{a38}\x07\x07\x02\x02\u{a37}\u{a36}\x03\
	\x02\x02\x02\u{a38}\u{a3b}\x03\x02\x02\x02\u{a39}\u{a37}\x03\x02\x02\x02\
	\u{a39}\u{a3a}\x03\x02\x02\x02\u{a3a}\u{a3c}\x03\x02\x02\x02\u{a3b}\u{a39}\
	\x03\x02\x02\x02\u{a3c}\u{a3e}\x07\x0a\x02\x02\u{a3d}\u{a39}\x03\x02\x02\
	\x02\u{a3d}\u{a3e}\x03\x02\x02\x02\u{a3e}\u{a42}\x03\x02\x02\x02\u{a3f}\
	\u{a41}\x07\x07\x02\x02\u{a40}\u{a3f}\x03\x02\x02\x02\u{a41}\u{a44}\x03\
	\x02\x02\x02\u{a42}\u{a40}\x03\x02\x02\x02\u{a42}\u{a43}\x03\x02\x02\x02\
	\u{a43}\u{a46}\x03\x02\x02\x02\u{a44}\u{a42}\x03\x02\x02\x02\u{a45}\u{a22}\
	\x03\x02\x02\x02\u{a45}\u{a46}\x03\x02\x02\x02\u{a46}\u{a47}\x03\x02\x02\
	\x02\u{a47}\u{a48}\x07\x0e\x02\x02\u{a48}\u{d9}\x03\x02\x02\x02\u{a49}\u{a4a}\
	\x09\x08\x02\x02\u{a4a}\u{db}\x03\x02\x02\x02\u{a4b}\u{a4e}\x05\u{de}\x70\
	\x02\u{a4c}\u{a4e}\x05\u{e0}\x71\x02\u{a4d}\u{a4b}\x03\x02\x02\x02\u{a4d}\
	\u{a4c}\x03\x02\x02\x02\u{a4e}\u{dd}\x03\x02\x02\x02\u{a4f}\u{a54}\x07\u{97}\
	\x02\x02\u{a50}\u{a53}\x05\u{e2}\x72\x02\u{a51}\u{a53}\x05\u{e4}\x73\x02\
	\u{a52}\u{a50}\x03\x02\x02\x02\u{a52}\u{a51}\x03\x02\x02\x02\u{a53}\u{a56}\
	\x03\x02\x02\x02\u{a54}\u{a52}\x03\x02\x02\x02\u{a54}\u{a55}\x03\x02\x02\
	\x02\u{a55}\u{a57}\x03\x02\x02\x02\u{a56}\u{a54}\x03\x02\x02\x02\u{a57}\
	\u{a58}\x07\u{a0}\x02\x02\u{a58}\u{df}\x03\x02\x02\x02\u{a59}\u{a5f}\x07\
	\u{98}\x02\x02\u{a5a}\u{a5e}\x05\u{e6}\x74\x02\u{a5b}\u{a5e}\x05\u{e8}\x75\
	\x02\u{a5c}\u{a5e}\x07\u{a6}\x02\x02\u{a5d}\u{a5a}\x03\x02\x02\x02\u{a5d}\
	\u{a5b}\x03\x02\x02\x02\u{a5d}\u{a5c}\x03\x02\x02\x02\u{a5e}\u{a61}\x03\
	\x02\x02\x02\u{a5f}\u{a5d}\x03\x02\x02\x02\u{a5f}\u{a60}\x03\x02\x02\x02\
	\u{a60}\u{a62}\x03\x02\x02\x02\u{a61}\u{a5f}\x03\x02\x02\x02\u{a62}\u{a63}\
	\x07\u{a5}\x02\x02\u{a63}\u{e1}\x03\x02\x02\x02\u{a64}\u{a65}\x09\x09\x02\
	\x02\u{a65}\u{e3}\x03\x02\x02\x02\u{a66}\u{a6a}\x07\u{a4}\x02\x02\u{a67}\
	\u{a69}\x07\x07\x02\x02\u{a68}\u{a67}\x03\x02\x02\x02\u{a69}\u{a6c}\x03\
	\x02\x02\x02\u{a6a}\u{a68}\x03\x02\x02\x02\u{a6a}\u{a6b}\x03\x02\x02\x02\
	\u{a6b}\u{a6d}\x03\x02\x02\x02\u{a6c}\u{a6a}\x03\x02\x02\x02\u{a6d}\u{a71}\
	\x05\u{98}\x4d\x02\u{a6e}\u{a70}\x07\x07\x02\x02\u{a6f}\u{a6e}\x03\x02\x02\
	\x02\u{a70}\u{a73}\x03\x02\x02\x02\u{a71}\u{a6f}\x03\x02\x02\x02\u{a71}\
	\u{a72}\x03\x02\x02\x02\u{a72}\u{a74}\x03\x02\x02\x02\u{a73}\u{a71}\x03\
	\x02\x02\x02\u{a74}\u{a75}\x07\x10\x02\x02\u{a75}\u{e5}\x03\x02\x02\x02\
	\u{a76}\u{a77}\x09\x0a\x02\x02\u{a77}\u{e7}\x03\x02\x02\x02\u{a78}\u{a7c}\
	\x07\u{a9}\x02\x02\u{a79}\u{a7b}\x07\x07\x02\x02\u{a7a}\u{a79}\x03\x02\x02\
	\x02\u{a7b}\u{a7e}\x03\x02\x02\x02\u{a7c}\u{a7a}\x03\x02\x02\x02\u{a7c}\
	\u{a7d}\x03\x02\x02\x02\u{a7d}\u{a7f}\x03\x02\x02\x02\u{a7e}\u{a7c}\x03\
	\x02\x02\x02\u{a7f}\u{a83}\x05\u{98}\x4d\x02\u{a80}\u{a82}\x07\x07\x02\x02\
	\u{a81}\u{a80}\x03\x02\x02\x02\u{a82}\u{a85}\x03\x02\x02\x02\u{a83}\u{a81}\
	\x03\x02\x02\x02\u{a83}\u{a84}\x03\x02\x02\x02\u{a84}\u{a86}\x03\x02\x02\
	\x02\u{a85}\u{a83}\x03\x02\x02\x02\u{a86}\u{a87}\x07\x10\x02\x02\u{a87}\
	\u{e9}\x03\x02\x02\x02\u{a88}\u{a8c}\x07\x0f\x02\x02\u{a89}\u{a8b}\x07\x07\
	\x02\x02\u{a8a}\u{a89}\x03\x02\x02\x02\u{a8b}\u{a8e}\x03\x02\x02\x02\u{a8c}\
	\u{a8a}\x03\x02\x02\x02\u{a8c}\u{a8d}\x03\x02\x02\x02\u{a8d}\u{a9f}\x03\
	\x02\x02\x02\u{a8e}\u{a8c}\x03\x02\x02\x02\u{a8f}\u{a91}\x05\u{ec}\x77\x02\
	\u{a90}\u{a8f}\x03\x02\x02\x02\u{a90}\u{a91}\x03\x02\x02\x02\u{a91}\u{a95}\
	\x03\x02\x02\x02\u{a92}\u{a94}\x07\x07\x02\x02\u{a93}\u{a92}\x03\x02\x02\
	\x02\u{a94}\u{a97}\x03\x02\x02\x02\u{a95}\u{a93}\x03\x02\x02\x02\u{a95}\
	\u{a96}\x03\x02\x02\x02\u{a96}\u{a98}\x03\x02\x02\x02\u{a97}\u{a95}\x03\
	\x02\x02\x02\u{a98}\u{a9c}\x07\x24\x02\x02\u{a99}\u{a9b}\x07\x07\x02\x02\
	\u{a9a}\u{a99}\x03\x02\x02\x02\u{a9b}\u{a9e}\x03\x02\x02\x02\u{a9c}\u{a9a}\
	\x03\x02\x02\x02\u{a9c}\u{a9d}\x03\x02\x02\x02\u{a9d}\u{aa0}\x03\x02\x02\
	\x02\u{a9e}\u{a9c}\x03\x02\x02\x02\u{a9f}\u{a90}\x03\x02\x02\x02\u{a9f}\
	\u{aa0}\x03\x02\x02\x02\u{aa0}\u{aa1}\x03\x02\x02\x02\u{aa1}\u{aa5}\x05\
	\u{80}\x41\x02\u{aa2}\u{aa4}\x07\x07\x02\x02\u{aa3}\u{aa2}\x03\x02\x02\x02\
	\u{aa4}\u{aa7}\x03\x02\x02\x02\u{aa5}\u{aa3}\x03\x02\x02\x02\u{aa5}\u{aa6}\
	\x03\x02\x02\x02\u{aa6}\u{aa8}\x03\x02\x02\x02\u{aa7}\u{aa5}\x03\x02\x02\
	\x02\u{aa8}\u{aa9}\x07\x10\x02\x02\u{aa9}\u{eb}\x03\x02\x02\x02\u{aaa}\u{abb}\
	\x05\u{ee}\x78\x02\u{aab}\u{aad}\x07\x07\x02\x02\u{aac}\u{aab}\x03\x02\x02\
	\x02\u{aad}\u{ab0}\x03\x02\x02\x02\u{aae}\u{aac}\x03\x02\x02\x02\u{aae}\
	\u{aaf}\x03\x02\x02\x02\u{aaf}\u{ab1}\x03\x02\x02\x02\u{ab0}\u{aae}\x03\
	\x02\x02\x02\u{ab1}\u{ab5}\x07\x0a\x02\x02\u{ab2}\u{ab4}\x07\x07\x02\x02\
	\u{ab3}\u{ab2}\x03\x02\x02\x02\u{ab4}\u{ab7}\x03\x02\x02\x02\u{ab5}\u{ab3}\
	\x03\x02\x02\x02\u{ab5}\u{ab6}\x03\x02\x02\x02\u{ab6}\u{ab8}\x03\x02\x02\
	\x02\u{ab7}\u{ab5}\x03\x02\x02\x02\u{ab8}\u{aba}\x05\u{ee}\x78\x02\u{ab9}\
	\u{aae}\x03\x02\x02\x02\u{aba}\u{abd}\x03\x02\x02\x02\u{abb}\u{ab9}\x03\
	\x02\x02\x02\u{abb}\u{abc}\x03\x02\x02\x02\u{abc}\u{ac5}\x03\x02\x02\x02\
	\u{abd}\u{abb}\x03\x02\x02\x02\u{abe}\u{ac0}\x07\x07\x02\x02\u{abf}\u{abe}\
	\x03\x02\x02\x02\u{ac0}\u{ac3}\x03\x02\x02\x02\u{ac1}\u{abf}\x03\x02\x02\
	\x02\u{ac1}\u{ac2}\x03\x02\x02\x02\u{ac2}\u{ac4}\x03\x02\x02\x02\u{ac3}\
	\u{ac1}\x03\x02\x02\x02\u{ac4}\u{ac6}\x07\x0a\x02\x02\u{ac5}\u{ac1}\x03\
	\x02\x02\x02\u{ac5}\u{ac6}\x03\x02\x02\x02\u{ac6}\u{ed}\x03\x02\x02\x02\
	\u{ac7}\u{ada}\x05\x44\x23\x02\u{ac8}\u{ad7}\x05\x46\x24\x02\u{ac9}\u{acb}\
	\x07\x07\x02\x02\u{aca}\u{ac9}\x03\x02\x02\x02\u{acb}\u{ace}\x03\x02\x02\
	\x02\u{acc}\u{aca}\x03\x02\x02\x02\u{acc}\u{acd}\x03\x02\x02\x02\u{acd}\
	\u{acf}\x03\x02\x02\x02\u{ace}\u{acc}\x03\x02\x02\x02\u{acf}\u{ad3}\x07\
	\x1c\x02\x02\u{ad0}\u{ad2}\x07\x07\x02\x02\u{ad1}\u{ad0}\x03\x02\x02\x02\
	\u{ad2}\u{ad5}\x03\x02\x02\x02\u{ad3}\u{ad1}\x03\x02\x02\x02\u{ad3}\u{ad4}\
	\x03\x02\x02\x02\u{ad4}\u{ad6}\x03\x02\x02\x02\u{ad5}\u{ad3}\x03\x02\x02\
	\x02\u{ad6}\u{ad8}\x05\x64\x33\x02\u{ad7}\u{acc}\x03\x02\x02\x02\u{ad7}\
	\u{ad8}\x03\x02\x02\x02\u{ad8}\u{ada}\x03\x02\x02\x02\u{ad9}\u{ac7}\x03\
	\x02\x02\x02\u{ad9}\u{ac8}\x03\x02\x02\x02\u{ada}\u{ef}\x03\x02\x02\x02\
	\u{adb}\u{aeb}\x07\x4c\x02\x02\u{adc}\u{ade}\x07\x07\x02\x02\u{add}\u{adc}\
	\x03\x02\x02\x02\u{ade}\u{ae1}\x03\x02\x02\x02\u{adf}\u{add}\x03\x02\x02\
	\x02\u{adf}\u{ae0}\x03\x02\x02\x02\u{ae0}\u{ae2}\x03\x02\x02\x02\u{ae1}\
	\u{adf}\x03\x02\x02\x02\u{ae2}\u{ae6}\x05\x64\x33\x02\u{ae3}\u{ae5}\x07\
	\x07\x02\x02\u{ae4}\u{ae3}\x03\x02\x02\x02\u{ae5}\u{ae8}\x03\x02\x02\x02\
	\u{ae6}\u{ae4}\x03\x02\x02\x02\u{ae6}\u{ae7}\x03\x02\x02\x02\u{ae7}\u{ae9}\
	\x03\x02\x02\x02\u{ae8}\u{ae6}\x03\x02\x02\x02\u{ae9}\u{aea}\x07\x09\x02\
	\x02\u{aea}\u{aec}\x03\x02\x02\x02\u{aeb}\u{adf}\x03\x02\x02\x02\u{aeb}\
	\u{aec}\x03\x02\x02\x02\u{aec}\u{af0}\x03\x02\x02\x02\u{aed}\u{aef}\x07\
	\x07\x02\x02\u{aee}\u{aed}\x03\x02\x02\x02\u{aef}\u{af2}\x03\x02\x02\x02\
	\u{af0}\u{aee}\x03\x02\x02\x02\u{af0}\u{af1}\x03\x02\x02\x02\u{af1}\u{af3}\
	\x03\x02\x02\x02\u{af2}\u{af0}\x03\x02\x02\x02\u{af3}\u{b02}\x05\x50\x29\
	\x02\u{af4}\u{af6}\x07\x07\x02\x02\u{af5}\u{af4}\x03\x02\x02\x02\u{af6}\
	\u{af9}\x03\x02\x02\x02\u{af7}\u{af5}\x03\x02\x02\x02\u{af7}\u{af8}\x03\
	\x02\x02\x02\u{af8}\u{afa}\x03\x02\x02\x02\u{af9}\u{af7}\x03\x02\x02\x02\
	\u{afa}\u{afe}\x07\x1c\x02\x02\u{afb}\u{afd}\x07\x07\x02\x02\u{afc}\u{afb}\
	\x03\x02\x02\x02\u{afd}\u{b00}\x03\x02\x02\x02\u{afe}\u{afc}\x03\x02\x02\
	\x02\u{afe}\u{aff}\x03\x02\x02\x02\u{aff}\u{b01}\x03\x02\x02\x02\u{b00}\
	\u{afe}\x03\x02\x02\x02\u{b01}\u{b03}\x05\x64\x33\x02\u{b02}\u{af7}\x03\
	\x02\x02\x02\u{b02}\u{b03}\x03\x02\x02\x02\u{b03}\u{b0b}\x03\x02\x02\x02\
	\u{b04}\u{b06}\x07\x07\x02\x02\u{b05}\u{b04}\x03\x02\x02\x02\u{b06}\u{b09}\
	\x03\x02\x02\x02\u{b07}\u{b05}\x03\x02\x02\x02\u{b07}\u{b08}\x03\x02\x02\
	\x02\u{b08}\u{b0a}\x03\x02\x02\x02\u{b09}\u{b07}\x03\x02\x02\x02\u{b0a}\
	\u{b0c}\x05\x30\x19\x02\u{b0b}\u{b07}\x03\x02\x02\x02\u{b0b}\u{b0c}\x03\
	\x02\x02\x02\u{b0c}\u{b14}\x03\x02\x02\x02\u{b0d}\u{b0f}\x07\x07\x02\x02\
	\u{b0e}\u{b0d}\x03\x02\x02\x02\u{b0f}\u{b12}\x03\x02\x02\x02\u{b10}\u{b0e}\
	\x03\x02\x02\x02\u{b10}\u{b11}\x03\x02\x02\x02\u{b11}\u{b13}\x03\x02\x02\
	\x02\u{b12}\u{b10}\x03\x02\x02\x02\u{b13}\u{b15}\x05\x42\x22\x02\u{b14}\
	\u{b10}\x03\x02\x02\x02\u{b14}\u{b15}\x03\x02\x02\x02\u{b15}\u{f1}\x03\x02\
	\x02\x02\u{b16}\u{b19}\x05\u{ea}\x76\x02\u{b17}\u{b19}\x05\u{f0}\x79\x02\
	\u{b18}\u{b16}\x03\x02\x02\x02\u{b18}\u{b17}\x03\x02\x02\x02\u{b19}\u{f3}\
	\x03\x02\x02\x02\u{b1a}\u{b2f}\x07\x4d\x02\x02\u{b1b}\u{b1d}\x07\x07\x02\
	\x02\u{b1c}\u{b1b}\x03\x02\x02\x02\u{b1d}\u{b20}\x03\x02\x02\x02\u{b1e}\
	\u{b1c}\x03\x02\x02\x02\u{b1e}\u{b1f}\x03\x02\x02\x02\u{b1f}\u{b21}\x03\
	\x02\x02\x02\u{b20}\u{b1e}\x03\x02\x02\x02\u{b21}\u{b25}\x07\x1c\x02\x02\
	\u{b22}\u{b24}\x07\x07\x02\x02\u{b23}\u{b22}\x03\x02\x02\x02\u{b24}\u{b27}\
	\x03\x02\x02\x02\u{b25}\u{b23}\x03\x02\x02\x02\u{b25}\u{b26}\x03\x02\x02\
	\x02\u{b26}\u{b28}\x03\x02\x02\x02\u{b27}\u{b25}\x03\x02\x02\x02\u{b28}\
	\u{b2c}\x05\x22\x12\x02\u{b29}\u{b2b}\x07\x07\x02\x02\u{b2a}\u{b29}\x03\
	\x02\x02\x02\u{b2b}\u{b2e}\x03\x02\x02\x02\u{b2c}\u{b2a}\x03\x02\x02\x02\
	\u{b2c}\u{b2d}\x03\x02\x02\x02\u{b2d}\u{b30}\x03\x02\x02\x02\u{b2e}\u{b2c}\
	\x03\x02\x02\x02\u{b2f}\u{b1e}\x03\x02\x02\x02\u{b2f}\u{b30}\x03\x02\x02\
	\x02\u{b30}\u{b38}\x03\x02\x02\x02\u{b31}\u{b33}\x07\x07\x02\x02\u{b32}\
	\u{b31}\x03\x02\x02\x02\u{b33}\u{b36}\x03\x02\x02\x02\u{b34}\u{b32}\x03\
	\x02\x02\x02\u{b34}\u{b35}\x03\x02\x02\x02\u{b35}\u{b37}\x03\x02\x02\x02\
	\u{b36}\u{b34}\x03\x02\x02\x02\u{b37}\u{b39}\x05\x1c\x0f\x02\u{b38}\u{b34}\
	\x03\x02\x02\x02\u{b38}\u{b39}\x03\x02\x02\x02\u{b39}\u{f5}\x03\x02\x02\
	\x02\u{b3a}\u{b3b}\x09\x0b\x02\x02\u{b3b}\u{f7}\x03\x02\x02\x02\u{b3c}\u{b4d}\
	\x07\x56\x02\x02\u{b3d}\u{b41}\x07\x30\x02\x02\u{b3e}\u{b40}\x07\x07\x02\
	\x02\u{b3f}\u{b3e}\x03\x02\x02\x02\u{b40}\u{b43}\x03\x02\x02\x02\u{b41}\
	\u{b3f}\x03\x02\x02\x02\u{b41}\u{b42}\x03\x02\x02\x02\u{b42}\u{b44}\x03\
	\x02\x02\x02\u{b43}\u{b41}\x03\x02\x02\x02\u{b44}\u{b48}\x05\x64\x33\x02\
	\u{b45}\u{b47}\x07\x07\x02\x02\u{b46}\u{b45}\x03\x02\x02\x02\u{b47}\u{b4a}\
	\x03\x02\x02\x02\u{b48}\u{b46}\x03\x02\x02\x02\u{b48}\u{b49}\x03\x02\x02\
	\x02\u{b49}\u{b4b}\x03\x02\x02\x02\u{b4a}\u{b48}\x03\x02\x02\x02\u{b4b}\
	\u{b4c}\x07\x31\x02\x02\u{b4c}\u{b4e}\x03\x02\x02\x02\u{b4d}\u{b3d}\x03\
	\x02\x02\x02\u{b4d}\u{b4e}\x03\x02\x02\x02\u{b4e}\u{b51}\x03\x02\x02\x02\
	\u{b4f}\u{b50}\x07\x2a\x02\x02\u{b50}\u{b52}\x05\u{158}\u{ad}\x02\u{b51}\
	\u{b4f}\x03\x02\x02\x02\u{b51}\u{b52}\x03\x02\x02\x02\u{b52}\u{b55}\x03\
	\x02\x02\x02\u{b53}\u{b55}\x07\x3e\x02\x02\u{b54}\u{b3c}\x03\x02\x02\x02\
	\u{b54}\u{b53}\x03\x02\x02\x02\u{b55}\u{f9}\x03\x02\x02\x02\u{b56}\u{b5a}\
	\x07\x59\x02\x02\u{b57}\u{b59}\x07\x07\x02\x02\u{b58}\u{b57}\x03\x02\x02\
	\x02\u{b59}\u{b5c}\x03\x02\x02\x02\u{b5a}\u{b58}\x03\x02\x02\x02\u{b5a}\
	\u{b5b}\x03\x02\x02\x02\u{b5b}\u{b5d}\x03\x02\x02\x02\u{b5c}\u{b5a}\x03\
	\x02\x02\x02\u{b5d}\u{b61}\x07\x0b\x02\x02\u{b5e}\u{b60}\x07\x07\x02\x02\
	\u{b5f}\u{b5e}\x03\x02\x02\x02\u{b60}\u{b63}\x03\x02\x02\x02\u{b61}\u{b5f}\
	\x03\x02\x02\x02\u{b61}\u{b62}\x03\x02\x02\x02\u{b62}\u{b64}\x03\x02\x02\
	\x02\u{b63}\u{b61}\x03\x02\x02\x02\u{b64}\u{b68}\x05\u{98}\x4d\x02\u{b65}\
	\u{b67}\x07\x07\x02\x02\u{b66}\u{b65}\x03\x02\x02\x02\u{b67}\u{b6a}\x03\
	\x02\x02\x02\u{b68}\u{b66}\x03\x02\x02\x02\u{b68}\u{b69}\x03\x02\x02\x02\
	\u{b69}\u{b6b}\x03\x02\x02\x02\u{b6a}\u{b68}\x03\x02\x02\x02\u{b6b}\u{b6f}\
	\x07\x0c\x02\x02\u{b6c}\u{b6e}\x07\x07\x02\x02\u{b6d}\u{b6c}\x03\x02\x02\
	\x02\u{b6e}\u{b71}\x03\x02\x02\x02\u{b6f}\u{b6d}\x03\x02\x02\x02\u{b6f}\
	\u{b70}\x03\x02\x02\x02\u{b70}\u{b91}\x03\x02\x02\x02\u{b71}\u{b6f}\x03\
	\x02\x02\x02\u{b72}\u{b92}\x05\u{86}\x44\x02\u{b73}\u{b75}\x05\u{86}\x44\
	\x02\u{b74}\u{b73}\x03\x02\x02\x02\u{b74}\u{b75}\x03\x02\x02\x02\u{b75}\
	\u{b79}\x03\x02\x02\x02\u{b76}\u{b78}\x07\x07\x02\x02\u{b77}\u{b76}\x03\
	\x02\x02\x02\u{b78}\u{b7b}\x03\x02\x02\x02\u{b79}\u{b77}\x03\x02\x02\x02\
	\u{b79}\u{b7a}\x03\x02\x02\x02\u{b7a}\u{b7d}\x03\x02\x02\x02\u{b7b}\u{b79}\
	\x03\x02\x02\x02\u{b7c}\u{b7e}\x07\x1d\x02\x02\u{b7d}\u{b7c}\x03\x02\x02\
	\x02\u{b7d}\u{b7e}\x03\x02\x02\x02\u{b7e}\u{b82}\x03\x02\x02\x02\u{b7f}\
	\u{b81}\x07\x07\x02\x02\u{b80}\u{b7f}\x03\x02\x02\x02\u{b81}\u{b84}\x03\
	\x02\x02\x02\u{b82}\u{b80}\x03\x02\x02\x02\u{b82}\u{b83}\x03\x02\x02\x02\
	\u{b83}\u{b85}\x03\x02\x02\x02\u{b84}\u{b82}\x03\x02\x02\x02\u{b85}\u{b89}\
	\x07\x5a\x02\x02\u{b86}\u{b88}\x07\x07\x02\x02\u{b87}\u{b86}\x03\x02\x02\
	\x02\u{b88}\u{b8b}\x03\x02\x02\x02\u{b89}\u{b87}\x03\x02\x02\x02\u{b89}\
	\u{b8a}\x03\x02\x02\x02\u{b8a}\u{b8e}\x03\x02\x02\x02\u{b8b}\u{b89}\x03\
	\x02\x02\x02\u{b8c}\u{b8f}\x05\u{86}\x44\x02\u{b8d}\u{b8f}\x07\x1d\x02\x02\
	\u{b8e}\u{b8c}\x03\x02\x02\x02\u{b8e}\u{b8d}\x03\x02\x02\x02\u{b8f}\u{b92}\
	\x03\x02\x02\x02\u{b90}\u{b92}\x07\x1d\x02\x02\u{b91}\u{b72}\x03\x02\x02\
	\x02\u{b91}\u{b74}\x03\x02\x02\x02\u{b91}\u{b90}\x03\x02\x02\x02\u{b92}\
	\u{fb}\x03\x02\x02\x02\u{b93}\u{bb5}\x07\x0b\x02\x02\u{b94}\u{b96}\x05\u{14e}\
	\u{a8}\x02\u{b95}\u{b94}\x03\x02\x02\x02\u{b96}\u{b99}\x03\x02\x02\x02\u{b97}\
	\u{b95}\x03\x02\x02\x02\u{b97}\u{b98}\x03\x02\x02\x02\u{b98}\u{b9d}\x03\
	\x02\x02\x02\u{b99}\u{b97}\x03\x02\x02\x02\u{b9a}\u{b9c}\x07\x07\x02\x02\
	\u{b9b}\u{b9a}\x03\x02\x02\x02\u{b9c}\u{b9f}\x03\x02\x02\x02\u{b9d}\u{b9b}\
	\x03\x02\x02\x02\u{b9d}\u{b9e}\x03\x02\x02\x02\u{b9e}\u{ba0}\x03\x02\x02\
	\x02\u{b9f}\u{b9d}\x03\x02\x02\x02\u{ba0}\u{ba4}\x07\x4e\x02\x02\u{ba1}\
	\u{ba3}\x07\x07\x02\x02\u{ba2}\u{ba1}\x03\x02\x02\x02\u{ba3}\u{ba6}\x03\
	\x02\x02\x02\u{ba4}\u{ba2}\x03\x02\x02\x02\u{ba4}\u{ba5}\x03\x02\x02\x02\
	\u{ba5}\u{ba7}\x03\x02\x02\x02\u{ba6}\u{ba4}\x03\x02\x02\x02\u{ba7}\u{bab}\
	\x05\x44\x23\x02\u{ba8}\u{baa}\x07\x07\x02\x02\u{ba9}\u{ba8}\x03\x02\x02\
	\x02\u{baa}\u{bad}\x03\x02\x02\x02\u{bab}\u{ba9}\x03\x02\x02\x02\u{bab}\
	\u{bac}\x03\x02\x02\x02\u{bac}\u{bae}\x03\x02\x02\x02\u{bad}\u{bab}\x03\
	\x02\x02\x02\u{bae}\u{bb2}\x07\x1e\x02\x02\u{baf}\u{bb1}\x07\x07\x02\x02\
	\u{bb0}\u{baf}\x03\x02\x02\x02\u{bb1}\u{bb4}\x03\x02\x02\x02\u{bb2}\u{bb0}\
	\x03\x02\x02\x02\u{bb2}\u{bb3}\x03\x02\x02\x02\u{bb3}\u{bb6}\x03\x02\x02\
	\x02\u{bb4}\u{bb2}\x03\x02\x02\x02\u{bb5}\u{b97}\x03\x02\x02\x02\u{bb5}\
	\u{bb6}\x03\x02\x02\x02\u{bb6}\u{bb7}\x03\x02\x02\x02\u{bb7}\u{bb8}\x05\
	\u{98}\x4d\x02\u{bb8}\u{bb9}\x07\x0c\x02\x02\u{bb9}\u{fd}\x03\x02\x02\x02\
	\u{bba}\u{bbe}\x07\x5b\x02\x02\u{bbb}\u{bbd}\x07\x07\x02\x02\u{bbc}\u{bbb}\
	\x03\x02\x02\x02\u{bbd}\u{bc0}\x03\x02\x02\x02\u{bbe}\u{bbc}\x03\x02\x02\
	\x02\u{bbe}\u{bbf}\x03\x02\x02\x02\u{bbf}\u{bc2}\x03\x02\x02\x02\u{bc0}\
	\u{bbe}\x03\x02\x02\x02\u{bc1}\u{bc3}\x05\u{fc}\x7f\x02\u{bc2}\u{bc1}\x03\
	\x02\x02\x02\u{bc2}\u{bc3}\x03\x02\x02\x02\u{bc3}\u{bc7}\x03\x02\x02\x02\
	\u{bc4}\u{bc6}\x07\x07\x02\x02\u{bc5}\u{bc4}\x03\x02\x02\x02\u{bc6}\u{bc9}\
	\x03\x02\x02\x02\u{bc7}\u{bc5}\x03\x02\x02\x02\u{bc7}\u{bc8}\x03\x02\x02\
	\x02\u{bc8}\u{bca}\x03\x02\x02\x02\u{bc9}\u{bc7}\x03\x02\x02\x02\u{bca}\
	\u{bce}\x07\x0f\x02\x02\u{bcb}\u{bcd}\x07\x07\x02\x02\u{bcc}\u{bcb}\x03\
	\x02\x02\x02\u{bcd}\u{bd0}\x03\x02\x02\x02\u{bce}\u{bcc}\x03\x02\x02\x02\
	\u{bce}\u{bcf}\x03\x02\x02\x02\u{bcf}\u{bda}\x03\x02\x02\x02\u{bd0}\u{bce}\
	\x03\x02\x02\x02\u{bd1}\u{bd5}\x05\u{100}\u{81}\x02\u{bd2}\u{bd4}\x07\x07\
	\x02\x02\u{bd3}\u{bd2}\x03\x02\x02\x02\u{bd4}\u{bd7}\x03\x02\x02\x02\u{bd5}\
	\u{bd3}\x03\x02\x02\x02\u{bd5}\u{bd6}\x03\x02\x02\x02\u{bd6}\u{bd9}\x03\
	\x02\x02\x02\u{bd7}\u{bd5}\x03\x02\x02\x02\u{bd8}\u{bd1}\x03\x02\x02\x02\
	\u{bd9}\u{bdc}\x03\x02\x02\x02\u{bda}\u{bd8}\x03\x02\x02\x02\u{bda}\u{bdb}\
	\x03\x02\x02\x02\u{bdb}\u{be0}\x03\x02\x02\x02\u{bdc}\u{bda}\x03\x02\x02\
	\x02\u{bdd}\u{bdf}\x07\x07\x02\x02\u{bde}\u{bdd}\x03\x02\x02\x02\u{bdf}\
	\u{be2}\x03\x02\x02\x02\u{be0}\u{bde}\x03\x02\x02\x02\u{be0}\u{be1}\x03\
	\x02\x02\x02\u{be1}\u{be3}\x03\x02\x02\x02\u{be2}\u{be0}\x03\x02\x02\x02\
	\u{be3}\u{be4}\x07\x10\x02\x02\u{be4}\u{ff}\x03\x02\x02\x02\u{be5}\u{bf6}\
	\x05\u{102}\u{82}\x02\u{be6}\u{be8}\x07\x07\x02\x02\u{be7}\u{be6}\x03\x02\
	\x02\x02\u{be8}\u{beb}\x03\x02\x02\x02\u{be9}\u{be7}\x03\x02\x02\x02\u{be9}\
	\u{bea}\x03\x02\x02\x02\u{bea}\u{bec}\x03\x02\x02\x02\u{beb}\u{be9}\x03\
	\x02\x02\x02\u{bec}\u{bf0}\x07\x0a\x02\x02\u{bed}\u{bef}\x07\x07\x02\x02\
	\u{bee}\u{bed}\x03\x02\x02\x02\u{bef}\u{bf2}\x03\x02\x02\x02\u{bf0}\u{bee}\
	\x03\x02\x02\x02\u{bf0}\u{bf1}\x03\x02\x02\x02\u{bf1}\u{bf3}\x03\x02\x02\
	\x02\u{bf2}\u{bf0}\x03\x02\x02\x02\u{bf3}\u{bf5}\x05\u{102}\u{82}\x02\u{bf4}\
	\u{be9}\x03\x02\x02\x02\u{bf5}\u{bf8}\x03\x02\x02\x02\u{bf6}\u{bf4}\x03\
	\x02\x02\x02\u{bf6}\u{bf7}\x03\x02\x02\x02\u{bf7}\u{c00}\x03\x02\x02\x02\
	\u{bf8}\u{bf6}\x03\x02\x02\x02\u{bf9}\u{bfb}\x07\x07\x02\x02\u{bfa}\u{bf9}\
	\x03\x02\x02\x02\u{bfb}\u{bfe}\x03\x02\x02\x02\u{bfc}\u{bfa}\x03\x02\x02\
	\x02\u{bfc}\u{bfd}\x03\x02\x02\x02\u{bfd}\u{bff}\x03\x02\x02\x02\u{bfe}\
	\u{bfc}\x03\x02\x02\x02\u{bff}\u{c01}\x07\x0a\x02\x02\u{c00}\u{bfc}\x03\
	\x02\x02\x02\u{c00}\u{c01}\x03\x02\x02\x02\u{c01}\u{c05}\x03\x02\x02\x02\
	\u{c02}\u{c04}\x07\x07\x02\x02\u{c03}\u{c02}\x03\x02\x02\x02\u{c04}\u{c07}\
	\x03\x02\x02\x02\u{c05}\u{c03}\x03\x02\x02\x02\u{c05}\u{c06}\x03\x02\x02\
	\x02\u{c06}\u{c08}\x03\x02\x02\x02\u{c07}\u{c05}\x03\x02\x02\x02\u{c08}\
	\u{c0c}\x07\x24\x02\x02\u{c09}\u{c0b}\x07\x07\x02\x02\u{c0a}\u{c09}\x03\
	\x02\x02\x02\u{c0b}\u{c0e}\x03\x02\x02\x02\u{c0c}\u{c0a}\x03\x02\x02\x02\
	\u{c0c}\u{c0d}\x03\x02\x02\x02\u{c0d}\u{c0f}\x03\x02\x02\x02\u{c0e}\u{c0c}\
	\x03\x02\x02\x02\u{c0f}\u{c11}\x05\u{86}\x44\x02\u{c10}\u{c12}\x05\u{94}\
	\x4b\x02\u{c11}\u{c10}\x03\x02\x02\x02\u{c11}\u{c12}\x03\x02\x02\x02\u{c12}\
	\u{c26}\x03\x02\x02\x02\u{c13}\u{c17}\x07\x5a\x02\x02\u{c14}\u{c16}\x07\
	\x07\x02\x02\u{c15}\u{c14}\x03\x02\x02\x02\u{c16}\u{c19}\x03\x02\x02\x02\
	\u{c17}\u{c15}\x03\x02\x02\x02\u{c17}\u{c18}\x03\x02\x02\x02\u{c18}\u{c1a}\
	\x03\x02\x02\x02\u{c19}\u{c17}\x03\x02\x02\x02\u{c1a}\u{c1e}\x07\x24\x02\
	\x02\u{c1b}\u{c1d}\x07\x07\x02\x02\u{c1c}\u{c1b}\x03\x02\x02\x02\u{c1d}\
	\u{c20}\x03\x02\x02\x02\u{c1e}\u{c1c}\x03\x02\x02\x02\u{c1e}\u{c1f}\x03\
	\x02\x02\x02\u{c1f}\u{c21}\x03\x02\x02\x02\u{c20}\u{c1e}\x03\x02\x02\x02\
	\u{c21}\u{c23}\x05\u{86}\x44\x02\u{c22}\u{c24}\x05\u{94}\x4b\x02\u{c23}\
	\u{c22}\x03\x02\x02\x02\u{c23}\u{c24}\x03\x02\x02\x02\u{c24}\u{c26}\x03\
	\x02\x02\x02\u{c25}\u{be5}\x03\x02\x02\x02\u{c25}\u{c13}\x03\x02\x02\x02\
	\u{c26}\u{101}\x03\x02\x02\x02\u{c27}\u{c2b}\x05\u{98}\x4d\x02\u{c28}\u{c2b}\
	\x05\u{104}\u{83}\x02\u{c29}\u{c2b}\x05\u{106}\u{84}\x02\u{c2a}\u{c27}\x03\
	\x02\x02\x02\u{c2a}\u{c28}\x03\x02\x02\x02\u{c2a}\u{c29}\x03\x02\x02\x02\
	\u{c2b}\u{103}\x03\x02\x02\x02\u{c2c}\u{c30}\x05\u{118}\u{8d}\x02\u{c2d}\
	\u{c2f}\x07\x07\x02\x02\u{c2e}\u{c2d}\x03\x02\x02\x02\u{c2f}\u{c32}\x03\
	\x02\x02\x02\u{c30}\u{c2e}\x03\x02\x02\x02\u{c30}\u{c31}\x03\x02\x02\x02\
	\u{c31}\u{c33}\x03\x02\x02\x02\u{c32}\u{c30}\x03\x02\x02\x02\u{c33}\u{c34}\
	\x05\u{98}\x4d\x02\u{c34}\u{105}\x03\x02\x02\x02\u{c35}\u{c39}\x05\u{11a}\
	\u{8e}\x02\u{c36}\u{c38}\x07\x07\x02\x02\u{c37}\u{c36}\x03\x02\x02\x02\u{c38}\
	\u{c3b}\x03\x02\x02\x02\u{c39}\u{c37}\x03\x02\x02\x02\u{c39}\u{c3a}\x03\
	\x02\x02\x02\u{c3a}\u{c3c}\x03\x02\x02\x02\u{c3b}\u{c39}\x03\x02\x02\x02\
	\u{c3c}\u{c3d}\x05\x64\x33\x02\u{c3d}\u{107}\x03\x02\x02\x02\u{c3e}\u{c42}\
	\x07\x5c\x02\x02\u{c3f}\u{c41}\x07\x07\x02\x02\u{c40}\u{c3f}\x03\x02\x02\
	\x02\u{c41}\u{c44}\x03\x02\x02\x02\u{c42}\u{c40}\x03\x02\x02\x02\u{c42}\
	\u{c43}\x03\x02\x02\x02\u{c43}\u{c45}\x03\x02\x02\x02\u{c44}\u{c42}\x03\
	\x02\x02\x02\u{c45}\u{c61}\x05\u{88}\x45\x02\u{c46}\u{c48}\x07\x07\x02\x02\
	\u{c47}\u{c46}\x03\x02\x02\x02\u{c48}\u{c4b}\x03\x02\x02\x02\u{c49}\u{c47}\
	\x03\x02\x02\x02\u{c49}\u{c4a}\x03\x02\x02\x02\u{c4a}\u{c4c}\x03\x02\x02\
	\x02\u{c4b}\u{c49}\x03\x02\x02\x02\u{c4c}\u{c4e}\x05\u{10a}\u{86}\x02\u{c4d}\
	\u{c49}\x03\x02\x02\x02\u{c4e}\u{c4f}\x03\x02\x02\x02\u{c4f}\u{c4d}\x03\
	\x02\x02\x02\u{c4f}\u{c50}\x03\x02\x02\x02\u{c50}\u{c58}\x03\x02\x02\x02\
	\u{c51}\u{c53}\x07\x07\x02\x02\u{c52}\u{c51}\x03\x02\x02\x02\u{c53}\u{c56}\
	\x03\x02\x02\x02\u{c54}\u{c52}\x03\x02\x02\x02\u{c54}\u{c55}\x03\x02\x02\
	\x02\u{c55}\u{c57}\x03\x02\x02\x02\u{c56}\u{c54}\x03\x02\x02\x02\u{c57}\
	\u{c59}\x05\u{10c}\u{87}\x02\u{c58}\u{c54}\x03\x02\x02\x02\u{c58}\u{c59}\
	\x03\x02\x02\x02\u{c59}\u{c62}\x03\x02\x02\x02\u{c5a}\u{c5c}\x07\x07\x02\
	\x02\u{c5b}\u{c5a}\x03\x02\x02\x02\u{c5c}\u{c5f}\x03\x02\x02\x02\u{c5d}\
	\u{c5b}\x03\x02\x02\x02\u{c5d}\u{c5e}\x03\x02\x02\x02\u{c5e}\u{c60}\x03\
	\x02\x02\x02\u{c5f}\u{c5d}\x03\x02\x02\x02\u{c60}\u{c62}\x05\u{10c}\u{87}\
	\x02\u{c61}\u{c4d}\x03\x02\x02\x02\u{c61}\u{c5d}\x03\x02\x02\x02\u{c62}\
	\u{109}\x03\x02\x02\x02\u{c63}\u{c67}\x07\x5d\x02\x02\u{c64}\u{c66}\x07\
	\x07\x02\x02\u{c65}\u{c64}\x03\x02\x02\x02\u{c66}\u{c69}\x03\x02\x02\x02\
	\u{c67}\u{c65}\x03\x02\x02\x02\u{c67}\u{c68}\x03\x02\x02\x02\u{c68}\u{c6a}\
	\x03\x02\x02\x02\u{c69}\u{c67}\x03\x02\x02\x02\u{c6a}\u{c6e}\x07\x0b\x02\
	\x02\u{c6b}\u{c6d}\x05\u{14e}\u{a8}\x02\u{c6c}\u{c6b}\x03\x02\x02\x02\u{c6d}\
	\u{c70}\x03\x02\x02\x02\u{c6e}\u{c6c}\x03\x02\x02\x02\u{c6e}\u{c6f}\x03\
	\x02\x02\x02\u{c6f}\u{c71}\x03\x02\x02\x02\u{c70}\u{c6e}\x03\x02\x02\x02\
	\u{c71}\u{c72}\x05\u{158}\u{ad}\x02\u{c72}\u{c73}\x07\x1c\x02\x02\u{c73}\
	\u{c7b}\x05\x64\x33\x02\u{c74}\u{c76}\x07\x07\x02\x02\u{c75}\u{c74}\x03\
	\x02\x02\x02\u{c76}\u{c79}\x03\x02\x02\x02\u{c77}\u{c75}\x03\x02\x02\x02\
	\u{c77}\u{c78}\x03\x02\x02\x02\u{c78}\u{c7a}\x03\x02\x02\x02\u{c79}\u{c77}\
	\x03\x02\x02\x02\u{c7a}\u{c7c}\x07\x0a\x02\x02\u{c7b}\u{c77}\x03\x02\x02\
	\x02\u{c7b}\u{c7c}\x03\x02\x02\x02\u{c7c}\u{c7d}\x03\x02\x02\x02\u{c7d}\
	\u{c81}\x07\x0c\x02\x02\u{c7e}\u{c80}\x07\x07\x02\x02\u{c7f}\u{c7e}\x03\
	\x02\x02\x02\u{c80}\u{c83}\x03\x02\x02\x02\u{c81}\u{c7f}\x03\x02\x02\x02\
	\u{c81}\u{c82}\x03\x02\x02\x02\u{c82}\u{c84}\x03\x02\x02\x02\u{c83}\u{c81}\
	\x03\x02\x02\x02\u{c84}\u{c85}\x05\u{88}\x45\x02\u{c85}\u{10b}\x03\x02\x02\
	\x02\u{c86}\u{c8a}\x07\x5e\x02\x02\u{c87}\u{c89}\x07\x07\x02\x02\u{c88}\
	\u{c87}\x03\x02\x02\x02\u{c89}\u{c8c}\x03\x02\x02\x02\u{c8a}\u{c88}\x03\
	\x02\x02\x02\u{c8a}\u{c8b}\x03\x02\x02\x02\u{c8b}\u{c8d}\x03\x02\x02\x02\
	\u{c8c}\u{c8a}\x03\x02\x02\x02\u{c8d}\u{c8e}\x05\u{88}\x45\x02\u{c8e}\u{10d}\
	\x03\x02\x02\x02\u{c8f}\u{c93}\x07\x62\x02\x02\u{c90}\u{c92}\x07\x07\x02\
	\x02\u{c91}\u{c90}\x03\x02\x02\x02\u{c92}\u{c95}\x03\x02\x02\x02\u{c93}\
	\u{c91}\x03\x02\x02\x02\u{c93}\u{c94}\x03\x02\x02\x02\u{c94}\u{c96}\x03\
	\x02\x02\x02\u{c95}\u{c93}\x03\x02\x02\x02\u{c96}\u{ca0}\x05\u{98}\x4d\x02\
	\u{c97}\u{c99}\x09\x0c\x02\x02\u{c98}\u{c9a}\x05\u{98}\x4d\x02\u{c99}\u{c98}\
	\x03\x02\x02\x02\u{c99}\u{c9a}\x03\x02\x02\x02\u{c9a}\u{ca0}\x03\x02\x02\
	\x02\u{c9b}\u{ca0}\x07\x64\x02\x02\u{c9c}\u{ca0}\x07\x3b\x02\x02\u{c9d}\
	\u{ca0}\x07\x65\x02\x02\u{c9e}\u{ca0}\x07\x3c\x02\x02\u{c9f}\u{c8f}\x03\
	\x02\x02\x02\u{c9f}\u{c97}\x03\x02\x02\x02\u{c9f}\u{c9b}\x03\x02\x02\x02\
	\u{c9f}\u{c9c}\x03\x02\x02\x02\u{c9f}\u{c9d}\x03\x02\x02\x02\u{c9f}\u{c9e}\
	\x03\x02\x02\x02\u{ca0}\u{10f}\x03\x02\x02\x02\u{ca1}\u{ca3}\x05\x7c\x3f\
	\x02\u{ca2}\u{ca1}\x03\x02\x02\x02\u{ca2}\u{ca3}\x03\x02\x02\x02\u{ca3}\
	\u{ca4}\x03\x02\x02\x02\u{ca4}\u{ca8}\x07\x27\x02\x02\u{ca5}\u{ca7}\x07\
	\x07\x02\x02\u{ca6}\u{ca5}\x03\x02\x02\x02\u{ca7}\u{caa}\x03\x02\x02\x02\
	\u{ca8}\u{ca6}\x03\x02\x02\x02\u{ca8}\u{ca9}\x03\x02\x02\x02\u{ca9}\u{cad}\
	\x03\x02\x02\x02\u{caa}\u{ca8}\x03\x02\x02\x02\u{cab}\u{cae}\x05\u{158}\
	\u{ad}\x02\u{cac}\u{cae}\x07\x4a\x02\x02\u{cad}\u{cab}\x03\x02\x02\x02\u{cad}\
	\u{cac}\x03\x02\x02\x02\u{cae}\u{111}\x03\x02\x02\x02\u{caf}\u{cb0}\x09\
	\x0d\x02\x02\u{cb0}\u{113}\x03\x02\x02\x02\u{cb1}\u{cb2}\x09\x0e\x02\x02\
	\u{cb2}\u{115}\x03\x02\x02\x02\u{cb3}\u{cb4}\x09\x0f\x02\x02\u{cb4}\u{117}\
	\x03\x02\x02\x02\u{cb5}\u{cb6}\x09\x10\x02\x02\u{cb6}\u{119}\x03\x02\x02\
	\x02\u{cb7}\u{cb8}\x09\x11\x02\x02\u{cb8}\u{11b}\x03\x02\x02\x02\u{cb9}\
	\u{cba}\x09\x12\x02\x02\u{cba}\u{11d}\x03\x02\x02\x02\u{cbb}\u{cbc}\x09\
	\x13\x02\x02\u{cbc}\u{11f}\x03\x02\x02\x02\u{cbd}\u{cbe}\x09\x14\x02\x02\
	\u{cbe}\u{121}\x03\x02\x02\x02\u{cbf}\u{cc5}\x07\x16\x02\x02\u{cc0}\u{cc5}\
	\x07\x17\x02\x02\u{cc1}\u{cc5}\x07\x15\x02\x02\u{cc2}\u{cc5}\x07\x14\x02\
	\x02\u{cc3}\u{cc5}\x05\u{126}\u{94}\x02\u{cc4}\u{cbf}\x03\x02\x02\x02\u{cc4}\
	\u{cc0}\x03\x02\x02\x02\u{cc4}\u{cc1}\x03\x02\x02\x02\u{cc4}\u{cc2}\x03\
	\x02\x02\x02\u{cc4}\u{cc3}\x03\x02\x02\x02\u{cc5}\u{123}\x03\x02\x02\x02\
	\u{cc6}\u{ccb}\x07\x16\x02\x02\u{cc7}\u{ccb}\x07\x17\x02\x02\u{cc8}\u{cc9}\
	\x07\x1b\x02\x02\u{cc9}\u{ccb}\x05\u{126}\u{94}\x02\u{cca}\u{cc6}\x03\x02\
	\x02\x02\u{cca}\u{cc7}\x03\x02\x02\x02\u{cca}\u{cc8}\x03\x02\x02\x02\u{ccb}\
	\u{125}\x03\x02\x02\x02\u{ccc}\u{ccd}\x09\x15\x02\x02\u{ccd}\u{127}\x03\
	\x02\x02\x02\u{cce}\u{cd0}\x07\x07\x02\x02\u{ccf}\u{cce}\x03\x02\x02\x02\
	\u{cd0}\u{cd3}\x03\x02\x02\x02\u{cd1}\u{ccf}\x03\x02\x02\x02\u{cd1}\u{cd2}\
	\x03\x02\x02\x02\u{cd2}\u{cd4}\x03\x02\x02\x02\u{cd3}\u{cd1}\x03\x02\x02\
	\x02\u{cd4}\u{cde}\x07\x09\x02\x02\u{cd5}\u{cd7}\x07\x07\x02\x02\u{cd6}\
	\u{cd5}\x03\x02\x02\x02\u{cd7}\u{cda}\x03\x02\x02\x02\u{cd8}\u{cd6}\x03\
	\x02\x02\x02\u{cd8}\u{cd9}\x03\x02\x02\x02\u{cd9}\u{cdb}\x03\x02\x02\x02\
	\u{cda}\u{cd8}\x03\x02\x02\x02\u{cdb}\u{cde}\x05\u{12a}\u{96}\x02\u{cdc}\
	\u{cde}\x07\x27\x02\x02\u{cdd}\u{cd1}\x03\x02\x02\x02\u{cdd}\u{cd8}\x03\
	\x02\x02\x02\u{cdd}\u{cdc}\x03\x02\x02\x02\u{cde}\u{129}\x03\x02\x02\x02\
	\u{cdf}\u{ce0}\x07\x2f\x02\x02\u{ce0}\u{ce1}\x07\x09\x02\x02\u{ce1}\u{12b}\
	\x03\x02\x02\x02\u{ce2}\u{ce5}\x05\u{14e}\u{a8}\x02\u{ce3}\u{ce5}\x05\u{130}\
	\u{99}\x02\u{ce4}\u{ce2}\x03\x02\x02\x02\u{ce4}\u{ce3}\x03\x02\x02\x02\u{ce5}\
	\u{ce6}\x03\x02\x02\x02\u{ce6}\u{ce4}\x03\x02\x02\x02\u{ce6}\u{ce7}\x03\
	\x02\x02\x02\u{ce7}\u{12d}\x03\x02\x02\x02\u{ce8}\u{ceb}\x05\u{14e}\u{a8}\
	\x02\u{ce9}\u{ceb}\x05\u{148}\u{a5}\x02\u{cea}\u{ce8}\x03\x02\x02\x02\u{cea}\
	\u{ce9}\x03\x02\x02\x02\u{ceb}\u{cec}\x03\x02\x02\x02\u{cec}\u{cea}\x03\
	\x02\x02\x02\u{cec}\u{ced}\x03\x02\x02\x02\u{ced}\u{12f}\x03\x02\x02\x02\
	\u{cee}\u{cf7}\x05\u{136}\u{9c}\x02\u{cef}\u{cf7}\x05\u{138}\u{9d}\x02\u{cf0}\
	\u{cf7}\x05\u{13a}\u{9e}\x02\u{cf1}\u{cf7}\x05\u{142}\u{a2}\x02\u{cf2}\u{cf7}\
	\x05\u{144}\u{a3}\x02\u{cf3}\u{cf7}\x05\u{146}\u{a4}\x02\u{cf4}\u{cf7}\x05\
	\u{148}\u{a5}\x02\u{cf5}\u{cf7}\x05\u{14c}\u{a7}\x02\u{cf6}\u{cee}\x03\x02\
	\x02\x02\u{cf6}\u{cef}\x03\x02\x02\x02\u{cf6}\u{cf0}\x03\x02\x02\x02\u{cf6}\
	\u{cf1}\x03\x02\x02\x02\u{cf6}\u{cf2}\x03\x02\x02\x02\u{cf6}\u{cf3}\x03\
	\x02\x02\x02\u{cf6}\u{cf4}\x03\x02\x02\x02\u{cf6}\u{cf5}\x03\x02\x02\x02\
	\u{cf7}\u{cfb}\x03\x02\x02\x02\u{cf8}\u{cfa}\x07\x07\x02\x02\u{cf9}\u{cf8}\
	\x03\x02\x02\x02\u{cfa}\u{cfd}\x03\x02\x02\x02\u{cfb}\u{cf9}\x03\x02\x02\
	\x02\u{cfb}\u{cfc}\x03\x02\x02\x02\u{cfc}\u{131}\x03\x02\x02\x02\u{cfd}\
	\u{cfb}\x03\x02\x02\x02\u{cfe}\u{d00}\x05\u{134}\u{9b}\x02\u{cff}\u{cfe}\
	\x03\x02\x02\x02\u{d00}\u{d01}\x03\x02\x02\x02\u{d01}\u{cff}\x03\x02\x02\
	\x02\u{d01}\u{d02}\x03\x02\x02\x02\u{d02}\u{133}\x03\x02\x02\x02\u{d03}\
	\u{d0c}\x05\u{14e}\u{a8}\x02\u{d04}\u{d08}\x07\x7c\x02\x02\u{d05}\u{d07}\
	\x07\x07\x02\x02\u{d06}\u{d05}\x03\x02\x02\x02\u{d07}\u{d0a}\x03\x02\x02\
	\x02\u{d08}\u{d06}\x03\x02\x02\x02\u{d08}\u{d09}\x03\x02\x02\x02\u{d09}\
	\u{d0c}\x03\x02\x02\x02\u{d0a}\u{d08}\x03\x02\x02\x02\u{d0b}\u{d03}\x03\
	\x02\x02\x02\u{d0b}\u{d04}\x03\x02\x02\x02\u{d0c}\u{135}\x03\x02\x02\x02\
	\u{d0d}\u{d0e}\x09\x16\x02\x02\u{d0e}\u{137}\x03\x02\x02\x02\u{d0f}\u{d10}\
	\x09\x17\x02\x02\u{d10}\u{139}\x03\x02\x02\x02\u{d11}\u{d12}\x09\x18\x02\
	\x02\u{d12}\u{13b}\x03\x02\x02\x02\u{d13}\u{d14}\x09\x19\x02\x02\u{d14}\
	\u{13d}\x03\x02\x02\x02\u{d15}\u{d17}\x05\u{140}\u{a1}\x02\u{d16}\u{d15}\
	\x03\x02\x02\x02\u{d17}\u{d18}\x03\x02\x02\x02\u{d18}\u{d16}\x03\x02\x02\
	\x02\u{d18}\u{d19}\x03\x02\x02\x02\u{d19}\u{13f}\x03\x02\x02\x02\u{d1a}\
	\u{d1e}\x05\u{14a}\u{a6}\x02\u{d1b}\u{d1d}\x07\x07\x02\x02\u{d1c}\u{d1b}\
	\x03\x02\x02\x02\u{d1d}\u{d20}\x03\x02\x02\x02\u{d1e}\u{d1c}\x03\x02\x02\
	\x02\u{d1e}\u{d1f}\x03\x02\x02\x02\u{d1f}\u{d2a}\x03\x02\x02\x02\u{d20}\
	\u{d1e}\x03\x02\x02\x02\u{d21}\u{d25}\x05\u{13c}\u{9f}\x02\u{d22}\u{d24}\
	\x07\x07\x02\x02\u{d23}\u{d22}\x03\x02\x02\x02\u{d24}\u{d27}\x03\x02\x02\
	\x02\u{d25}\u{d23}\x03\x02\x02\x02\u{d25}\u{d26}\x03\x02\x02\x02\u{d26}\
	\u{d2a}\x03\x02\x02\x02\u{d27}\u{d25}\x03\x02\x02\x02\u{d28}\u{d2a}\x05\
	\u{14e}\u{a8}\x02\u{d29}\u{d1a}\x03\x02\x02\x02\u{d29}\u{d21}\x03\x02\x02\
	\x02\u{d29}\u{d28}\x03\x02\x02\x02\u{d2a}\u{141}\x03\x02\x02\x02\u{d2b}\
	\u{d2c}\x09\x1a\x02\x02\u{d2c}\u{143}\x03\x02\x02\x02\u{d2d}\u{d2e}\x07\
	\u{81}\x02\x02\u{d2e}\u{145}\x03\x02\x02\x02\u{d2f}\u{d30}\x09\x1b\x02\x02\
	\u{d30}\u{147}\x03\x02\x02\x02\u{d31}\u{d32}\x09\x1c\x02\x02\u{d32}\u{149}\
	\x03\x02\x02\x02\u{d33}\u{d34}\x07\u{86}\x02\x02\u{d34}\u{14b}\x03\x02\x02\
	\x02\u{d35}\u{d36}\x09\x1d\x02\x02\u{d36}\u{14d}\x03\x02\x02\x02\u{d37}\
	\u{d3a}\x05\u{150}\u{a9}\x02\u{d38}\u{d3a}\x05\u{152}\u{aa}\x02\u{d39}\u{d37}\
	\x03\x02\x02\x02\u{d39}\u{d38}\x03\x02\x02\x02\u{d3a}\u{d3e}\x03\x02\x02\
	\x02\u{d3b}\u{d3d}\x07\x07\x02\x02\u{d3c}\u{d3b}\x03\x02\x02\x02\u{d3d}\
	\u{d40}\x03\x02\x02\x02\u{d3e}\u{d3c}\x03\x02\x02\x02\u{d3e}\u{d3f}\x03\
	\x02\x02\x02\u{d3f}\u{14f}\x03\x02\x02\x02\u{d40}\u{d3e}\x03\x02\x02\x02\
	\u{d41}\u{d45}\x05\u{154}\u{ab}\x02\u{d42}\u{d44}\x07\x07\x02\x02\u{d43}\
	\u{d42}\x03\x02\x02\x02\u{d44}\u{d47}\x03\x02\x02\x02\u{d45}\u{d43}\x03\
	\x02\x02\x02\u{d45}\u{d46}\x03\x02\x02\x02\u{d46}\u{d4b}\x03\x02\x02\x02\
	\u{d47}\u{d45}\x03\x02\x02\x02\u{d48}\u{d4b}\x07\x2a\x02\x02\u{d49}\u{d4b}\
	\x07\x2c\x02\x02\u{d4a}\u{d41}\x03\x02\x02\x02\u{d4a}\u{d48}\x03\x02\x02\
	\x02\u{d4a}\u{d49}\x03\x02\x02\x02\u{d4b}\u{d4c}\x03\x02\x02\x02\u{d4c}\
	\u{d4d}\x05\u{156}\u{ac}\x02\u{d4d}\u{151}\x03\x02\x02\x02\u{d4e}\u{d52}\
	\x05\u{154}\u{ab}\x02\u{d4f}\u{d51}\x07\x07\x02\x02\u{d50}\u{d4f}\x03\x02\
	\x02\x02\u{d51}\u{d54}\x03\x02\x02\x02\u{d52}\u{d50}\x03\x02\x02\x02\u{d52}\
	\u{d53}\x03\x02\x02\x02\u{d53}\u{d58}\x03\x02\x02\x02\u{d54}\u{d52}\x03\
	\x02\x02\x02\u{d55}\u{d58}\x07\x2a\x02\x02\u{d56}\u{d58}\x07\x2c\x02\x02\
	\u{d57}\u{d4e}\x03\x02\x02\x02\u{d57}\u{d55}\x03\x02\x02\x02\u{d57}\u{d56}\
	\x03\x02\x02\x02\u{d58}\u{d59}\x03\x02\x02\x02\u{d59}\u{d5b}\x07\x0d\x02\
	\x02\u{d5a}\u{d5c}\x05\u{156}\u{ac}\x02\u{d5b}\u{d5a}\x03\x02\x02\x02\u{d5c}\
	\u{d5d}\x03\x02\x02\x02\u{d5d}\u{d5b}\x03\x02\x02\x02\u{d5d}\u{d5e}\x03\
	\x02\x02\x02\u{d5e}\u{d5f}\x03\x02\x02\x02\u{d5f}\u{d60}\x07\x0e\x02\x02\
	\u{d60}\u{153}\x03\x02\x02\x02\u{d61}\u{d62}\x09\x02\x02\x02\u{d62}\u{d66}\
	\x09\x1e\x02\x02\u{d63}\u{d65}\x07\x07\x02\x02\u{d64}\u{d63}\x03\x02\x02\
	\x02\u{d65}\u{d68}\x03\x02\x02\x02\u{d66}\u{d64}\x03\x02\x02\x02\u{d66}\
	\u{d67}\x03\x02\x02\x02\u{d67}\u{d69}\x03\x02\x02\x02\u{d68}\u{d66}\x03\
	\x02\x02\x02\u{d69}\u{d6a}\x07\x1c\x02\x02\u{d6a}\u{155}\x03\x02\x02\x02\
	\u{d6b}\u{d6e}\x05\x26\x14\x02\u{d6c}\u{d6e}\x05\x6c\x37\x02\u{d6d}\u{d6b}\
	\x03\x02\x02\x02\u{d6d}\u{d6c}\x03\x02\x02\x02\u{d6e}\u{157}\x03\x02\x02\
	\x02\u{d6f}\u{d70}\x09\x1f\x02\x02\u{d70}\u{159}\x03\x02\x02\x02\u{d71}\
	\u{d7c}\x05\u{158}\u{ad}\x02\u{d72}\u{d74}\x07\x07\x02\x02\u{d73}\u{d72}\
	\x03\x02\x02\x02\u{d74}\u{d77}\x03\x02\x02\x02\u{d75}\u{d73}\x03\x02\x02\
	\x02\u{d75}\u{d76}\x03\x02\x02\x02\u{d76}\u{d78}\x03\x02\x02\x02\u{d77}\
	\u{d75}\x03\x02\x02\x02\u{d78}\u{d79}\x07\x09\x02\x02\u{d79}\u{d7b}\x05\
	\u{158}\u{ad}\x02\u{d7a}\u{d75}\x03\x02\x02\x02\u{d7b}\u{d7e}\x03\x02\x02\
	\x02\u{d7c}\u{d7a}\x03\x02\x02\x02\u{d7c}\u{d7d}\x03\x02\x02\x02\u{d7d}\
	\u{15b}\x03\x02\x02\x02\u{d7e}\u{d7c}\x03\x02\x02\x02\u{214}\u{15d}\u{162}\
	\u{168}\u{170}\u{176}\u{17b}\u{181}\u{18b}\u{194}\u{19b}\u{1a2}\u{1a9}\u{1ae}\
	\u{1b3}\u{1b9}\u{1bb}\u{1c0}\u{1c8}\u{1cb}\u{1d2}\u{1d5}\u{1db}\u{1e2}\u{1e6}\
	\u{1eb}\u{1f2}\u{1fc}\u{1ff}\u{206}\u{209}\u{20c}\u{211}\u{218}\u{21c}\u{221}\
	\u{225}\u{22a}\u{231}\u{235}\u{23a}\u{23e}\u{243}\u{24a}\u{24e}\u{251}\u{257}\
	\u{25a}\u{262}\u{269}\u{272}\u{279}\u{280}\u{286}\u{28c}\u{290}\u{292}\u{297}\
	\u{29d}\u{2a0}\u{2a5}\u{2ad}\u{2b4}\u{2bb}\u{2bf}\u{2c5}\u{2cc}\u{2d2}\u{2d9}\
	\u{2e1}\u{2e7}\u{2ee}\u{2f3}\u{2fa}\u{303}\u{30a}\u{311}\u{317}\u{31d}\u{321}\
	\u{326}\u{32c}\u{331}\u{338}\u{33f}\u{343}\u{349}\u{350}\u{357}\u{35d}\u{363}\
	\u{36a}\u{371}\u{378}\u{37c}\u{383}\u{389}\u{38f}\u{395}\u{39c}\u{3a0}\u{3a5}\
	\u{3ac}\u{3b0}\u{3b5}\u{3b9}\u{3bf}\u{3c6}\u{3cd}\u{3d3}\u{3d9}\u{3dd}\u{3df}\
	\u{3e4}\u{3ea}\u{3f0}\u{3f7}\u{3fb}\u{3fe}\u{404}\u{408}\u{40d}\u{414}\u{419}\
	\u{41e}\u{425}\u{42c}\u{433}\u{437}\u{43c}\u{440}\u{445}\u{449}\u{450}\u{454}\
	\u{459}\u{45f}\u{466}\u{46d}\u{471}\u{477}\u{47e}\u{485}\u{48b}\u{491}\u{495}\
	\u{49a}\u{4a0}\u{4a6}\u{4aa}\u{4af}\u{4b6}\u{4bb}\u{4c0}\u{4c5}\u{4ca}\u{4ce}\
	\u{4d3}\u{4da}\u{4df}\u{4e1}\u{4e6}\u{4e9}\u{4ee}\u{4f2}\u{4f7}\u{4fb}\u{4fe}\
	\u{501}\u{506}\u{50a}\u{50d}\u{50f}\u{515}\u{51b}\u{521}\u{528}\u{52f}\u{536}\
	\u{53a}\u{53f}\u{543}\u{546}\u{54c}\u{553}\u{55a}\u{55e}\u{563}\u{56a}\u{571}\
	\u{575}\u{57a}\u{57f}\u{585}\u{58c}\u{593}\u{599}\u{59f}\u{5a3}\u{5a5}\u{5aa}\
	\u{5b0}\u{5b6}\u{5bd}\u{5c1}\u{5c7}\u{5ce}\u{5d2}\u{5d8}\u{5df}\u{5e5}\u{5eb}\
	\u{5f2}\u{5f9}\u{5fd}\u{602}\u{606}\u{609}\u{60f}\u{616}\u{61d}\u{621}\u{626}\
	\u{62a}\u{630}\u{639}\u{63d}\u{642}\u{649}\u{64d}\u{652}\u{65b}\u{662}\u{668}\
	\u{66e}\u{672}\u{678}\u{67b}\u{681}\u{685}\u{68a}\u{68e}\u{691}\u{697}\u{69b}\
	\u{69f}\u{6a4}\u{6aa}\u{6b2}\u{6b9}\u{6bf}\u{6c6}\u{6ca}\u{6cd}\u{6d1}\u{6d6}\
	\u{6dc}\u{6e0}\u{6e6}\u{6ed}\u{6f0}\u{6f6}\u{6fd}\u{706}\u{70b}\u{710}\u{717}\
	\u{71c}\u{720}\u{726}\u{72a}\u{72f}\u{738}\u{73f}\u{745}\u{74a}\u{750}\u{755}\
	\u{75a}\u{765}\u{768}\u{76b}\u{76f}\u{771}\u{778}\u{77f}\u{784}\u{78a}\u{791}\
	\u{799}\u{79f}\u{7a6}\u{7ab}\u{7b3}\u{7b7}\u{7bd}\u{7c6}\u{7cb}\u{7d1}\u{7d5}\
	\u{7da}\u{7e1}\u{7ee}\u{7f3}\u{7fc}\u{800}\u{805}\u{808}\u{810}\u{817}\u{81d}\
	\u{824}\u{82b}\u{831}\u{839}\u{840}\u{848}\u{84f}\u{856}\u{85e}\u{867}\u{86c}\
	\u{86e}\u{875}\u{87c}\u{883}\u{88e}\u{895}\u{89d}\u{8a3}\u{8ab}\u{8b2}\u{8ba}\
	\u{8c1}\u{8c8}\u{8cf}\u{8d6}\u{8dc}\u{8e7}\u{8ea}\u{8f0}\u{8f8}\u{8ff}\u{905}\
	\u{90c}\u{913}\u{919}\u{920}\u{928}\u{92e}\u{935}\u{93c}\u{942}\u{948}\u{94c}\
	\u{951}\u{95a}\u{960}\u{963}\u{966}\u{96a}\u{96f}\u{973}\u{978}\u{981}\u{988}\
	\u{98f}\u{995}\u{99b}\u{99f}\u{9a4}\u{9ad}\u{9b4}\u{9bb}\u{9c1}\u{9c7}\u{9cb}\
	\u{9d0}\u{9d3}\u{9d8}\u{9dd}\u{9e4}\u{9eb}\u{9ee}\u{9f1}\u{9f6}\u{a09}\u{a0f}\
	\u{a16}\u{a1f}\u{a26}\u{a2d}\u{a33}\u{a39}\u{a3d}\u{a42}\u{a45}\u{a4d}\u{a52}\
	\u{a54}\u{a5d}\u{a5f}\u{a6a}\u{a71}\u{a7c}\u{a83}\u{a8c}\u{a90}\u{a95}\u{a9c}\
	\u{a9f}\u{aa5}\u{aae}\u{ab5}\u{abb}\u{ac1}\u{ac5}\u{acc}\u{ad3}\u{ad7}\u{ad9}\
	\u{adf}\u{ae6}\u{aeb}\u{af0}\u{af7}\u{afe}\u{b02}\u{b07}\u{b0b}\u{b10}\u{b14}\
	\u{b18}\u{b1e}\u{b25}\u{b2c}\u{b2f}\u{b34}\u{b38}\u{b41}\u{b48}\u{b4d}\u{b51}\
	\u{b54}\u{b5a}\u{b61}\u{b68}\u{b6f}\u{b74}\u{b79}\u{b7d}\u{b82}\u{b89}\u{b8e}\
	\u{b91}\u{b97}\u{b9d}\u{ba4}\u{bab}\u{bb2}\u{bb5}\u{bbe}\u{bc2}\u{bc7}\u{bce}\
	\u{bd5}\u{bda}\u{be0}\u{be9}\u{bf0}\u{bf6}\u{bfc}\u{c00}\u{c05}\u{c0c}\u{c11}\
	\u{c17}\u{c1e}\u{c23}\u{c25}\u{c2a}\u{c30}\u{c39}\u{c42}\u{c49}\u{c4f}\u{c54}\
	\u{c58}\u{c5d}\u{c61}\u{c67}\u{c6e}\u{c77}\u{c7b}\u{c81}\u{c8a}\u{c93}\u{c99}\
	\u{c9f}\u{ca2}\u{ca8}\u{cad}\u{cc4}\u{cca}\u{cd1}\u{cd8}\u{cdd}\u{ce4}\u{ce6}\
	\u{cea}\u{cec}\u{cf6}\u{cfb}\u{d01}\u{d08}\u{d0b}\u{d18}\u{d1e}\u{d25}\u{d29}\
	\u{d39}\u{d3e}\u{d45}\u{d4a}\u{d52}\u{d57}\u{d5d}\u{d66}\u{d6d}\u{d75}\u{d7c}";

